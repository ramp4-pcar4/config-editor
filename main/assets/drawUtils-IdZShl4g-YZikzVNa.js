import{i3 as v,aM as b,n$ as K,l5 as A,d4 as B,d7 as d,b8 as G,n2 as Q,d6 as T,d9 as q,db as z,nM as U,nK as W}from"./index-BeTPrQ6f.js";import{R as X}from"./curveOperationUtils-ClbIvhut-17Ywjz26.js";function R(n,e,i,s){if(n.type==="point")return n.x+=e,n.y+=i,n.hasZ&&s!=null,n;if(n.type==="multipoint"){const a=n.points;for(let c=0;c<a.length;c++)a[c]=O(a[c],e,i,s);return n}if(n.type==="extent")return n.xmin+=e,n.xmax+=e,n.ymin+=i,n.ymax+=i,n;const t=n.type==="polyline"?n.curvePaths??n.paths:n.curveRings??n.rings,o=Q(n);for(let a=0;a<t.length;a++){const c=t[a];for(let y=0;y<c.length;y++)c[y]=k(c[y],e,i,s)}return"paths"in n?o?n.curvePaths=t:n.paths=t:o?n.curveRings=t:n.rings=t,n}function F(n,e,i,s,t){const o=n.clone();if(t){const{resolution:a}=s;R(o,e*a,-i*a)}else{const{dxMap:a,dyMap:c}=$(e,i,s);R(o,a,c)}return o}function $(n,e,i){const s=i.state.inverseTransform;return{dxMap:s[0]*n+s[2]*e,dyMap:s[1]*n+s[3]*e}}function O(n,e,i,s){return S(n,n[0]+e,n[1]+i,n[2]!=null&&s!=null?n[2]+s:void 0)}function k(n,e,i,s){const t=O(d(n),e,i,s);if(T(n))return t;if(q(n)){const[,c,y]=n.b;return{b:[t,[c[0]+e,c[1]+i],[y[0]+e,y[1]+i]]}}if(z(n)){const[,c]=n.c;return{c:[t,[c[0]+e,c[1]+i]]}}const[,o,...a]=n.a;return{a:[t,[o[0]+e,o[1]+i],...a]}}function H(n,e,i,s){if(n.type==="point"){const{x:u,y:f}=n,m=s?s[0]:u,l=s?s[1]:f,x=n.clone(),p=(u-m)*e+m,r=(f-l)*i+l;return x.x=p,x.y=r,x}if(n.type==="extent"){const{xmin:u,xmax:f,ymin:m,ymax:l}=n,x=s?s[0]:(u+f)/2,p=s?s[1]:(l+m)/2,r=n.clone();if(r.xmin=(u-x)*e+x,r.ymax=(l-p)*i+p,r.xmax=(f-x)*e+x,r.ymin=(m-p)*i+p,r.xmin>r.xmax){const h=r.xmin,M=r.xmax;r.xmin=M,r.xmax=h}if(r.ymin>r.ymax){const h=r.ymin,M=r.ymax;r.ymin=M,r.ymax=h}return r}let t=null;if(!s){t=v(n);const u=b(),f=K(u,t);if(!f)return n.clone();const[m,l,x,p]=f;s=[(m+x)/2,(l+p)/2]}const[o,a]=s;if(n.type==="multipoint"){const u=n.clone(),f=u.points;for(let m=0;m<f.length;m++){const l=f[m],[x,p]=l,r=(x-o)*e+o,h=(p-a)*i+a;f[m]=S(l,r,h,void 0)}return u.points=f,u}const c=n.clone();t??(t=v(n));const y=c.type==="polygon",g=y?c.curveRings??c.rings:c.curvePaths??c.paths;if(!s){const u=b(),f=K(u,g,!1,!1);if(!f)return c;s=A(f)}for(const u of g){let f=null;const m=y&&u.length>0&&B(d(u[0]),d(u.at(-1)));for(let l=0;l<u.length;l++){const x=u[l];u[l]=C(x,e,i,o,a,f),f=x}m&&(u[0]=[...d(u.at(-1))])}return c}function P(n,e,i,s,t){const[o,a,...c]=n;return[(o-s)*e+s,(a-t)*i+t,...c]}function C(n,e,i,s,t,o){if(T(n))return P(n,e,i,s,t);if(q(n)){const[V,Z,j]=n.b.map(w=>P(w,e,i,s,t));return{b:[V,Z,j]}}if(!o)return n;const a=d(o),c=z(n)?U(a,n):n,[y,g,u,f,m,l,x]=c.a,p=m??0,r=l??Math.hypot(y[0]-g[0],y[1]-g[1]),h=x??1,M=X(s,t,1,0,0,1,e,i);return W(a,{a:[[...y],[...g],u,f,p,r,h]},M)}function I(n,e,i,s,t,o){const a=Math.sqrt((i-n)*(i-n)+(s-e)*(s-e));return Math.sqrt((t-n)*(t-n)+(o-e)*(o-e))/a}function J(n,e,i,s=!1){const t=Math.atan2(e.y-i.y,e.x-i.x)-Math.atan2(n.y-i.y,n.x-i.x),o=Math.atan2(Math.sin(t),Math.cos(t));return s?o:G(o)}function S(n,e,i,s){const t=[e,i];return n.length>2&&t.push(s??n[2]),n.length>3&&t.push(n[3]),t}export{J as A,F as K,H as Q,$ as T,I as V};
