import{bd as V,cV as Ee,R as X,a8 as K,z as Ve,cX as F,E as ze,v as ne,I as He,t as Fe,dP as qe,k as ae,bc as Be,G as Ne,kc as le,b_ as Qe,j0 as We,ao as he,ah as $e,b as Je,jX as k}from"./index-V75RkAZg.js";import{T as Ge,j as Ke}from"./diffUtils-BSe9IE26-BuVfek0e.js";import{C as x,I as R}from"./enums-qHpGJ28Q-CmnLAccm.js";import{U as Ye}from"./workers-0oosFQiO-Cx5QIW18.js";import{$ as P,G as je,Q as Xe}from"./Rect-KI3be8Nv-Brin7FGu.js";import{D as O,L as ce,A as B,U as Ze,G as Re,n as C}from"./enums-DBi1-Mm2-CUS1pvQe.js";import{H as Me,O as Pe}from"./Texture-DXSFJsEu-iyb9Qqd0.js";import{o as Z}from"./pbf-Ijhb7ANA-GGRTg74t.js";import{B as et}from"./rasterizingUtils-B8CPqgVl-DF9hy09B.js";import{X as ue,T as A,R as Ae,k as tt}from"./Tile-DvzRai0K-rf52_D9Y.js";import{i as st}from"./LRUCache-BLmkvs7b-BsSTmLq7.js";import{R as it,D as rt,G as ot,H as nt}from"./mat3-DOnW3DjW-C3hbW9XY.js";import{e as z,E as N,r as at}from"./MapView-BcnxJC0k-DSzdMEdd.js";import{i as ye}from"./memoryEstimations-iHVpvWPf-B1nJmmow.js";import{u as D,N as U}from"./VertexArrayObject-DTkLCIKs-CYJyzqWU.js";import{p as v,b as W,a as ee,s as lt,c as ht,u as ct,n as L,i as ut}from"./config-DB0LnTDt-CYa9nhWp.js";import{H as Le}from"./WGLContainer-CF3AeUnM-cSPpaldL.js";import{V as Oe}from"./TileInfo-owTCOSRx-2r7NkIk9.js";import{o as yt}from"./signal-DxzURL18-0RAxY8TY.js";import{h as dt}from"./TileContainer-Dc8VVA_r-CDCKnlIN.js";import{O as _t}from"./PooledRBush-J5-OtqBl-CXbBUrRT.js";import{n as de,q as _e,e as pe,J as pt}from"./SourceLayerData-DFLKou4m-bPhN0MLn.js";import{D as ft}from"./LayerView2D-CCfp06E--Wd_YCmM7.js";import{v as gt}from"./LayerView-D3XoMhlx-BPhCvomp.js";import{n as mt}from"./RefreshableLayerView-CB9NNXxL-CmA9SZYU.js";import{i as fe}from"./Scheduler-Br-2v2ys-DRVzYeHz.js";import"./Queue-B8H6jIv7-B9qPWfGK.js";import"./intl-DLmy-Li5-CbupOHia.js";import"./getDataTypeBytes-HSdrWtlL-ClHsCcSN.js";import"./floatRGBA-YJlz5IlR-CVqaG7md.js";import"./defaultCIMValues-gWpu7WSC-cjxb95kj.js";import"./enums-f9UUstHQ-hLTu4V1l.js";import"./definitions-CBIQmVpq-o3EUznKY.js";import"./vec2-BnynUbeJ-CKtGJQAy.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./ReactiveMap-BaMcQuG3-DrguFqM2.js";import"./quickselect-DHTstthl-Ds_Aj0x5.js";import"./Query-CxQYWcUQ-uPfOe2wz.js";import"./Field-Cj6Pz3TI-CLTDqp9X.js";import"./fieldType-VTpxE-EM-Eu6FRLce.js";import"./TimeExtent-gZaEUVeW-B3MjAsHp.js";import"./MemCache-BCippCv6-GgFWDHQN.js";import"./globalCss-CFN4F315-Ctib04SM.js";import"./Version-BTMwSXf1-z-x5RV_T.js";import"./CollectionFlattener-9hYRBLDX-Bw0jowzo.js";import"./projection-m8vi7Cxv-MPQBAE9_.js";import"./jsxFactory-C5LxVioS-v57fvz1-.js";import"./uuid-Dj9mdEVg-BaKSCiyT.js";import"./UpdatingHandles-DBzjq66S--bh3qoX_.js";import"./Map-DbZVFU-I-Du-ai5MG.js";import"./Basemap-DxWxjcEH-rQTh1mLu.js";import"./loadAll-BIhJ1RSe-B99U4CNe.js";import"./PortalItem-CJetnHeq-BmR4deil.js";import"./mat4f32-CiZjBg9k-CUm34GoR.js";import"./mat4-BFStKTjU-DR_gzsZK.js";import"./Layer-B8q-l4yV-D3Rc0sPb.js";import"./GraphicsCollection-rAFZo1AJ-Ca7ddbf2.js";import"./HeightModelInfo-BkDck4B0-BG4roXYR.js";import"./timeZoneUtils-z3WjfjXQ-FDRCpCci.js";import"./IViewEvents-BE10MM98-CvMfjolG.js";import"./HighlightDefaults-Cg50f_1y-C-MDMrzm.js";import"./a11yUtils-C2ydunC--CPPkIt2r.js";import"./heightModelInfoUtils-CI93rfC7-DBRyTjbL.js";import"./ViewingMode-CyR_b1T8-_s7_Gbsk.js";import"./vec2f64-CEUyUoff-BBc0aQ6D.js";import"./mat2d-BQA-1WB--Pnyy0dhf.js";import"./normalizeUtils-b-vZURob-AxvZJOZv.js";import"./utils-DuaeuwP5-D_EqUpgO.js";import"./utils-Jw-4AGsF-BLOvp60n.js";import"./mat2df32-BCnkwMW8-BLRY8i4P.js";import"./vec2f32-CVhmN3Me-DxoqVD7C.js";import"./vec32-BuqRmYBM-DetTgtCf.js";import"./unitBezier-DhyPAQO8-B9kUb8N6.js";import"./imageUtils-DEFspgr5-C53B2KbF.js";import"./themeUtils-RB4IoNvm-uO-dsvgO.js";import"./ColorBackground-Dcc9SnXm-BVlH8Ed_.js";import"./TileKey-B_6qmYK--BtZdR-Xy.js";import"./dataViewUtils-xig9T3UA-BMtA_edW.js";import"./VertexElementDescriptor-BAy1DPb3-BOhpDZGx.js";import"./BoundingBox-D9JxeQeA-SaxmeIkg.js";import"./ProgramTemplate-CBS0ERm4-cXQogPLG.js";import"./vec3f32-BS0cezmI-B_madU1n.js";import"./Container-BdpN3llD-CIDkgCaC.js";import"./EffectView-Bw7SZPlx-Gh8cXVFx.js";import"./parser-hXQyB-Qx-CHgeEqM_.js";import"./earcut-XDcq3zAf-BcwyrT7l.js";import"./featureConversionUtils-DRaHTjrY-COshiQK_.js";import"./OptimizedFeatureSet-D6mgsKNr-HQQUKWvo.js";import"./OptimizedGeometry-1qDYm3YK-DNcX879h.js";import"./colorUtils-DxUhbS7D-ChH2PoBT.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-CjUMzAyX-DPYbdAom.js";import"./utils-C0LvbFCo-RMQaTNpt.js";import"./layerViewUtils-Bk5QNiAa-DQZ_DGTV.js";let bt=class{constructor(i,e){this.sourceTile=e,this.xTile=0,this.yTile=0,this.hash=0,this.priority=1,this.featureIndex=0,this.colliders=[],this.textVertexRanges=[],this.iconVertexRanges=[],this.tile=i}},wt=class{constructor(){this.tileSymbols=[],this.parts=[{startTime:0,startOpacity:0,targetOpacity:0,show:!1},{startTime:0,startOpacity:0,targetOpacity:0,show:!1}],this.show=!1}};function ge(i,e,s,t,r,o){const n=s-r;if(n>=0)return(e>>n)+(t-(o<<n))*(i>>n);const a=-n;return e-(o-(t<<a))*(i>>a)<<a}let ke=class{constructor(i,e,s){this._rows=Math.ceil(e/s),this._columns=Math.ceil(i/s),this._cellSize=s,this.cells=new Array(this._rows);for(let t=0;t<this._rows;t++){this.cells[t]=new Array(this._columns);for(let r=0;r<this._columns;r++)this.cells[t][r]=[]}}getCell(i,e){const s=Math.min(Math.max(Math.floor(e/this._cellSize),0),this._rows-1),t=Math.min(Math.max(Math.floor(i/this._cellSize),0),this._columns-1);return this.cells[s]&&this.cells[s][t]||null}getCellSpan(i,e,s,t){return[Math.min(Math.max(Math.floor(i/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(e/this._cellSize),0),this.rows-1),Math.min(Math.max(Math.floor(s/this._cellSize),0),this.columns-1),Math.min(Math.max(Math.floor(t/this._cellSize),0),this.rows-1)]}get cellSize(){return this._cellSize}get columns(){return this._columns}get rows(){return this._rows}};function St(i,e,s,t,r,o,n){const a=e[t++];for(let h=0;h<a;h++){const l=new bt(o,n);l.xTile=e[t++],l.yTile=e[t++],l.hash=e[t++],l.priority=e[t++],l.featureIndex=e[t++];const c=e[t++];for(let y=0;y<c;y++){const p=e[t++],f=e[t++],_=e[t++],m=e[t++],g=!!e[t++],b=e[t++],T=s[t++],S=s[t++],w=e[t++],M=e[t++];l.colliders.push({xTile:p,yTile:f,dxPixels:_,dyPixels:m,hard:g,partIndex:b,width:w,height:M,minLod:T,maxLod:S})}const u=i[t++];for(let y=0;y<u;y++)l.textVertexRanges.push([i[t++],i[t++]]);const d=i[t++];for(let y=0;y<d;y++)l.iconVertexRanges.push([i[t++],i[t++]]);r.push(l)}return t}function xt(i,e,s){for(const[t,r]of i.symbols)Tt(i,e,s,r,t)}function Tt(i,e,s,t,r){const o=i.layerData.get(r);if(o.type===R.SYMBOL){for(const n of t){const a=n.unique;let h;if(n.selectedForRendering){const l=a.parts[0],c=l.startOpacity,u=l.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*c)|u<<7;h=d<<24|d<<16|d<<8|d}else h=0;for(const[l,c]of n.iconVertexRanges)for(let u=l;u<l+c;u+=4)o.iconOpacity[u/4]=h;if(n.selectedForRendering){const l=a.parts[1],c=l.startOpacity,u=l.targetOpacity;i.allSymbolsFadingOut=i.allSymbolsFadingOut&&u===0;const d=Math.floor(127*c)|u<<7;h=d<<24|d<<16|d<<8|d}else h=0;for(const[l,c]of n.textVertexRanges)for(let u=l;u<l+c;u+=4)o.textOpacity[u/4]=h}o.lastOpacityUpdate=e,o.opacityChanged=!0}}function It(i,e,s,t){const r=i.colliders;let o,n,a,h;for(const l of r)if(i.unique.show&&i.unique.parts[l.partIndex].show&&(o=l.xScreen-t[0]+l.dxScreen,n=l.yScreen-t[1]+l.dyScreen,a=o+l.width,h=n+l.height,Xe(s,e.x,e.y,o,n,a,h)))return!0;return!1}function vt(i,e,s,t,r,o){const{iconRotationAlignment:n,textRotationAlignment:a,iconTranslate:h,iconTranslateAnchor:l,textTranslate:c,textTranslateAnchor:u}=t;let d=0;for(const y of i.colliders){const[p,f]=y.partIndex===0?h:c,_=y.partIndex===0?l:u,m=y.minLod<=o&&o<=y.maxLod;d+=m?0:1,y.enabled=m,y.xScreen=y.xTile*r[0]+y.yTile*r[3]+r[6],y.yScreen=y.xTile*r[1]+y.yTile*r[4]+r[7],_===ut.MAP?(y.xScreen+=s*p-e*f,y.yScreen+=e*p+s*f):(y.xScreen+=p,y.yScreen+=f),L.VIEWPORT===(y.partIndex===0?n:a)?(y.dxScreen=y.dxPixels,y.dyScreen=y.dyPixels):(y.dxScreen=s*(y.dxPixels+y.width/2)-e*(y.dyPixels+y.height/2)-y.width/2,y.dyScreen=e*(y.dxPixels+y.width/2)+s*(y.dyPixels+y.height/2)-y.height/2)}i.colliders.length>0&&d===i.colliders.length&&(i.unique.show=!1)}let Ct=class{constructor(i,e,s,t,r,o){this._symbols=i,this._styleRepository=t,this._zoom=r,this._currentLayerCursor=0,this._currentSymbolCursor=0,this._styleProps=new Map,this._allNeededMatrices=new Map,this._gridIndex=new ke(e,s,ht),this._si=Math.sin(Math.PI*o/180),this._co=Math.cos(Math.PI*o/180);for(const n of i)for(const a of n.symbols)this._allNeededMatrices.has(a.tile)||this._allNeededMatrices.set(a.tile,at(a.tile.transforms.tileUnitsToPixels))}work(i){const e=this._gridIndex;function s(r){const o=r.xScreen+r.dxScreen,n=r.yScreen+r.dyScreen,a=o+r.width,h=n+r.height,[l,c,u,d]=e.getCellSpan(o,n,a,h);for(let y=c;y<=d;y++)for(let p=l;p<=u;p++){const f=e.cells[y][p];for(const _ of f){const m=_.xScreen+_.dxScreen,g=_.yScreen+_.dyScreen,b=m+_.width,T=g+_.height;if(!(a<m||o>b||h<g||n>T))return!0}}return!1}const t=performance.now();for(;this._currentLayerCursor<this._symbols.length;this._currentLayerCursor++,this._currentSymbolCursor=0){const r=this._symbols[this._currentLayerCursor],o=this._getProperties(r.styleLayerUID);for(;this._currentSymbolCursor<r.symbols.length;this._currentSymbolCursor++){if(this._currentSymbolCursor%100==99&&performance.now()-t>i)return!1;const n=r.symbols[this._currentSymbolCursor];if(!n.unique.show)continue;vt(n,this._si,this._co,o,this._allNeededMatrices.get(n.tile),this._zoom);const a=n.unique;if(!a.show)continue;const{iconAllowOverlap:h,iconIgnorePlacement:l,textAllowOverlap:c,textIgnorePlacement:u}=o;for(const d of n.colliders){if(!d.enabled)continue;const y=a.parts[d.partIndex];y.show&&!(d.partIndex?c:h)&&s(d)&&(d.hard?a.show=!1:y.show=!1)}if(a.show)for(const d of n.colliders){if(!d.enabled||(d.partIndex?u:l)||!a.parts[d.partIndex].show)continue;const y=d.xScreen+d.dxScreen,p=d.yScreen+d.dyScreen,f=y+d.width,_=p+d.height,[m,g,b,T]=this._gridIndex.getCellSpan(y,p,f,_);for(let S=g;S<=T;S++)for(let w=m;w<=b;w++)this._gridIndex.cells[S][w].push(d)}}}return!0}_getProperties(i){const e=this._styleProps.get(i);if(e)return e;const s=this._zoom,t=this._styleRepository.getStyleLayerByUID(i),r=t.getLayoutValue("symbol-placement",s)!==ct.POINT;let o=t.getLayoutValue("icon-rotation-alignment",s);o===L.AUTO&&(o=r?L.MAP:L.VIEWPORT);let n=t.getLayoutValue("text-rotation-alignment",s);n===L.AUTO&&(n=r?L.MAP:L.VIEWPORT);const a=t.getPaintValue("icon-translate",s),h=t.getPaintValue("icon-translate-anchor",s),l=t.getPaintValue("text-translate",s),c=t.getPaintValue("text-translate-anchor",s),u={iconAllowOverlap:t.getLayoutValue("icon-allow-overlap",s),iconIgnorePlacement:t.getLayoutValue("icon-ignore-placement",s),textAllowOverlap:t.getLayoutValue("text-allow-overlap",s),textIgnorePlacement:t.getLayoutValue("text-ignore-placement",s),iconRotationAlignment:o,textRotationAlignment:n,iconTranslateAnchor:h,iconTranslate:a,textTranslateAnchor:c,textTranslate:l};return this._styleProps.set(i,u),u}};function Dt(i,e){if(i.priority-e.priority)return i.priority-e.priority;const s=i.tile.key,t=e.tile.key;return s.world-t.world?s.world-t.world:s.level-t.level?s.level-t.level:s.row-t.row?s.row-t.row:s.col-t.col?s.col-t.col:i.xTile-e.xTile?i.xTile-e.xTile:i.yTile-e.yTile}let Rt=class{get running(){return this._running}constructor(i,e,s,t,r,o){this._visibleTiles=i,this._symbolRepository=e,this._createCollisionJob=s,this._assignTileSymbolsOpacity=t,this._symbolLayerSorter=r,this._isLayerVisible=o,this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}setScreenSize(i,e){this._screenWidth===i&&this._screenHeight===e||this.restart(),this._screenWidth=i,this._screenHeight=e}restart(){this._selectionJob=null,this._selectionJobCompleted=!1,this._collisionJob=null,this._collisionJobCompleted=!1,this._opacityJob=null,this._opacityJobCompleted=!1,this._running=!0}continue(i){if(this._selectionJob||(this._selectionJob=this._createSelectionJob()),!this._selectionJobCompleted){const e=performance.now();if(!this._selectionJob.work(i)||(this._selectionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._collisionJob||(this._collisionJob=this._createCollisionJob(this._selectionJob.sortedSymbols,this._screenWidth,this._screenHeight)),!this._collisionJobCompleted){const e=performance.now();if(!this._collisionJob.work(i)||(this._collisionJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}if(this._opacityJob||(this._opacityJob=this._createOpacityJob()),!this._opacityJobCompleted){const e=performance.now();if(!this._opacityJob.work(i)||(this._opacityJobCompleted=!0,(i=Math.max(0,i-(performance.now()-e)))===0))return!1}return this._running=!1,!0}_createSelectionJob(){const i=this._symbolRepository.uniqueSymbols;for(let a=0;a<i.length;a++){const h=i[a];for(let l=0;l<h.uniqueSymbols.length;l++){const c=h.uniqueSymbols[l];for(const u of c.tileSymbols)u.selectedForRendering=!1}}const e=[];let s=0,t=0;const r=this._isLayerVisible;function o(a){let h;const l=performance.now();for(;t<i.length;t++,s=0){const c=i[t],u=c.styleLayerUID;if(!r(u)){e[t]||(e[t]={styleLayerUID:u,symbols:[]});continue}e[t]=e[t]||{styleLayerUID:u,symbols:[]};const d=e[t];for(;s<c.uniqueSymbols.length;s++){if(h=c.uniqueSymbols[s],s%100==99&&performance.now()-l>a)return!1;let y=null,p=!1,f=!1;for(const _ of h.tileSymbols)if(!f||!p){const m=_.tile;(!y||m.isCoverage||m.neededForCoverage&&!p)&&(y=_,(m.neededForCoverage||m.isCoverage)&&(f=!0),m.isCoverage&&(p=!0))}if(y.selectedForRendering=!0,f){d.symbols.push(y),h.show=!0;for(const _ of h.parts)_.show=!0}else h.show=!1}}for(const c of e)c.symbols.sort(Dt);return!0}const n=this._symbolLayerSorter;return{work:o,get sortedSymbols(){return e.sort(n)}}}_createOpacityJob(){const i=this._assignTileSymbolsOpacity,e=this._visibleTiles;let s=0;function t(r,o){for(const n of r.symbols.values())Mt(n,o);i(r,o);for(const n of r.childrenTiles)t(n,o)}return{work(r){const o=performance.now();for(;s<e.length;s++){if(performance.now()-o>r)return!1;const n=e[s];n.parentTile==null&&t(n,performance.now())}return!0}}}};function Mt(i,e){for(const s of i){const t=s.unique;for(const r of t.parts){const o=r.targetOpacity>.5?1:-1;r.startOpacity+=o*((e-r.startTime)/W),r.startOpacity=Math.min(Math.max(r.startOpacity,0),1),r.startTime=e,r.targetOpacity=t.show&&r.show?1:0}}}const Pt=32,At=8,Lt=64,Ot=20;let kt=class{constructor(i,e,s){this.tileCoordRange=i,this._visibleTiles=e,this._createUnique=s,this._tiles=new Map,this._uniqueSymbolsReferences=new Map}get uniqueSymbols(){return this._uniqueSymbolLayerArray==null&&(this._uniqueSymbolLayerArray=this._createUniqueSymbolLayerArray()),this._uniqueSymbolLayerArray}get uniqueSymbolsReferences(){return this._uniqueSymbolsReferences}add(i,e){this._uniqueSymbolLayerArray=null;let s=this._tiles.get(i.id);s||(s={symbols:new Map},this._tiles.set(i.id,s));const t=new Map;if(e)for(const n of e)s.symbols.has(n)&&(t.set(n,s.symbols.get(n)),s.symbols.delete(n));else for(const[n,a]of i.layerData)s.symbols.has(n)&&(t.set(n,s.symbols.get(n)),s.symbols.delete(n));this._removeSymbols(t);const r=i.symbols,o=new Map;for(const[n,a]of r){let h=a.length;if(h>=Pt){let l=this.tileCoordRange;do l/=2,h/=4;while(h>At&&l>Lt);const c=new ke(this.tileCoordRange,this.tileCoordRange,l);o.set(n,{flat:a,index:c}),s.symbols.set(n,{flat:a,index:c});for(const u of a)c.getCell(u.xTile,u.yTile).push(u)}else o.set(n,{flat:a}),s.symbols.set(n,{flat:a})}this._addSymbols(i.key,r)}deleteStyleLayers(i){this._uniqueSymbolLayerArray=null;for(const[e,s]of this._tiles){const t=new Map;for(const r of i)s.symbols.has(r)&&(t.set(r,s.symbols.get(r)),s.symbols.delete(r));this._removeSymbols(t),s.symbols.size===0&&this._tiles.delete(e)}}removeTile(i){this._uniqueSymbolLayerArray=null;const e=this._tiles.get(i.id);if(!e)return;const s=new Map;for(const[t,r]of i.symbols)e.symbols.has(t)&&(s.set(t,e.symbols.get(t)),e.symbols.delete(t));this._removeSymbols(s),e.symbols.size===0&&this._tiles.delete(i.id)}querySymbols(i,e,s,t){const r=[],o=this.uniqueSymbols;for(const n of o){const a=n.styleLayerUID,h=n.uniqueSymbols;for(const l of h){const c=l.tileSymbols.find(u=>u.selectedForRendering);c&&It(c,i,e*(window.devicePixelRatio||1),s)&&r.push({vtlSymbol:c,styleLayerUID:a,tileKey:c.tile.key})}}return r}_removeSymbols(i){for(const[e,{flat:s}]of i)for(const t of s){const r=t.unique,o=r.tileSymbols,n=o.length-1;for(let a=0;a<n;a++)if(o[a]===t){o[a]=o[n];break}if(o.length=n,n===0){const a=this._uniqueSymbolsReferences.get(e);a.delete(r),a.size===0&&this._uniqueSymbolsReferences.delete(e)}t.unique=null}}_addSymbols(i,e){if(e.size===0)return;const s=this._visibleTiles;for(const t of s)t.parentTile||t.key.world!==i.world||t.key.level===i.level&&!t.key.equals(i)||this._matchSymbols(t,i,e);for(const[t,r]of e)for(const o of r)if(o.unique==null){const n=this._createUnique();o.unique=n,n.tileSymbols.push(o);let a=this._uniqueSymbolsReferences.get(t);a||(a=new Set,this._uniqueSymbolsReferences.set(t,a)),a.add(n)}}_matchSymbols(i,e,s){if(i.key.level>e.level){const r=i.key.level-e.level;if(i.key.row>>r!==e.row||i.key.col>>r!==e.col)return}if(e.level>i.key.level){const r=e.level-i.key.level;if(e.row>>r!==i.key.row||e.col>>r!==i.key.col)return}if(e.equals(i.key)){for(const r of i.childrenTiles)this._matchSymbols(r,e,s);return}const t=new Map;for(const[r,o]of s){const n=[];for(const c of o){const u=ge(this.tileCoordRange,c.xTile,e.level,e.col,i.key.level,i.key.col),d=ge(this.tileCoordRange,c.yTile,e.level,e.row,i.key.level,i.key.row);u>=0&&u<this.tileCoordRange&&d>=0&&d<this.tileCoordRange&&n.push({symbol:c,xTransformed:u,yTransformed:d})}const a=[],h=(i.key.level<e.level?1:1<<i.key.level-e.level)+Ot,l=this._tiles.get(i.id).symbols.get(r);if(l){const c=l.flat;for(const u of n){let d,y=!1;const p=u.xTransformed,f=u.yTransformed;d=l.index!=null?l.index.getCell(p,f):c;const _=u.symbol,m=_.hash;for(const g of d)if(m===g.hash&&Math.abs(p-g.xTile)<=h&&Math.abs(f-g.yTile)<=h){const b=g.unique;_.unique=b,b.tileSymbols.push(_),y=!0;break}y||a.push(_)}}a.length>0&&t.set(r,a)}for(const r of i.childrenTiles)this._matchSymbols(r,e,t)}_createUniqueSymbolLayerArray(){const i=this._uniqueSymbolsReferences,e=new Array(i.size);let s,t=0;for(const[r,o]of i){const n=new Array(o.size);s=0;for(const a of o)n[s++]=a;e[t]={styleLayerUID:r,uniqueSymbols:n},t++}return e}},Ut=class extends Le{_createTransforms(){return{displayViewScreenMat3:z(),tileMat3:z()}}};class H{constructor(e,s){this._width=0,this._height=0,this._free=[],this._width=e,this._height=s,this._free.push(new P(0,0,e,s))}get width(){return this._width}get height(){return this._height}allocate(e,s){if(e>this._width||s>this._height)return new P;let t=null,r=-1;for(let o=0;o<this._free.length;++o){const n=this._free[o];e<=n.width&&s<=n.height&&(t===null||n.y<=t.y&&n.x<=t.x)&&(t=n,r=o)}return t===null?new P:(this._free.splice(r,1),t.width<t.height?(t.width>e&&this._free.push(new P(t.x+e,t.y,t.width-e,s)),t.height>s&&this._free.push(new P(t.x,t.y+s,t.width,t.height-s))):(t.width>e&&this._free.push(new P(t.x+e,t.y,t.width-e,t.height)),t.height>s&&this._free.push(new P(t.x,t.y+s,e,t.height-s))),new P(t.x,t.y,e,s))}release(e){for(let s=0;s<this._free.length;++s){const t=this._free[s];if(t.y===e.y&&t.height===e.height&&t.x+t.width===e.x)t.width+=e.width;else if(t.x===e.x&&t.width===e.width&&t.y+t.height===e.y)t.height+=e.height;else if(e.y===t.y&&e.height===t.height&&e.x+e.width===t.x)t.x=e.x,t.width+=e.width;else{if(e.x!==t.x||e.width!==t.width||e.y+e.height!==t.y)continue;t.y=e.y,t.height+=e.height}this._free.splice(s,1),this.release(e)}this._free.push(e)}}let me=class{constructor(i,e,s){this.width=0,this.height=0,this._dirties=[],this._glyphData=[],this._currentPage=0,this._glyphIndex={},this._textures=[],this._rangePromises=new Map,this.width=i,this.height=e,this._glyphSource=s,this._binPack=new H(i-4,e-4),this._glyphData.push(new Uint8Array(i*e)),this._dirties.push(!0),this._textures.push(void 0)}getGlyphItems(i,e){const s=[],t=this._glyphSource,r=new Set,o=1/256;for(const a of e){const h=Math.floor(a*o);r.add(h)}const n=[];return r.forEach(a=>{const h=i+a;if(this._rangePromises.has(h))n.push(this._rangePromises.get(h));else{const l=t.getRange(i,a).then(()=>{this._rangePromises.delete(h)},()=>{this._rangePromises.delete(h)});this._rangePromises.set(h,l),n.push(l)}}),Promise.all(n).then(()=>{let a=this._glyphIndex[i];a||(a={},this._glyphIndex[i]=a);for(const h of e){const l=a[h];if(l){s[h]={sdf:!0,rect:l.rect,metrics:l.metrics,page:l.page,code:h};continue}const c=t.getGlyph(i,h);if(!(c!=null&&c.metrics))continue;const u=c.metrics;let d;if(u.width===0)d=new P(0,0,0,0);else{const y=u.width+6,p=u.height+2*3;let f=y%4?4-y%4:4,_=p%4?4-p%4:4;f===1&&(f=5),_===1&&(_=5),d=this._binPack.allocate(y+f,p+_),d.isEmpty&&(this._dirties[this._currentPage]||(this._glyphData[this._currentPage]=null),this._currentPage=this._glyphData.length,this._glyphData.push(new Uint8Array(this.width*this.height)),this._dirties.push(!0),this._textures.push(void 0),this._binPack=new H(this.width-4,this.height-4),d=this._binPack.allocate(y+f,p+_));const m=this._glyphData[this._currentPage],g=c.bitmap;let b,T;if(g)for(let S=0;S<p;S++){b=y*S,T=this.width*(d.y+S+1)+d.x;for(let w=0;w<y;w++)m[T+w+1]=g.at(b+w)}}a[h]={rect:d,metrics:u,tileIDs:null,page:this._currentPage},s[h]={sdf:!0,rect:d,metrics:u,page:this._currentPage,code:h},this._dirties[this._currentPage]=!0}return s})}removeGlyphs(i){for(const e in this._glyphIndex){const s=this._glyphIndex[e];if(!s)continue;let t;for(const r in s)if(t=s[r],t.tileIDs.delete(i),t.tileIDs.size===0){const o=this._glyphData[t.page],n=t.rect;let a,h;for(let l=0;l<n.height;l++)for(a=this.width*(n.y+l)+n.x,h=0;h<n.width;h++)o[a+h]=0;delete s[r],this._dirties[t.page]=!0}}}bind(i,e,s,t=0){if(!this._textures[s]){const o=new Me;o.pixelFormat=Ze.ALPHA,o.wrapMode=Re.CLAMP_TO_EDGE,o.width=this.width,o.height=this.height,this._textures[s]=new Pe(i,o,new Uint8Array(this.width*this.height))}const r=this._textures[s];r.setSamplingMode(e),this._dirties[s]&&r.setData(this._glyphData[s]),i.bindTexture(r,t),this._dirties[s]=!1}destroy(){this.dispose()}dispose(){this._glyphData.length=0,this._binPack=null;for(const i of this._textures)i&&i.dispose();this._textures.length=0}};class Y{constructor(e){if(this._metrics=[],!e)return void(this._allBitmaps=null);const s=new Map;let t=0;for(;e.next();)switch(e.tag()){case 1:{const n=e.getMessage();for(;n.next();)switch(n.tag()){case 3:{const a=n.getMessage();let h,l,c,u,d,y,p;for(;a.next();)switch(a.tag()){case 1:h=a.getUInt32();break;case 2:l=a.getBytes();break;case 3:c=a.getUInt32();break;case 4:u=a.getUInt32();break;case 5:d=a.getSInt32();break;case 6:y=a.getSInt32();break;case 7:p=a.getUInt32();break;default:a.skip()}if(a.release(),h){const f=(l==null?void 0:l.length)??0;this._metrics[h]={width:c,height:u,left:d,top:y,advance:p,startOffset:t,length:f},s.set(h,l),t+=f}break}default:n.skip()}n.release();break}default:e.skip()}const r=new Uint8Array(t),o=this._metrics;for(const[n,a]of s){const{startOffset:h,length:l}=o[n];if(a)for(let c=0;c<l;++c)r[h+c]=a[c]}this._allBitmaps=r}getMetrics(e){return this._metrics[e]}getBitmap(e){if(!this._allBitmaps)return;const s=this._metrics[e];if(s===void 0)return;const{startOffset:t,length:r}=s;return r!==0?new Vt(this._allBitmaps,t,r):void 0}}let Et=class{constructor(){this._ranges=[]}get ranges(){return this._ranges}getRange(i){return this._ranges[i]}addRange(i,e){this._ranges[i]=e}},be=class{constructor(i){this._glyphInfo={},this._baseURL=i}getRange(i,e){const s=this._getFontStack(i);if(s.getRange(e))return Promise.resolve();const t=256*e,r=t+255;if(this._baseURL){const o=this._baseURL.replace("{fontstack}",i).replace("{range}",t+"-"+r);return Je(o,{responseType:"array-buffer"}).then(n=>{s.addRange(e,new Y(new Z(new Uint8Array(n.data),new DataView(n.data))))}).catch(()=>{s.addRange(e,new Y)})}return s.addRange(e,new Y),Promise.resolve()}getGlyph(i,e){const s=this._getFontStack(i);if(!s)return;const t=Math.floor(e/256),r=s.getRange(t);return r?{metrics:r.getMetrics(e),bitmap:r.getBitmap(e)}:void 0}_getFontStack(i){let e=this._glyphInfo[i];return e||(e=this._glyphInfo[i]=new Et),e}},Vt=class{constructor(i,e,s){this._array=i,this._start=e,this.length=s}at(i){return 0<=i&&i<this.length?this._array[this._start+i]:void 0}};const zt="dasharray-";class ${constructor(e,s,t=0){this._size=[],this._mosaicsData=[],this._textures=[],this._dirties=[],this._maxItemSize=0,this._currentPage=0,this._pageWidth=0,this._pageHeight=0,this._mosaicRects={},this.pixelRatio=1,s<=0&&console.error("Sprites mosaic defaultWidth and defaultHeight must be greater than zero!"),this._pageWidth=e,this._pageHeight=s,t>0&&(this._maxItemSize=t),this._binPack=new H(e-4,s-4)}destroy(){this.dispose()}dispose(){this._binPack=null,this._mosaicsData.length=0,this._mosaicRects={};for(const e of this._textures)e&&e.dispose();this._textures.length=0}getWidth(e){return e>=this._size.length?-1:this._size[e][0]}getHeight(e){return e>=this._size.length?-1:this._size[e][1]}getPageSize(e){return e>=this._size.length?null:this._size[e]}setSpriteSource(e){if(this.dispose(),this.pixelRatio=e.devicePixelRatio,this._mosaicsData.length===0){this._binPack=new H(this._pageWidth-4,this._pageHeight-4);const s=Math.floor(this._pageWidth),t=Math.floor(this._pageHeight),r=new Uint32Array(s*t);this._mosaicsData[0]=r,this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0)}this._sprites=e}getSpriteItem(e,s=!1){let t,r,o=this._mosaicRects[e];if(o)return o;if(!this._sprites||this._sprites.loadStatus!=="loaded"||(e&&e.startsWith(zt)?([t,r]=this._rasterizeDash(e),s=!0):t=this._sprites.getSpriteInfo(e),!(t!=null&&t.width)||!t.height||t.width<0||t.height<0))return null;const n=t.width,a=t.height,[h,l,c]=this._allocateImage(n,a);return h.width<=0?null:(this._copy(h,t,l,c,s,r),o={type:"sprite",rect:h,width:n,height:a,sdf:t.sdf,simplePattern:!1,rasterizationScale:t.pixelRatio??1,samplingMode:"Linear",page:l},this._mosaicRects[e]=o,o)}getSpriteItems(e){const s={};for(const t of e)s[t.name]=this.getSpriteItem(t.name,t.repeat);return s}getMosaicItemPosition(e,s){const t=this.getSpriteItem(e,s),r=t==null?void 0:t.rect;if(!r)return null;r.width=t.width,r.height=t.height;const o=t.width,n=t.height,a=2;return{tl:[r.x+a,r.y+a],br:[r.x+a+o,r.y+a+n],page:t.page}}bind(e,s,t=0,r=0){if(t>=this._size.length||t>=this._mosaicsData.length)return;if(!this._textures[t]){const n=new Me;n.wrapMode=Re.CLAMP_TO_EDGE,n.width=this._size[t][0],n.height=this._size[t][1],this._textures[t]=new Pe(e,n,new Uint8Array(this._mosaicsData[t].buffer))}const o=this._textures[t];o.setSamplingMode(s),this._dirties[t]&&o.setData(new Uint8Array(this._mosaicsData[t].buffer)),e.bindTexture(o,r),this._dirties[t]=!1}static _copyBits(e,s,t,r,o,n,a,h,l,c,u){let d=r*s+t,y=h*n+a;if(u){y-=n;for(let p=-1;p<=c;p++,d=((p+c)%c+r)*s+t,y+=n)for(let f=-1;f<=l;f++)o[y+f]=e[d+(f+l)%l]}else for(let p=0;p<c;p++){for(let f=0;f<l;f++)o[y+f]=e[d+f];d+=s,y+=n}}_copy(e,s,t,r,o,n){if(!this._sprites||this._sprites.loadStatus!=="loaded"||t>=this._mosaicsData.length)return;const a=new Uint32Array(n?n.buffer:this._sprites.image.buffer),h=this._mosaicsData[t],l=2,c=n?s.width:this._sprites.width;$._copyBits(a,c,s.x,s.y,h,r[0],e.x+l,e.y+l,s.width,s.height,o),this._dirties[t]=!0}_allocateImage(e,s){e+=2,s+=2;const t=Math.max(e,s);if(this._maxItemSize&&this._maxItemSize<t){const a=new P(0,0,e,s);return this._mosaicsData.push(new Uint32Array(e*s)),this._dirties.push(!0),this._size.push([e,s]),this._textures.push(void 0),[a,this._mosaicsData.length-1,[e,s]]}let r=e%4?4-e%4:4,o=s%4?4-s%4:4;r===1&&(r=5),o===1&&(o=5);const n=this._binPack.allocate(e+r,s+o);return n.width<=0?(this._dirties[this._currentPage]||(this._mosaicsData[this._currentPage]=null),this._currentPage=this._mosaicsData.length,this._mosaicsData.push(new Uint32Array(this._pageWidth*this._pageHeight)),this._dirties.push(!0),this._size.push([this._pageWidth,this._pageHeight]),this._textures.push(void 0),this._binPack=new H(this._pageWidth-4,this._pageHeight-4),this._allocateImage(e,s)):[n,this._currentPage,[this._pageWidth,this._pageHeight]]}_rasterizeDash(e){const s=/\[(.*?)\]/,t=e.match(s);if(!t)return null;const r=t[1].split(",").map(Number),o=e.slice(e.lastIndexOf("-")+1),[n,a,h]=et(r,o);return[{x:0,y:0,width:a,height:h,sdf:!0,pixelRatio:1},new Uint8Array(n.buffer)]}}let Ht=class{constructor(i,e,s,t){this._layer=i,this._styleRepository=e,this.devicePixelRatio=s,this._sourceDataMaxLOD=t,this._spriteMosaic=null,this._glyphMosaic=null,this._connection=null,this._spriteSourceAbortController=null,this._startOptionsInputSignal=null,this._inputSignalEventListener=null}destroy(){var i,e,s;(i=this._connection)==null||i.close(),this._connection=null,this._styleRepository=null,this._layer=null,(e=this._spriteMosaic)==null||e.destroy(),this._spriteMosaic=null,this._glyphMosaic=null,this._spriteSourceAbortController=qe(this._spriteSourceAbortController),this._spriteSourcePromise=null,this._inputSignalEventListener&&((s=this._startOptionsInputSignal)==null||s.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,this._inputSignalEventListener=null}get spriteMosaic(){return this._spriteSourcePromise.then(()=>this._spriteMosaic)}get glyphMosaic(){return this._glyphMosaic}async start(i){this._requestSprite(i);const e=this._layer.currentStyleInfo.glyphsUrl,s=new be(e?ae(e,{...this._layer.customParameters,token:this._layer.apiKey}):null);this._glyphMosaic=new me(1024,1024,s),this._broadcastPromise=Ye("WorkerTileHandler",{client:this,schedule:i.schedule,signal:i.signal}).then(t=>{var r;if(this._layer&&((r=this._connection)==null||r.close(),this._connection=t,this._layer&&!this._connection.closed)){const o=t.broadcast("setStyle",{style:this._layer.currentStyleInfo.style,sourceDataMaxLOD:this._sourceDataMaxLOD},i);Promise.all(o).catch(n=>Be(n))}})}_requestSprite(i){var o,n;(o=this._spriteSourceAbortController)==null||o.abort();const e=new AbortController;this._spriteSourceAbortController=e;const s=i==null?void 0:i.signal;this._inputSignalEventListener&&((n=this._startOptionsInputSignal)==null||n.removeEventListener("abort",this._inputSignalEventListener)),this._startOptionsInputSignal=null,s&&(this._inputSignalEventListener=Ft(e),s.addEventListener("abort",this._inputSignalEventListener,{once:!0}));const{signal:t}=e,r={...i,signal:t};this._spriteSourcePromise=this._layer.loadSpriteSource(this.devicePixelRatio,r),this._spriteSourcePromise.then(a=>{Ne(t),this._spriteMosaic=new $(1024,1024,250),this._spriteMosaic.setSpriteSource(a)})}async updateStyle(i){const e=[];for(const s of i)s.type===x.SPRITES_CHANGED?e.push({type:x.SPRITES_CHANGED,data:{spriteSource:null}}):e.push(s);return await this._broadcastPromise,this._broadcastPromise=Promise.all(this._connection.broadcast("updateStyle",e)),this._broadcastPromise}setSpriteSource(i){const e=new $(1024,1024,250);return e.setSpriteSource(i),this._spriteMosaic=e,this._spriteSourcePromise=Promise.resolve(i),this._spriteSourceAbortController=null,e}async setStyle(i,e,s){await this._broadcastPromise,this._styleRepository=i,this._sourceDataMaxLOD=s,this._requestSprite();const t=new be(this._layer.currentStyleInfo.glyphsUrl?ae(this._layer.currentStyleInfo.glyphsUrl,{...this._layer.customParameters,token:this._layer.apiKey}):null);return this._glyphMosaic=new me(1024,1024,t),this._broadcastPromise=Promise.all(this._connection.broadcast("setStyle",{style:e,sourceDataMaxLOD:this._sourceDataMaxLOD})),this._broadcastPromise}async fetchTileData(i,e){const s=await this._getRefKeys(i,e);return this._getSourcesData(Object.keys(this._layer.sourceNameToSource),s,e)}async fetchTilePBFs(i){const e=Object.keys(this._layer.sourceNameToSource),s={},t=await this._getRefKeys(i,s),r=[],o=[];for(let n=0;n<t.length;n++)if(t[n].value==null||e[n]==null)o.push(null);else{const a=t[n].value,h=this._getTilePayload(a,e[n],s);h.then(l=>{r.push({...l,key:a})}),o.push(h)}return Promise.all(o).then(()=>r)}async parseTileData(i,e){const s=i&&i.data;if(!s)return null;const{sourceName2DataAndRefKey:t,transferList:r}=s;return Object.keys(t).length===0?null:this._broadcastPromise.then(()=>this._connection.invoke("createTileAndParse",{key:i.key.id,sourceName2DataAndRefKey:t,styleLayerUIDs:i.styleLayerUIDs},{...e,transferList:r}))}async getSprites(i){return await this._spriteSourcePromise,this._spriteMosaic.getSpriteItems(i)}getGlyphs(i){return this._glyphMosaic.getGlyphItems(i.font,i.codePoints)}async _getTilePayload(i,e,s){const t=A.pool.acquire(i.id),r=this._layer.sourceNameToSource[e],{level:o,row:n,col:a}=t;A.pool.release(t);try{return{protobuff:await r.requestTile(o,n,a,s),sourceName:e}}catch(h){if(X(h))throw h;return{protobuff:null,sourceName:e}}}async _getRefKeys(i,e){const s=this._layer.sourceNameToSource,t=new Array;for(const r in s){const o=s[r].getRefKey(i,e);t.push(o)}return le(t)}_getSourcesData(i,e,s){const t=[];for(let r=0;r<e.length;r++)if(e[r].value==null||i[r]==null)t.push(null);else{const o=e[r].value,n=this._getTilePayload(o,i[r],s);t.push(n)}return le(t).then(r=>{const o={},n=[];for(let a=0;a<r.length;a++){const h=r[a].value;if(h&&h.protobuff&&h.protobuff.byteLength>0){const l=e[a].value.id;o[h.sourceName]={refKey:l,protobuff:h.protobuff},n.push(h.protobuff)}}return{sourceName2DataAndRefKey:o,transferList:n}})}};function Ft(i){return()=>i.abort()}const we=512,qt=1e-6,Bt=(i,e)=>i+1/(1<<2*e);let Se=class{constructor(i,e){this._tiles=new Map,this._tileCache=new st(40,s=>s.dispose()),this._viewSize=[0,0],this._visibleTiles=new Map,this.acquireTile=i.acquireTile,this.releaseTile=i.releaseTile,this.tileInfoView=i.tileInfoView,this._container=e}destroy(){for(const i of this._tiles.values())i.dispose();this._tiles=null,this._tileCache.clear(),this._tileCache=null}update(i){this._updateCacheSize(i);const e=this.tileInfoView,s=e.getTileCoverage(i.state,0,!0,"smallest");if(!s)return!0;const{spans:t,lodInfo:r}=s,{level:o}=r,n=this._tiles,a=new Set,h=new Set;for(const{row:c,colFrom:u,colTo:d}of t)for(let y=u;y<=d;y++){const p=A.getId(o,c,r.normalizeCol(y),r.getWorldForColumn(y)),f=this._getOrAcquireTile(p);a.add(p),f.processed()?this._addToContainer(f):h.add(new A(p))}for(const[c,u]of n)u.isCoverage=a.has(c);for(const c of h)this._findPlaceholdersForMissingTiles(c,a);let l=!1;for(const[c,u]of n)u.neededForCoverage=a.has(c),u.neededForCoverage||u.isHoldingForFade&&e.intersects(s,u.key)&&a.add(c),u.isFading&&(l=!0);for(const c of this._tiles.keys())a.has(c)||this._releaseTile(c);return Ae.pool.release(s),!l}clear(){this._tiles.clear(),this._tileCache.clear(),this._visibleTiles.clear()}clearCache(){this._tileCache.clear()}getIntersectingTiles(i,e,s,t,r){const o=[0,0],n=[0,0];t.toMap(o,i-s,e+s),t.toMap(n,i+s,e-s);const a=Math.min(o[0],n[0]),h=Math.min(o[1],n[1]),l=Math.max(o[0],n[0]),c=Math.max(o[1],n[1]),u=Qe(a,h,l,c),d=F(),y=[];for(const p of this._visibleTiles.values())this.tileInfoView.getTileBounds(d,p.key),We(u,d)&&y.push(p);if(r!=null&&r.length>0){const p=new Set(y.map(_=>_.id)),f=r.filter(_=>!p.has(_.tileKey.id)).map(_=>this._visibleTiles.get(_.tileKey.id)).filter(_=>_!==void 0);y.push(...f)}return y}_findPlaceholdersForMissingTiles(i,e){const s=[];for(const r of this._tiles.values())this._addPlaceholderChild(s,r,i,e);const t=s.reduce(Bt,0);Math.abs(1-t)<qt||this._addPlaceholderParent(i.id,e)}_addPlaceholderChild(i,e,s,t){e.key.level<=s.level||!e.hasData()||Qt(s,e.key)&&(this._addToContainer(e),t.add(e.id),i.push(e.key.level-s.level))}_addPlaceholderParent(i,e){const s=this._tiles;let t=i;for(;;){if(t=Nt(t),!t||e.has(t))return;const r=s.get(t);if(r!=null&&r.hasData())return this._addToContainer(r),void e.add(r.id)}}_getOrAcquireTile(i){let e=this._tiles.get(i);return e||(e=this._tileCache.pop(i),e||(e=this.acquireTile(new A(i))),this._tiles.set(i,e),e)}_releaseTile(i){const e=this._tiles.get(i);this.releaseTile(e),this._removeFromContainer(e),this._tiles.delete(i),e.hasData()?this._tileCache.put(i,e,1):e.dispose()}_addToContainer(i){let e;const s=[],t=this._container;if(t.contains(i))return;const r=this._visibleTiles;for(const o of r.values())this._canConnectDirectly(i,o)&&s.push(o),e==null&&this._canConnectDirectly(o,i)&&(e=o);if(e!=null){for(const o of s)e.childrenTiles.delete(o),i.childrenTiles.add(o),o.parentTile=i;e.childrenTiles.add(i),i.parentTile=e}else for(const o of s)i.childrenTiles.add(o),o.parentTile=i;r.set(i.id,i),t.addChild(i)}_removeFromContainer(i){if(this._visibleTiles.delete(i.id),this._container.removeChild(i),i.parentTile!=null){i.parentTile.childrenTiles.delete(i);for(const e of i.childrenTiles)i.parentTile!=null&&i.parentTile.childrenTiles.add(e)}for(const e of i.childrenTiles)e.parentTile=i.parentTile;i.parentTile=null,i.childrenTiles.clear()}_canConnectDirectly(i,e){const s=i.key;let{level:t,row:r,col:o,world:n}=e.key;const a=this._visibleTiles;for(;t>0;){if(t--,r>>=1,o>>=1,s.level===t&&s.row===r&&s.col===o&&s.world===n)return!0;if(a.has(`${t}/${r}/${o}/${n}`))return!1}return!1}_updateCacheSize(i){const e=i.state.size;if(e[0]===this._viewSize[0]&&e[1]===this._viewSize[1])return;const s=Math.ceil(e[0]/we)+1,t=Math.ceil(e[1]/we)+1;this._viewSize[0]=e[0],this._viewSize[1]=e[1],this._tileCache.maxSize=5*s*t}};function Nt(i){const[e,s,t,r]=i.split("/"),o=parseInt(e,10);return o===0?null:`${o-1}/${parseInt(s,10)>>1}/${parseInt(t,10)>>1}/${parseInt(r,10)}`}function Qt(i,e){const s=e.level-i.level;return i.row===e.row>>s&&i.col===e.col>>s&&i.world===e.world}let G=class{constructor(i,e){this.layerUIDs=[],this.isDestroyed=!1,this._data=i;let s=1;const t=new Uint32Array(i);this.layerUIDs=[];const r=t[s++];for(let o=0;o<r;o++)this.layerUIDs[o]=t[s++];this.bufferDataOffset=s,e&&(this.layer=e.getStyleLayerByUID(this.layerUIDs[0]))}get isPreparedForRendering(){return this._data==null}get offset(){return this.bufferDataOffset}get data(){return this._data}destroy(){this.isDestroyed||(this.doDestroy(),this._data=null,this.isDestroyed=!0)}prepareForRendering(i){this._data!=null&&(this.doPrepareForRendering(i,this._data,this.bufferDataOffset),this._data=null)}},Wt=class extends G{constructor(i,e){super(i,e),this.type=R.LINE,this.lineIndexStart=0,this.lineIndexCount=0;const s=new Uint32Array(i);let t=this.bufferDataOffset;this.lineIndexStart=s[t++],this.lineIndexCount=s[t++];const r=s[t++];if(r>0){this.patternMap=new Map;for(let o=0;o<r;o++){const n=s[t++],a=s[t++],h=s[t++];this.patternMap.set(n,[a,h])}}this.bufferDataOffset=t}get usedMemory(){var i,e;return(((i=this.data)==null?void 0:i.byteLength)??0)+(((e=this.vao)==null?void 0:e.cachedMemory)??0)}hasData(){return this.lineIndexCount>0}triangleCount(){return this.lineIndexCount/3}doDestroy(){this.vao=k(this.vao)}doPrepareForRendering(i,e,s){const t=new Uint32Array(e),r=new Int32Array(t.buffer),o=t[s++],n=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*s,o));s+=o;const a=t[s++],h=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(t.buffer,4*s,a));s+=a;const l=this.layer.lineMaterial;this.vao=new U(i,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}};class $t extends G{constructor(e,s){super(e,s),this.type=R.FILL,this.fillIndexStart=0,this.fillIndexCount=0,this.outlineIndexStart=0,this.outlineIndexCount=0;const t=new Uint32Array(e);let r=this.bufferDataOffset;this.fillIndexStart=t[r++],this.fillIndexCount=t[r++],this.outlineIndexStart=t[r++],this.outlineIndexCount=t[r++];const o=t[r++];if(o>0){this.patternMap=new Map;for(let n=0;n<o;n++){const a=t[r++],h=t[r++],l=t[r++];this.patternMap.set(a,[h,l])}}this.bufferDataOffset=r}get usedMemory(){var e,s,t;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((s=this.fillVAO)==null?void 0:s.cachedMemory)??0)+(((t=this.outlineVAO)==null?void 0:t.cachedMemory)??0)}hasData(){return this.fillIndexCount>0||this.outlineIndexCount>0}triangleCount(){return(this.fillIndexCount+this.outlineIndexCount)/3}doDestroy(){this.fillVAO=k(this.fillVAO),this.outlineVAO=k(this.outlineVAO)}doPrepareForRendering(e,s,t){const r=new Uint32Array(s),o=new Int32Array(r.buffer),n=r[t++],a=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*t,n));t+=n;const h=r[t++],l=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*t,h));t+=h;const c=r[t++],u=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*t,c));t+=c;const d=r[t++],y=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*t,d));t+=d;const p=this.layer,f=p.fillMaterial,_=p.outlineMaterial;this.fillVAO=new U(e,f.getAttributeLocations(),f.getLayoutInfo(),new Map([["geometry",a]]),l),this.outlineVAO=new U(e,_.getAttributeLocations(),_.getLayoutInfo(),new Map([["geometry",u]]),y)}}class Jt extends G{constructor(e,s,t){super(e,s),this.type=R.SYMBOL,this.iconPerPageElementsMap=new Map,this.glyphPerPageElementsMap=new Map,this.symbolInstances=[],this.isIconSDF=!1,this.opacityChanged=!1,this.lastOpacityUpdate=0,this.symbols=[];const r=new Uint32Array(e),o=new Int32Array(e),n=new Float32Array(e);let a=this.bufferDataOffset;this.isIconSDF=!!r[a++];const h=r[a++],l=r[a++],c=r[a++],u=new A(h,l,c,0),d=r[a++];for(let _=0;_<d;_++){const m=r[a++],g=r[a++],b=r[a++];this.iconPerPageElementsMap.set(m,[g,b])}const y=r[a++];for(let _=0;_<y;_++){const m=r[a++],g=r[a++],b=r[a++];this.glyphPerPageElementsMap.set(m,[g,b])}const p=r[a++],f=r[a++];this.iconOpacity=new Int32Array(p),this.textOpacity=new Int32Array(f),a=St(r,o,n,a,this.symbols,t,u),this.bufferDataOffset=a}get usedMemory(){var e,s,t;return(((e=this.data)==null?void 0:e.byteLength)??0)+(((s=this.iconVAO)==null?void 0:s.cachedMemory)??0)+(((t=this.textVAO)==null?void 0:t.cachedMemory)??0)+ye(this.iconOpacity)+ye(this.textOpacity)}hasData(){return this.iconPerPageElementsMap.size>0||this.glyphPerPageElementsMap.size>0}triangleCount(){let e=0;for(const s of this.iconPerPageElementsMap.values())e+=s[1];for(const s of this.glyphPerPageElementsMap.values())e+=s[1];return e/3}doDestroy(){this.iconVAO=k(this.iconVAO),this.textVAO=k(this.textVAO)}updateOpacityInfo(){if(!this.opacityChanged)return;this.opacityChanged=!1;const e=this.iconOpacity,s=this.iconVAO.vertexBuffers.get("opacity");e.length>0&&e.byteLength===s.usedMemory&&s.setSubData(e,0,0,e.length);const t=this.textOpacity,r=this.textVAO.vertexBuffers.get("opacity");t.length>0&&t.byteLength===r.usedMemory&&r.setSubData(t,0,0,t.length)}doPrepareForRendering(e,s,t){const r=new Uint32Array(s),o=new Int32Array(r.buffer),n=r[t++],a=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*t,n));t+=n;const h=r[t++],l=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*t,h));t+=h;const c=r[t++],u=D.createVertex(e,C.STATIC_DRAW,new Int32Array(o.buffer,4*t,c));t+=c;const d=r[t++],y=D.createIndex(e,C.STATIC_DRAW,new Uint32Array(r.buffer,4*t,d));t+=d;const p=D.createVertex(e,C.STATIC_DRAW,this.iconOpacity.buffer),f=D.createVertex(e,C.STATIC_DRAW,this.textOpacity.buffer),_=this.layer,m=_.iconMaterial,g=_.textMaterial;this.iconVAO=new U(e,m.getAttributeLocations(),m.getLayoutInfo(),new Map([["geometry",a],["opacity",p]]),l),this.textVAO=new U(e,g.getAttributeLocations(),g.getLayoutInfo(),new Map([["geometry",u],["opacity",f]]),y)}}let Gt=class extends G{constructor(i,e){super(i,e),this.type=R.CIRCLE,this.circleIndexStart=0,this.circleIndexCount=0;const s=new Uint32Array(i);let t=this.bufferDataOffset;this.circleIndexStart=s[t++],this.circleIndexCount=s[t++],this.bufferDataOffset=t}get usedMemory(){var i,e;return(((i=this.data)==null?void 0:i.byteLength)??0)+(((e=this.vao)==null?void 0:e.cachedMemory)??0)}hasData(){return this.circleIndexCount>0}triangleCount(){return this.circleIndexCount/3}doDestroy(){this.vao=k(this.vao)}doPrepareForRendering(i,e,s){const t=new Uint32Array(e),r=new Int32Array(t.buffer),o=t[s++],n=D.createVertex(i,C.STATIC_DRAW,new Int32Array(r.buffer,4*s,o));s+=o;const a=t[s++],h=D.createIndex(i,C.STATIC_DRAW,new Uint32Array(t.buffer,4*s,a));s+=a;const l=this.layer.circleMaterial;this.vao=new U(i,l.getAttributeLocations(),l.getLayoutInfo(),new Map([["geometry",n]]),h)}},Kt=class Ue extends Le{constructor(e,s,t,r,o,n,a,h=null){super(e,s,t,r,o,n,4096,4096),this.styleRepository=a,this._memCache=h,this.type="vector-tile",this._referenced=1,this._hasSymbolBuckets=!1,this._usedMemory=256,this.layerData=new Map,this.status="loading",this.allSymbolsFadingOut=!1,this.lastOpacityUpdate=0,this.symbols=new Map,this.isCoverage=!1,this.neededForCoverage=!1,this.decluttered=!1,this.parentTile=null,this.childrenTiles=new Set,this.featureIndex=null,this.triangleCount=0,this._processed=!1,this.id=e.id}get hasSymbolBuckets(){return this._hasSymbolBuckets}get isFading(){return this._hasSymbolBuckets&&performance.now()-this.lastOpacityUpdate<W}get isHoldingForFade(){return this._hasSymbolBuckets&&(!this.allSymbolsFadingOut||performance.now()-this.lastOpacityUpdate<W)}get wasRequested(){return this.status==="errored"||this.status==="loaded"||this.status==="reloading"}setData(e){this.changeDataImpl(e),this.requestRender(),this.ready(),this._processed=!0}deleteLayerData(e){var t,r;let s=!1;for(const o of e){const n=this.layerData.get(o);n&&(this._usedMemory-=n.usedMemory,n.type===R.SYMBOL&&this.symbols.delete(o)&&(s=!0),n.destroy(),this.layerData.delete(o))}(t=this._memCache)==null||t.updateSize(this.key.id,this),s&&((r=this.featureIndex)==null||r.clear(),this.emit("symbols-changed")),this.requestRender()}processed(){return this._processed}hasData(){return this.layerData.size>0}hasFeatures(){const e=this.layerData.values();for(const s of e)if(s.hasData())return!0;return!1}dispose(){this.status!=="unloaded"&&(Ue._destroyRenderBuckets(this.layerData),this.layerData.clear(),this.featureIndex=null,this._usedMemory=0,this.destroy(),this.status="unloaded")}release(){--this._referenced==0&&(this.dispose(),this.stage=null)}retain(){++this._referenced}get cachedMemory(){return this._usedMemory}get usedMemory(){return this._usedMemory}get usedMemoryPerReference(){return this._usedMemory/(this._referenced||1)}changeDataImpl(e){var t,r;(t=this.featureIndex)==null||t.clear();let s=!1;if(e){const{bucketsWithData:o,emptyBuckets:n}=e,a=this._createRenderBuckets(o);if(n&&n.byteLength>0){const h=new Uint32Array(n);for(const l of h)this._deleteLayerData(l)}for(const[h,l]of a)this._deleteLayerData(h),l.type===R.SYMBOL&&(this.symbols.set(h,l.symbols),s=!0),this._usedMemory+=l.usedMemory,this.layerData.set(h,l);(r=this._memCache)==null||r.updateSize(this.key.id,this)}this._hasSymbolBuckets=!1;for(const o of this.layerData.values())o.type===R.SYMBOL&&(this._hasSymbolBuckets=!0);s&&this.emit("symbols-changed")}attachWithContext(e){this.stage={context:e,trashDisplayObject(s){s.processDetach()},untrashDisplayObject:()=>!1}}setTransform(e){super.setTransform(e);const s=this.resolution/(e.resolution*e.pixelRatio),t=this.width/this.rangeX*s,r=this.height/this.rangeY*s,o=[0,0];e.toScreen(o,[this.x,this.y]);const n=this.transforms.tileUnitsToPixels;it(n),rt(n,n,o),ot(n,n,Math.PI*e.rotation/180),nt(n,n,[t,r,1])}_createTransforms(){return{displayViewScreenMat3:z(),tileMat3:z(),tileUnitsToPixels:z()}}static _destroyRenderBuckets(e){if(!e)return;const s=new Set;for(const t of e.values())s.has(t)||(t.destroy(),s.add(t));e.clear()}_createRenderBuckets(e){const s=new Map,t=new Map;for(const r of e){const o=this._deserializeBucket(r,t);for(const n of o.layerUIDs)s.set(n,o)}return s}_deserializeBucket(e,s){let t=s.get(e);if(t)return t;switch(new Uint32Array(e)[0]){case R.FILL:t=new $t(e,this.styleRepository);break;case R.LINE:t=new Wt(e,this.styleRepository);break;case R.SYMBOL:t=new Jt(e,this.styleRepository,this);break;case R.CIRCLE:t=new Gt(e,this.styleRepository)}return s.set(e,t),t}_deleteLayerData(e){if(!this.layerData.has(e))return;const s=this.layerData.get(e);this._usedMemory-=s.usedMemory,s.destroy(),this.layerData.delete(e)}};const Yt=.5,xe=1e-6;class jt{constructor(e,s){this.styleRepository=e,this._tileToHandle=new Map,this._viewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._declutterViewState={scale:0,rotation:0,center:[0,0],size:[0,0]},this._offsetFromScreenCenter=[0,0],this._completed=!1,this._fading=yt(!1),this._symbolRepository=new kt(4096,s,()=>new wt),this._symbolDeclutterer=new Rt(s,this._symbolRepository,(t,r,o)=>this._createCollisionJob(t,r,o),(t,r)=>{t.allSymbolsFadingOut=!0,t.lastOpacityUpdate=r,xt(t,r,!0),t.decluttered=!0,t.requestRender()},(t,r)=>this.styleRepository.getStyleLayerByUID(t.styleLayerUID).z-this.styleRepository.getStyleLayerByUID(r.styleLayerUID).z,t=>{const r=this.styleRepository.getStyleLayerByUID(t);if(this._zoom+xe<r.minzoom||this._zoom-xe>=r.maxzoom)return!1;const o=r.getLayoutProperty("visibility");return!o||o.getValue()!==ee.NONE})}get symbolRepository(){return this._symbolRepository}_createCollisionJob(e,s,t){return this.updateDecluttererViewState(),new Ct(e,s,t,this.styleRepository,this._zoom,this._viewState.rotation)}get fading(){return this._fading.value}get decluttererOffset(){return this._offsetFromScreenCenter}addTile(e){e.decluttered=!1,this._tileToHandle.set(e,e.on("symbols-changed",()=>{this._symbolRepository.add(e),this.restartDeclutter()})),this._symbolRepository.add(e),this.restartDeclutter()}removeTile(e){const s=this._tileToHandle.get(e);s&&(this._symbolRepository.removeTile(e),this.restartDeclutter(),s.remove(),this._tileToHandle.delete(e))}update(e,s){this._zoom=e,this._viewState={scale:s.scale,rotation:s.rotation,center:[s.center[0],s.center[1]],size:[s.size[0],s.size[1]]};const t=[0,0];s.toScreen(t,s.center);const r=[0,0];return s.toScreen(r,this._declutterViewState.center),this._offsetFromScreenCenter[0]=t[0]-r[0],this._offsetFromScreenCenter[1]=t[1]-r[1],this._continueDeclutter(),this._completed}restartDeclutter(){this._completed=!1,this._symbolDeclutterer.restart(),this._notifyUnstable()}clear(){this._completed=!1,this._symbolRepository=null,this._symbolDeclutterer.restart(),this._tileToHandle.forEach(e=>e.remove()),this._tileToHandle.clear()}get stale(){return this._zoom!==this._declutterZoom||this._viewState.size[0]!==this._declutterViewState.size[0]||this._viewState.size[1]!==this._declutterViewState.size[1]||this._viewState.scale!==this._declutterViewState.scale||this._viewState.rotation!==this._declutterViewState.rotation}deleteStyleLayers(e){this._symbolRepository.deleteStyleLayers(e)}_continueDeclutter(){this._completed&&!this.stale||(this._symbolDeclutterer.running||(this.updateDecluttererViewState(),this._symbolDeclutterer.restart()),this._symbolDeclutterer.setScreenSize(this._viewState.size[0],this._viewState.size[1]),this._completed=this._symbolDeclutterer.continue(lt),this._completed&&this._scheduleNotifyStable())}_scheduleNotifyStable(){this._stableNotificationHandle!=null&&clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=setTimeout(()=>{this._stableNotificationHandle=null,this._fading.value=!1},(1+Yt)*W)}_notifyUnstable(){this._stableNotificationHandle!=null&&(clearTimeout(this._stableNotificationHandle),this._stableNotificationHandle=null),this._fading.value=!0}updateDecluttererViewState(){this._declutterZoom=this._zoom,this._declutterViewState.center[0]=this._viewState.center[0],this._declutterViewState.center[1]=this._viewState.center[1],this._declutterViewState.rotation=this._viewState.rotation,this._declutterViewState.scale=this._viewState.scale,this._declutterViewState.size[0]=this._viewState.size[0],this._declutterViewState.size[1]=this._viewState.size[1],this._offsetFromScreenCenter[0]=0,this._offsetFromScreenCenter[1]=0}}const J=1e-6;function Te(i,e){if(i){const s=i.getLayoutProperty("visibility");if(!s||s.getValue()!==ee.NONE&&(i.minzoom===void 0||i.minzoom<e+J)&&(i.maxzoom===void 0||i.maxzoom>=e-J))return!0}return!1}let Xt=class extends dt{constructor(i){super(i),this._backgroundTiles=[],this._computeDisplayInfoView(i)}destroy(){var i,e;this.removeAllChildren(),(i=this._spriteMosaic)==null||i.dispose(),this._spriteMosaic=null,(e=this._glyphMosaic)==null||e.dispose(),this._glyphMosaic=null,this._symbolFader!=null&&(this._symbolFader.clear(),this._symbolFader=null),this._styleRepository=null,this._backgroundTiles=[]}get fading(){var i;return((i=this._symbolFader)==null?void 0:i.fading)??!1}get symbolFader(){return this._symbolFader}get symbolRepository(){var i;return(i=this._symbolFader)==null?void 0:i.symbolRepository}setStyleResources(i,e,s,t){this._spriteMosaic=i,this._glyphMosaic=e,this._styleRepository=s,this.tileInfoView=t,this._computeDisplayInfoView(t),this._symbolFader==null&&(this._symbolFader=new jt(this._styleRepository,this.children)),this._symbolFader.styleRepository=s}setSpriteMosaic(i){var e;(e=this._spriteMosaic)==null||e.dispose(),this._spriteMosaic=i}deleteStyleLayers(i){this._symbolFader!=null&&this._symbolFader.deleteStyleLayers(i)}createRenderParams(i){return{...super.createRenderParams(i),renderPass:null,styleLayer:null,styleLayerUID:-1,glyphMosaic:this._glyphMosaic,spriteMosaic:this._spriteMosaic,hasClipping:!!this._clippingInfos}}doRender(i){!this.visible||i.drawPhase!==N.MAP&&i.drawPhase!==N.DEBUG||this._spriteMosaic===void 0||super.doRender(i)}addChild(i){return super.addChild(i),this._symbolFader!=null?this._symbolFader.addTile(i):i.decluttered=!0,this.requestRender(),i}removeChild(i){return this._symbolFader!=null&&this._symbolFader.removeTile(i),this.requestRender(),super.removeChild(i)}renderChildren(i){const{drawPhase:e}=i;e!==N.DEBUG?this._doRender(i):super.renderChildren(i)}removeAllChildren(){for(let i=0;i<this.children.length;i++){const e=this.children[i];this._symbolFader!=null&&this._symbolFader.removeTile(e),e.dispose()}super.removeAllChildren()}getStencilTarget(){return this.children.filter(i=>i.neededForCoverage&&i.hasData())}restartDeclutter(){this._symbolFader!=null&&this._symbolFader.restartDeclutter()}_doRender(i){const{context:e,state:s}=i,t=this._styleRepository;if(!t)return;const r=t.layers,o=this._displayInfo.scaleToZoom(s.scale);t.backgroundBucketIds.length>0&&(i.renderPass="background",this._renderBackgroundLayers(i,t.backgroundBucketIds,o)),super.renderChildren(i),i.drawPhase===N.MAP&&this._fade(o,s);const n=this.children.filter(a=>a.visible&&a.hasData());if(!n||n.length===0)return e.bindVAO(),e.setStencilTestEnabled(!0),void e.setBlendingEnabled(!0);for(const a of n)a.triangleCount=0;e.setStencilWriteMask(0),e.setColorMask(!0,!0,!0,!0),e.setStencilOp(O.KEEP,O.KEEP,O.REPLACE),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!1),e.setDepthTestEnabled(!0),e.setDepthWriteEnabled(!0),e.setDepthFunction(ce.LEQUAL),e.setClearDepth(1),e.clear(e.gl.DEPTH_BUFFER_BIT),i.renderPass="opaque";for(let a=r.length-1;a>=0;a--)this._renderStyleLayer(r[a],i,n);e.setDepthWriteEnabled(!1),e.setBlendingEnabled(!0),e.setBlendFunctionSeparate(B.ONE,B.ONE_MINUS_SRC_ALPHA,B.ONE,B.ONE_MINUS_SRC_ALPHA),i.renderPass="translucent";for(let a=0;a<r.length;a++)this._renderStyleLayer(r[a],i,n);e.bindVAO(),e.setStencilTestEnabled(!0),e.setBlendingEnabled(!0);for(const a of n)a.debugInfo.display.triangleCount=a.triangleCount}_fade(i,e){this._symbolFader!=null&&(this._symbolFader.update(i,e)||this.requestRender())}_renderStyleLayer(i,e,s){const{displayLevel:t,painter:r,renderPass:o}=e;if(i===void 0)return;const n=i.getLayoutProperty("visibility");if(n&&n.getValue()===ee.NONE)return;let a;switch(i.type){case v.BACKGROUND:return;case v.FILL:if(o!=="opaque"&&e.renderPass!=="translucent")return;a="vtlFill";break;case v.LINE:if(o!=="translucent")return;a="vtlLine";break;case v.CIRCLE:if(o!=="translucent")return;a="vtlCircle";break;case v.SYMBOL:if(o!=="translucent")return;a="vtlSymbol"}if(s=i.type===v.SYMBOL?s.filter(l=>l.decluttered):s.filter(l=>l.neededForCoverage),a!=="vtlSymbol"&&(s.length===0||i.minzoom!==void 0&&i.minzoom>=t+J||i.maxzoom!==void 0&&i.maxzoom<t-J))return;const h=i.uid;e.styleLayerUID=h,e.styleLayer=i;for(const l of s)if(l.layerData.has(h)){r.renderObjects(e,s,a);break}}_renderBackgroundLayers(i,e,s){const{context:t,painter:r,state:o}=i,n=this._styleRepository;let a=!1;for(const g of e)if(n.getLayerById(g).type===v.BACKGROUND&&Te(n.getLayerById(g),s)){a=!0;break}if(!a)return;const h=this.tileInfoView,l=h.getTileCoverage(i.state,0,!0,"smallest"),{spans:c,lodInfo:u}=l,{level:d}=u,y=F(),p=[];if(this._renderPasses){const g=this._renderPasses[0];this._clippingInfos!=null&&(g.brushes[0].prepareState(i),g.brushes[0].drawMany(i,this._clippingInfos))}const f=this._backgroundTiles;let _,m=0;for(const{row:g,colFrom:b,colTo:T}of c)for(let S=b;S<=T;S++){if(m<f.length)_=f[m],_.key.set(d,g,u.normalizeCol(S),u.getWorldForColumn(S)),h.getTileBounds(y,_.key,!1),_.x=y[0],_.y=y[3],_.resolution=h.getTileResolution(d);else{const w=new A(d,g,u.normalizeCol(S),u.getWorldForColumn(S)),M=h.getTileBounds(F(),w),E=h.getTileResolution(d);_=new Ut(w,E,M[0],M[3],512,512,4096,4096),f.push(_)}_.setTransform(o),p.push(_),m++}t.setStencilWriteMask(0),t.setColorMask(!0,!0,!0,!0),t.setStencilOp(O.KEEP,O.KEEP,O.REPLACE),t.setStencilFunction(ce.EQUAL,0,255),t.setStencilTestEnabled(!0);for(const g of e){const b=n.getLayerById(g);b.type===v.BACKGROUND&&Te(b,s)&&(i.styleLayerUID=b.uid,i.styleLayer=b,r.renderObjects(i,p,"vtlBackground"))}Ae.pool.release(l)}_computeDisplayInfoView(i){let e=i.tileInfo.lods[0].scale;const s=Math.max(25,i.tileInfo.lods.length),t=[];for(let r=0;r<=s;r++)t.push(e),e/=2;this._displayInfo=Oe.create({scales:t,size:512,spatialReference:i.spatialReference,numLODs:s})}};const Zt=8,es=512,Ie=4096,ts=(i,e)=>{const s=i.vtlSymbol.sourceTile,t=e.vtlSymbol.sourceTile;return s.level!==t.level?s.level-t.level:s.row!==t.row?s.row-t.row:s.col!==t.col?s.col-t.col:i.styleLayerUID-e.styleLayerUID};class te{constructor(e,s,t,r,o){this.tileKey=e,this._tileLayerData=s,this._styleRepository=t,this._tileHandler=r,this._parentLayer=o,this._index=null,this._tileKeyToPBF=new Map}static create(e,s,t,r,o){return new te(e,s,t,r,o)}clear(){var e;(e=this._index)==null||e.clear(),this._tileKeyToPBF.clear()}async queryAttributes(e,s,t,r,o){if(this._tileLayerData.size===0||!this._styleRepository||!this._tileHandler)return[];this._index===null&&(this._index=new _t(100,ss),await this._indexLayers());const n=[];return this._queryIndex(n,e,s,t,this.tileKey.level,r),o&&(o==null?void 0:o.length)>0&&await this._getSymbolsAttributes(n,o),n}async _indexLayers(){const e=this.tileKey,s=this._styleRepository.layers,t=await this._getTilePayload(e);for(const[r,o]of this._tileLayerData){const n=s[r],a=t.find(c=>c.sourceName===n.source);if(!a)continue;const{protobuff:h,key:l}=a;if(o.type!==R.SYMBOL){const c=1<<e.level-l.level,u=e.row-l.row*c,d=e.col-l.col*c;this._indexLayer(n,h,e.level,c,u,d)}}}_indexLayer(e,s,t,r,o,n){const a=e.sourceLayer,h=e.getFeatureFilter(),l=t,c=t+1,u=je(l),d=new Z(new Uint8Array(s),new DataView(s));for(;d.next();)switch(d.tag()){case 3:{const y=d.getMessage(),p=new _e(y);if(y.release(),p.name!==a)continue;const f=p.getData(),_=p.extent/r,m=_*n-u,g=_*o-u,b=m+_+2*u,T=g+_+2*u,S=_/es,w=Ie/_,M=_*n,E=_*o;for(;f.nextTag(2);){const se=f.getMessage(),q=new pe(se,p);if(se.release(),h&&!h.filter(q,t))continue;const ie=q.values||{},re=ie._minzoom,oe=ie._maxzoom;if(re&&re>=10*c||oe&&oe<=10*l)continue;const I=e.getFeatureInflatedBounds(q,l,p.extent,S);I==null||I[0]>b||I[1]>T||I[2]<m||I[3]<g||(I[0]=(I[0]-M)*w,I[1]=(I[1]-E)*w,I[2]=(I[2]-M)*w,I[3]=(I[3]-E)*w,this._index.insert(new pt(e,q,I,w,M,E)))}break}default:d.skip()}}async _getSymbolsAttributes(e,s){if(!s||s.length===0)return e;const t=[];s.sort(ts);let r=s[0].styleLayerUID,o=0;for(let a=0;a<s.length;a++)r!==s[a].styleLayerUID&&(t.push({from:o,to:a,styleLayerUID:r,sourceTileKey:s[a].vtlSymbol.sourceTile}),o=a,r=s[a].styleLayerUID);t.push({from:o,to:s.length,styleLayerUID:r,sourceTileKey:s[s.length-1].vtlSymbol.sourceTile});const n=this._styleRepository.layers;for(const a of t){const h=await this._getTilePayload(a.sourceTileKey),l=n[a.styleLayerUID],c=!!l&&h.find(u=>u.sourceName===l.source);c&&this._addSymbolsAttributes(e,s.slice(a.from,a.to).map(u=>u.vtlSymbol),r,c)}return e}_addSymbolsAttributes(e,s,t,r){const o=this._styleRepository.layers,n=r.key,a=this.tileKey,h=1<<a.level-n.level,l=a.row-n.row*h,c=a.col-n.col*h;this._getSymbolAttributes(r.protobuff,s,t,h,l,c).forEach(u=>{const{attributes:d,tilePoint:y}=u;e.push({layerId:o[t].id,layerIndex:t,graphic:new he({attributes:d,origin:{type:"vector-tile",layerId:o[t].id,layerIndex:t,layer:this._parentLayer}}),tilePoint:y})})}_getSymbolAttributes(e,s,t,r,o,n){const a=[],h=this._styleRepository.layers;let l=0;s.sort((u,d)=>u.featureIndex-d.featureIndex);const c=new Z(new Uint8Array(e),new DataView(e));for(;c.next();)switch(c.tag()){case 3:{const u=c.getMessage(),d=new _e(u);if(u.release(),d.name!==h[t].sourceLayer)continue;const y=d.getData(),p=d.extent/r,f=Ie/p,_=p*n,m=p*o;let g=0;for(;y.nextTag(2);){const b=y.getMessage();if(g++===s[l].featureIndex){const T=new pe(b,d),S=T.values,w=T.getGeometry(),M=w!=null?[f*(w[0][0].x-_),f*(w[0][0].y-m)]:null;a.push({attributes:S,tilePoint:M}),l++}if(b.release(),l===s.length)return a}break}default:c.skip()}return a}_queryIndex(e,s,t,r,o,n){var h;const a=Zt*r*(window.devicePixelRatio||1);return(h=this._index)==null||h.search({minX:s-a,minY:t-a,maxX:s+a,maxY:t+a},l=>{const{layer:c,feature:u}=l;c.isIntersectingFeature(s,t,r,u,o,n,l)&&e.push({layerId:c.id,layerIndex:c.uid,tilePoint:null,graphic:new he({attributes:u.values,origin:{type:"vector-tile",layerId:l.layer.id,layerIndex:l.layer.uid,layer:this._parentLayer}})})}),e}async _getTilePayload(e){return $e(this._tileKeyToPBF,e.id,()=>this._tileHandler.fetchTilePBFs(e)).then(s=>s)}}const ss=i=>({minX:i.bounds[0],minY:i.bounds[1],maxX:i.bounds[2],maxY:i.bounds[3]});class ve extends tt{constructor(){super(...arguments),this._fullCacheLodInfos=null,this._levelByScale={}}getTileParentId(e){const s=A.pool.acquire(e),t=s.level===0?null:A.getId(s.level-1,s.row>>1,s.col>>1,s.world);return A.pool.release(s),t}getTileCoverage(e,s,t=!0,r){const o=super.getTileCoverage(e,s,t,r);if(!o)return o;const n=1<<o.lodInfo.level;return o.spans=o.spans.filter(a=>a.row>=0&&a.row<n),o}scaleToLevel(e){if(this._fullCacheLodInfos||this._initializeFullCacheLODs(this._lodInfos),this._levelByScale[e])return this._levelByScale[e];{const s=this._fullCacheLodInfos;if(e>s[0].scale)return s[0].level;let t,r;for(let o=0;o<s.length-1;o++)if(r=s[o+1],e>r.scale)return t=s[o],t.level+(t.scale-e)/(t.scale-r.scale);return s[s.length-1].level}}_initializeFullCacheLODs(e){let s;if(e[0].level===0)s=e.map(t=>({level:t.level,resolution:t.resolution,scale:t.scale}));else{const t=this.tileInfo.size[0],r=this.tileInfo.spatialReference;s=Oe.create({size:t,spatialReference:r}).lods.map(o=>({level:o.level,resolution:o.resolution,scale:o.scale}))}for(let t=0;t<s.length;t++)this._levelByScale[s[t].scale]=s[t].level;this._fullCacheLodInfos=s}}const j=2,Ce=8,De=512;let Q=class extends mt(ft(gt)){constructor(){super(...arguments),this._styleChanges=[],this._fetchQueue=null,this._parseQueue=null,this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._styeChanged=!1,this._spriteSourceChanged=!1}get fading(){var i;return((i=this._vectorTileContainer)==null?void 0:i.fading)??!1}get hasVisibleFeatures(){const i=this._vectorTileContainer.children;for(const e of i)if(e.hasFeatures())return!0;return!1}get spriteSourceChanged(){return this._spriteSourceChanged}get styleChanged(){return this._styeChanged}async hitTest(i,e){var c,u;const s=this._tileHandlerPromise,t=(c=this._vectorTileContainer)==null?void 0:c.symbolFader;if(!s||!this._isTileHandlerReady||!t)return;await s;let r=null;const o=(u=this._vectorTileContainer)==null?void 0:u.symbolRepository;o&&(r=o.querySymbols(e,j,t.decluttererOffset,{}));const n=this.view.state,a=this._tileManager.getIntersectingTiles(e.x,e.y,j,n,r);if((!a||a.length===0)&&(r==null?void 0:r.length)===0)return null;i=i.clone().normalize();const h=[],l=[];for(const d of a)h.push(this._queryTile(l,i,j,this.view.state.rotation,d,r==null?void 0:r.filter(y=>y.tileKey.id===d.id)));return await Promise.all(h),l}update(i){if(this._tileHandlerPromise&&this._isTileHandlerReady)return i.pixelRatio!==this._tileHandler.devicePixelRatio?(this._start(),void(this._tileHandler.devicePixelRatio=i.pixelRatio)):void(this._styleChanges.length>0?this._tileHandlerPromise=this._applyStyleChanges():(this._pauseQueues(),this._fetchQueue.state=i.state,this._parseQueue.state=i.state,this._tileManager.update(i)||this.requestUpdate(),this._resumeQueues()))}attach(){const{style:i}=this.layer.currentStyleInfo;this._styleRepository=new de(i),this._tileInfoView=new ve(this.layer.tileInfo,this.layer.fullExtent),this._vectorTileContainer=new Xt(this._tileInfoView),this._tileHandler=new Ht(this.layer,this._styleRepository,window.devicePixelRatio||1,this.layer.tileInfo.lods.length-1),this.container.addChild(this._vectorTileContainer),this._start(),this.addAttachHandles([this.layer.on("paint-change",e=>{var s,t;if(this._styeChanged=!0,e.isDataDriven)this._styleChanges.push({type:x.PAINTER_CHANGED,data:e}),this.requestUpdate();else{const r=this._styleRepository,o=r.getLayerById(e.layer);if(!o)return;const n=o.type===v.SYMBOL;r.setPaintProperties(e.layer,e.paint),n&&((s=this._vectorTileContainer)==null||s.restartDeclutter()),(t=this._vectorTileContainer)==null||t.requestRender()}}),this.layer.on("layout-change",e=>{var o,n;const s=this._styleRepository,t=s.getLayerById(e.layer);if(!t)return;this._styeChanged=!0;const r=Ge(t.layout,e.layout);if(r!=null){if(Ke(r,"visibility")&&is(r)===1)return s.setLayoutProperties(e.layer,e.layout),t.type===v.SYMBOL&&((o=this._vectorTileContainer)==null||o.restartDeclutter()),void((n=this._vectorTileContainer)==null?void 0:n.requestRender());this._styleChanges.push({type:x.LAYOUT_CHANGED,data:e}),this.requestUpdate()}}),this.layer.on("style-layer-visibility-change",e=>{var r,o;const s=this._styleRepository,t=s.getLayerById(e.layer);t&&(this._styeChanged=!0,s.setStyleLayerVisibility(e.layer,e.visibility),t.type===v.SYMBOL&&((r=this._vectorTileContainer)==null||r.restartDeclutter()),(o=this._vectorTileContainer)==null||o.requestRender())}),this.layer.on("style-layer-change",e=>{this._styleChanges.push({type:x.LAYER_CHANGED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("delete-style-layer",e=>{this._styleChanges.push({type:x.LAYER_REMOVED,data:e}),this._styeChanged=!0,this.requestUpdate()}),this.layer.on("load-style",()=>this._loadStyle()),this.layer.on("spriteSource-change",e=>{this._spriteSourceChanged=!0,this._styleChanges.push({type:x.SPRITES_CHANGED,data:e});const s=this._styleRepository.layers;for(const t of s)switch(t.type){case v.SYMBOL:t.getLayoutProperty("icon-image")&&this._styleChanges.push({type:x.LAYOUT_CHANGED,data:{layer:t.id,layout:t.layout}});break;case v.LINE:t.getPaintProperty("line-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}});break;case v.FILL:t.getLayoutProperty("fill-pattern")&&this._styleChanges.push({type:x.PAINTER_CHANGED,data:{layer:t.id,paint:t.paint,isDataDriven:t.isPainterDataDriven()}})}this.requestUpdate()})])}detach(){this._stop(),this.container.removeAllChildren(),this._vectorTileContainer=V(this._vectorTileContainer),this._tileHandler=V(this._tileHandler)}viewChange(){this.requestUpdate()}moveEnd(){this.requestUpdate()}supportsSpatialReference(i){var e;return Ee((e=this.layer.tileInfo)==null?void 0:e.spatialReference,i)}canResume(){let i=super.canResume();const{currentStyleInfo:e}=this.layer;if(i&&(e!=null&&e.layerDefinition)){const s=this.view.scale,{minScale:t,maxScale:r}=e.layerDefinition;e!=null&&e.layerDefinition&&(t&&t<s&&(i=!1),r&&r>s&&(i=!1))}return i}isUpdating(){return this.fading}acquireTile(i){const e=this._createVectorTile(i);return this._updatingHandles.addPromise(this._fetchQueue.push(e.key).then(s=>this._parseQueue.push({key:e.key,data:s})).then(s=>{e.once("attach",()=>this.requestUpdate()),e.setData(s),this.requestUpdate()}).catch(s=>{X(s)||K.getLogger(this).error(s)})),e}releaseTile(i){const e=i.key.id;this._fetchQueue.abort(e),this._parseQueue.abort(e),this.requestUpdate()}async doRefresh(){if(!this.attached)return;if(this.suspended)return this._tileManager.clear(),void this.requestUpdate();this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache(),this._resumeQueues();const i=this._vectorTileContainer.children,e=[];try{for(const s of i){const t=this._updatingHandles.addPromise(this._fetchQueue.push(s.key).then(r=>this._parseQueue.push({key:s.key,data:r})).then(r=>s.setData(r)).finally(()=>s.featureIndex=null));e.push(t)}await Promise.all(e)}catch(s){K.getLogger(this).error("error refreshing vector-tiles layer-view",s),this._resumeQueues(),this._isTileHandlerReady=!0}this._isTileHandlerReady=!0,this.requestUpdate()}_start(){if(this._stop(),this._tileManager=new Se({acquireTile:s=>this.acquireTile(s),releaseTile:s=>this.releaseTile(s),tileInfoView:this._tileInfoView},this._vectorTileContainer),!this.layer.currentStyleInfo)return;const i=new AbortController,e=this._tileHandler.start({signal:i.signal}).then(()=>{this._fetchQueue=new ue({tileInfoView:this._tileInfoView,process:(s,t)=>this._getTileData(s,t),concurrency:15,scheduler:this.scheduler,priority:fe.MAPVIEW_FETCH_QUEUE}),this._parseQueue=new ue({tileInfoView:this._tileInfoView,process:(s,t)=>this._parseTileData(s,t),concurrency:8,scheduler:this.scheduler,priority:fe.MAPVIEW_VECTOR_TILE_PARSING_QUEUE}),this.requestUpdate(),this._isTileHandlerReady=!0});this._tileHandler.spriteMosaic.then(s=>{this._vectorTileContainer.setStyleResources(s,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this.requestUpdate()}),this._tileHandlerAbortController=i,this._tileHandlerPromise=e}_stop(){if(!this._tileHandlerAbortController||!this._vectorTileContainer)return;const i=this._tileHandlerAbortController;i&&i.abort(),this._tileHandlerPromise=null,this._isTileHandlerReady=!1,this._fetchQueue=V(this._fetchQueue),this._parseQueue=V(this._parseQueue),this._tileManager=V(this._tileManager),this._vectorTileContainer.removeAllChildren()}async _getTileData(i,e){return this._tileHandler.fetchTileData(i,e)}async _parseTileData(i,e){return this._tileHandler.parseTileData(i,e)}async _applyStyleChanges(){this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._tileManager.clearCache();const i=this._styleChanges;try{await this._tileHandler.updateStyle(i)}catch(o){K.getLogger(this).error("error applying vector-tiles style update",o.message),this._resumeQueues(),this._isTileHandlerReady=!0}const e=this._styleRepository,s=new Set;i.forEach(o=>{if(o.type!==x.LAYER_REMOVED)return;const n=o.data,a=e.getLayerById(n.layer);a&&s.add(a.uid)});const t=new Set;i.forEach(o=>{let n;switch(o.type){case x.PAINTER_CHANGED:e.setPaintProperties(o.data.layer,o.data.paint),n=o.data.layer;break;case x.LAYOUT_CHANGED:e.setLayoutProperties(o.data.layer,o.data.layout),n=o.data.layer;break;case x.LAYER_REMOVED:return void e.deleteStyleLayer(o.data.layer);case x.LAYER_CHANGED:e.setStyleLayer(o.data.layer,o.data.index),n=o.data.layer.id;break;case x.SPRITES_CHANGED:this._vectorTileContainer.setSpriteMosaic(this._tileHandler.setSpriteSource(o.data.spriteSource))}if(n){const a=e.getLayerById(n);a&&t.add(a.uid)}});const r=this._vectorTileContainer.children;if(s.size>0){const o=Array.from(s);this._vectorTileContainer.deleteStyleLayers(o);for(const n of r)n.deleteLayerData(o)}if(this._resumeQueues(),t.size>0){const o=Array.from(t),n=[];for(const a of r){const h=this._updatingHandles.addPromise(this._fetchQueue.push(a.key).then(l=>this._parseQueue.push({key:a.key,data:l,styleLayerUIDs:o})).then(l=>a.setData(l)).finally(()=>a.featureIndex=null));n.push(h)}await Promise.all(n)}this._styleChanges=[],this._isTileHandlerReady=!0,this.requestUpdate()}async _loadStyle(){const{style:i}=this.layer.currentStyleInfo,e=Ve(i);this._isTileHandlerReady=!1,this._pauseQueues(),this._clearQueues(),this._styleRepository=new de(e),this._vectorTileContainer.destroy(),this._tileManager.clear(),this._tileHandlerAbortController.abort(),this._tileHandlerAbortController=new AbortController;const{signal:s}=this._tileHandlerAbortController;try{this._tileHandlerPromise=this._tileHandler.setStyle(this._styleRepository,e,this.layer.tileInfo.lods.length-1),await this._tileHandlerPromise}catch(o){if(!X(o))throw o}if(s.aborted)return this._resumeQueues(),this._isTileHandlerReady=!0,this._styeChanged=!1,this._spriteSourceChanged=!1,void this.requestUpdate();const t=await this._tileHandler.spriteMosaic,r=this._vectorTileContainer;this._tileInfoView=new ve(this.layer.tileInfo,this.layer.fullExtent),r.setStyleResources(t,this._tileHandler.glyphMosaic,this._styleRepository,this._tileInfoView),this._tileManager=new Se({acquireTile:o=>this.acquireTile(o),releaseTile:o=>this.releaseTile(o),tileInfoView:this._tileInfoView},this._vectorTileContainer),this._resumeQueues(),this._isTileHandlerReady=!0,this.requestUpdate(),this._styeChanged=!1,this._spriteSourceChanged=!1}_createVectorTile(i){const e=this._tileInfoView.getTileBounds(F(),i),s=this._tileInfoView.getTileResolution(i.level);return new Kt(i,s,e[0],e[3],512,512,this._styleRepository)}async _queryTile(i,e,s,t,r,o){if(r.layerData.size===0)return;const n=this._ensureTileIndex(r),a=this._tileInfoView.getTileBounds(F(),r.key,!0),h=Ce*De*((e.x-a[0])/(a[2]-a[0])),l=Ce*De*(1-(e.y-a[1])/(a[3]-a[1])),c=await n.queryAttributes(h,l,s,t,o);for(const u of c)u.graphic.geometry=this._tileToMapPoint(u.tilePoint,r.transforms.tileUnitsToPixels),i.push({type:"graphic",layer:this.layer,graphic:u.graphic,mapPoint:e.clone()});i.sort((u,d)=>d.graphic.origin.layerIndex-u.graphic.origin.layerIndex)}_tileToMapPoint(i,e){if(!i)return null;const s=i[0]*e[0]+i[1]*e[3]+e[6],t=i[0]*e[1]+i[1]*e[4]+e[7],r=this.view.state,o=[0,0];return r.toMap(o,[s,t]),new ze({x:o[0],y:o[1],spatialReference:r.spatialReference})}_ensureTileIndex(i){let e=i.featureIndex;return e||(e=te.create(i.key,i.layerData,this._styleRepository,this._tileHandler,this.layer),i.featureIndex=e),e}_pauseQueues(){this._fetchQueue.pause(),this._parseQueue.pause()}_resumeQueues(){this._fetchQueue.resume(),this._parseQueue.resume()}_clearQueues(){this._fetchQueue.clear(),this._parseQueue.clear()}};function is(i){if(i==null)return 0;switch(i.type){case"partial":return Object.keys(i.diff).length;case"complete":return Math.max(Object.keys(i.oldValue).length,Object.keys(i.newValue).length);case"collection":return Object.keys(i.added).length+Object.keys(i.changed).length+Object.keys(i.removed).length}}ne([He()],Q.prototype,"_isTileHandlerReady",void 0),Q=ne([Fe("esri.views.2d.layers.VectorTileLayerView2D")],Q);const Qi=Q;export{Qi as default};
