import{h as y,iv as g,bq as H,bC as M,ep as $,it as P}from"./index-JysQxb7m.js";import{o as I,b as G}from"./fetchService-IPSkq0MP-DH3vOeo6.js";import{u as m,p as k,w as x,d as b,l as w,g as C,h as D,L as R,f as v}from"./loadUtils-B4p6zboh-DUvFKnin.js";import{s as L}from"./jsonContext-C9WBVzLb-DK5wBZQ7.js";import{o as V}from"./portalItemUtils-BfWDJg-S-Da4taYqM.js";import{g as j}from"./styleUtils-BnJpZ0Gl-BFeelRje.js";import"./associatedFeatureServiceUtils-5tlRvHRs-BucD56Fh.js";import"./PortalItem-BP-IQXnZ-q--yZGhn.js";import"./projectionUtils-B-CplN3q-DYZZu_-u.js";import"./asyncUtils-BPUlNCrX-BS2LVKAY.js";async function ie(t,n){const a=t.instance.portalItem;if(a!=null&&a.id)return await a.load(n),A(t),t.validateItem&&t.validateItem(a),E(t,n)}function A(t){const n=t.instance.portalItem;if(!(n!=null&&n.type)||!t.supportedTypes.includes(n.type))throw new y("portal:invalid-layer-item-type","Invalid layer item type '${type}', expected '${expectedType}'",{type:n==null?void 0:n.type,expectedType:t.supportedTypes.join(", ")})}async function E(t,n){const a=t.instance,e=a.portalItem;if(!e)return;let{url:i}=e;const{title:r}=e,s=L(e,"portal-item");if(a.type==="group")return J(a,s,t);i&&a.type!=="media"&&a.read({url:i},s);const u=new v,{data:p,preferredHost:o}=await S(t,u,n);return i=e.url,"isUrlHostModified"in a&&(o?a.applyPreferredHost({preferredHost:o}):a.applyHostFromPortalItem()),p&&a.read(p,s),a.resourceReferences={portalItem:e,paths:s.readResourcePaths??[]},a.type!=="subtype-group"&&a.read({title:r},s),j(a,s)}async function J(t,n,a){const e=t.portalItem;if(!t.sourceIsPortalItem)return;const{title:i,type:r}=e;if(r==="Group Layer"){if(!V(e,"Map"))throw new y("portal:invalid-layer-item-typekeyword","'Group Layer' item without 'Map' type keyword is not supported");return N(t,a)}return t.read({title:i},n),O(t,a)}async function N(t,n){const a=t.portalItem,e=await a.fetchData("json");if(!e)return;if(!n.populateGroupLayer)throw new y("portal:missing-populate-group-layer","Missing populate group layer");const i=L(a,"web-map");t.read(e,i),await n.populateGroupLayer(t,e,{context:i}),t.resourceReferences={portalItem:a,paths:i.readResourcePaths??[]}}async function O(t,n){var c;let a;const{portalItem:e}=t;if(!e)return;const i=e.type,r=n.layerModuleTypeMap;if(!r)throw new y("portal:missing-layer-module-type-map","Layer module type map is required to construct sub layers");switch(i){case"Feature Service":case"Feature Collection":a=r.FeatureLayer;break;case"Stream Service":a=r.StreamLayer;break;case"Scene Service":a=r.SceneLayer;break;case"Video Service":a=r.VideoLayer;break;default:throw new y("portal:unsupported-item-type-as-group",`The item type '${i}' is not supported as a 'IGroupLayer'`)}const s=i==="Video Service",u=new v;let[p,{data:o}]=await Promise.all([a(),s?{data:null}:S(n,u)]),l=()=>p;if(s)return B(t,l,r);if(i==="Feature Service"){const f=(c=m(o))==null?void 0:c.customParameters;o=e.url?(await k(o,e.url,u)).data:{},l=await Z(o,r)||l;const{provider:T,preferredHost:F}=await W(e.url,{customParameters:f,loadContext:u});return g(e,F),await d(t,l,l,o,r,T)}return i==="Scene Service"&&e.url&&(o=await x(e,o,u)),b(o)>0?await d(t,l,null,o,r):await q(t,l,r)}async function q(t,n,a){var r,s;const{portalItem:e}=t;if(!(e!=null&&e.url))return;const i=await I(e.url);i&&d(t,n,null,{layers:(r=i.layers)==null?void 0:r.map(w),tables:(s=i.tables)==null?void 0:s.map(w)},a)}async function B(t,n,a){var r;const{portalItem:e}=t;if(!(e!=null&&e.url))return;const i=await I(e.url);i&&d(t,n,null,{layers:(r=i.layers)==null?void 0:r.map(({id:s,name:u})=>({id:s,name:u}))},a)}async function d(t,n,a,e,i,r){var p;let s=e.layers||[];const u=e.tables||[];if(((p=t.portalItem)==null?void 0:p.type)==="Feature Collection"?(s.forEach((o,l)=>{var c;o.id=l,((c=o==null?void 0:o.layerDefinition)==null?void 0:c.type)==="Table"&&u.push(o)}),s=s.filter(o=>{var l;return((l=o==null?void 0:o.layerDefinition)==null?void 0:l.type)!=="Table"})):(s.reverse(),u.reverse()),s.forEach(o=>{const l=r==null?void 0:r(o);if(l||!r){const c=h(t,n(o),e,o,l);t.add(c)}}),u.length){const o=a?null:await i.FeatureLayer();u.forEach(l=>{const c=r==null?void 0:r(l);if(c||!r){const f=h(t,a?a(l):o,e,l,c);t.tables.add(f)}})}}function h(t,n,a,e,i){const r=t.portalItem,s={portalItem:r.clone(),layerId:e.id};e.url!=null&&(s.url=e.url);const u=new n(s);if("sourceJSON"in u&&(u.sourceJSON=i),u.type!=="subtype-group"&&u.type!=="catalog"&&(u.sublayerTitleMode="service-name"),r.type==="Feature Collection"){const p={origin:"portal-item",portal:r.portal||H.getDefault()};u.read(e,p);const o=a.showLegend;o!=null&&u.read({showLegend:o},p)}return u}async function S(t,n,a){if(t.supportsData===!1)return{data:void 0};const e=t.instance,i=e.portalItem;if(!i)return{data:void 0};let r=null;try{r=await i.fetchData("json",a)}catch{}if(K(e)){let s=null;const{count:u,preferredHost:p}=await U(i,r,n);if(g(i,p),((r==null?void 0:r.layers)||(r==null?void 0:r.tables))&&u>0){if(e.layerId==null){const o=C(e.type),l=o!=null&&o.length?D(r,o)[0]:m(r);l&&(e.layerId=l.id)}s=z(r,e),(s==null?void 0:s.layerType)==="OrientedImageryLayer"&&e.type==="oriented-imagery"&&e.supportedSourceTypes.add("Feature Layer"),s&&r.showLegend!=null&&(s.showLegend=r.showLegend)}return u>1&&"sublayerTitleMode"in e&&e.sublayerTitleMode!=="service-name"&&(e.sublayerTitleMode="item-title-and-service-name"),{data:s,preferredHost:p}}return{data:r}}async function U(t,n,a){var s,u,p,o,l;if(n!=null&&n.layers&&(n!=null&&n.tables))return{count:b(n)};const e=M(t.url);if(!e)return{count:1};const i=e.url.path,r=await a.fetchServiceMetadata(i,{customParameters:(s=m(n))==null?void 0:s.customParameters}).catch(()=>null);return{count:(((u=n==null?void 0:n.layers)==null?void 0:u.length)??((p=r==null?void 0:r.layers)==null?void 0:p.length)??0)+(((o=n==null?void 0:n.tables)==null?void 0:o.length)??((l=r==null?void 0:r.tables)==null?void 0:l.length)??0),preferredHost:$(t)?P():null}}function z(t,n){var i,r;const{layerId:a}=n,e=((i=t.layers)==null?void 0:i.find(s=>s.id===a))||((r=t.tables)==null?void 0:r.find(s=>s.id===a));return e&&Q(e,n)?e:null}function K(t){return t.type!=="stream"&&"layerId"in t}function Q(t,n){const a="layerType"in t&&t.layerType,{type:e}=n;return!(e==="feature"&&a&&t.layerType!=="ArcGISFeatureLayer"||e==="catalog"&&!a||e==="oriented-imagery"&&!a||e==="subtype-group"&&!a)}async function W(t,n){const{layersJSON:a,preferredHost:e}=await G(t,n);if(!a)return{provider:null,preferredHost:e};const i=[...a.layers,...a.tables];return{provider:r=>i.find(s=>s.id===r.id),preferredHost:e}}async function Z(t,n){const{layers:a,tables:e}=t,i=[...a??[],...e??[]];if(!i.length)return;const r=new Set,s=[];for(const{layerType:o}of i){const l=o??"ArcGISFeatureLayer";if(r.has(l))continue;r.add(l);const c=n[R(l)];s.push(c())}const u=await Promise.all(s),p=new Map;return Array.from(r).forEach((o,l)=>{p.set(o,u[l])}),({layerType:o})=>{const l=o??"ArcGISFeatureLayer";return p.get(l)}}export{ie as load};
