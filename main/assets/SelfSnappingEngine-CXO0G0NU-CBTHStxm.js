import{ac as X,a0 as Y,v as _,S as P,du as C,n as K,az as Q}from"./index-DECxckyg.js";import{u as W,c as G}from"./Cyclical-DgD7_U1C-DeKSo0c-.js";import{o as H,t as A}from"./quantityUtils-B1Ov7DZK-BxtSXfLN.js";import{b as u}from"./elevationInfoUtils-Ccn2Wfoe-Dkd5S0ss.js";import{D as Z,z as $,B as m,I as M,M as f,R as F,S as b,T as S,X as ee,_ as R,Y as z,a0 as te,c as ie,a1 as q,n as l,J as y,a2 as I,a3 as se,a4 as T,a5 as re,C as ne,a6 as oe,a7 as ae,a8 as he}from"./SketchViewModel-B0qFHK0t-BPVoqr27.js";import{M as J,i as B,P as de,l as pe,y as ce,A as le,f as j}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{o as O}from"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{N as ge,r as fe,A as ue}from"./vec32-Cj8pVsU0-_k_0y_aO.js";import"./ElevationInfo-DE5to86a-zZvCtC1M.js";import"./lengthUtils-C61nRlXw-CNiQkeeF.js";import"./UpdatingHandles-Bd2FQ26N-CPeQVO1m.js";import"./projectionUtils-B-CplN3q-dCP8PmW1.js";import"./GraphicsLayer-BiEC2-gS-DSKnymkB.js";import"./GraphicsCollection-uWAVmks7-DJ4BOlOA.js";import"./Layer-DvVVmz9x-D2JZ_h1N.js";import"./TimeExtent-Cf2Pienb-DASHDtdu.js";import"./BlendLayer-DjW_5k0v-CiV_4sQK.js";import"./layerContainerType-ChWdCT09-G5sdAsSy.js";import"./jsonUtils-BwLwuQj7-s-55UT6y.js";import"./parser-CWccHtwJ-CKACZqwA.js";import"./mat4f32-BdRMyjXW-CWt6U0BP.js";import"./mat4-OOmHNWi7-BlAajtXL.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./ScaleRangeLayer-x42fwED3-BPHyoz7r.js";import"./editableLayers-DFUBlMJy-snLFy9cR.js";import"./utils-Dd8gTonD-DUYRQ7Um.js";import"./Queue-DV3gpSdl-dEQtqDMO.js";import"./Version-CnwD6MZa-C2nxDhmR.js";import"./projectVectorToVector-DcyiGOWJ-CDN5YqHG.js";import"./projectPointToVector-BZJhoF_5-C6CtqXX8.js";import"./geodesicUtils-DKS2UG72-ETyX6iOS.js";import"./asyncUtils-BPUlNCrX-DKWscr2H.js";import"./Query-n1aoaaFC-DEpJ8fHn.js";import"./Field-BIQ-quF4-CUYPWLA1.js";import"./fieldType-PhcL4ff8-DZQJCxjF.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./plane-Cf3Koz3c-BErhslGI.js";import"./vectorStacks-5ZZtmT9E-DSFWRh8B.js";import"./mat3f64-BnNZDR5l-Bz3OL2oI.js";import"./mat4f64-xsZDPPj0-Dq35B4BL.js";import"./quatf64-C16JxGFv-BKWK1F8U.js";import"./sphere-zPMQWhGG-DLIwZr6O.js";import"./mat3-DOnW3DjW-C3hbW9XY.js";import"./geodeticLengthOperator-DHGBHzf3-kIlow3Tp.js";import"./geodeticCurveType-D_etKnbP-CirnHLSB.js";import"./earcut-C6NeZYSh-Da0ULCQ5.js";import"./triangle-BM89wdHY-BGay_Mgz.js";import"./lineSegment-BAWQVP9P-CxLisQzg.js";import"./spatialReferenceEllipsoidUtils-BK0OQJn2-BUjoUZO0.js";class k{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=y.shortLineThreshold*y.shortLineThreshold}snap(e,t){return t.vertexHandle!=null?t.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(f(e.leftVertex.pos,this.view,t),f(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return this.squaredShortLineThreshold===0||S(m(t,i,u,this.view),m(e,i,u,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=Q(i);return j(l(e),l(t))*s<y.verticalLineThresholdMeters}squaredProximityThreshold(e){return e==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class me extends k{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,n=[];if(s<1)return n;const{spatialReference:o}=t,h=m(e,o,u,this.view),{view:a}=this,d=i.edges[s-1];let p=d;do{if(this.edgeExceedsShortLineThreshold(p,t)){const c=M(p,a,t);this._processCandidateProposal(c.left,c.right,e,h,t,n)}p=p.leftVertex.leftEdge}while(p&&p!==d);return n}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,n=s.component;if(n.edges.length<2)return i;const{view:o}=this,{spatialReference:h}=t,a=m(e,h,u,o),d=s.leftEdge,p=s.rightEdge;d&&p&&this.edgeExceedsShortLineThreshold(d,t)&&this.edgeExceedsShortLineThreshold(p,t)&&this._processCandidateProposal(f(d.leftVertex.pos,o,t),f(p.rightVertex.pos,o,t),e,a,t,i);const c=n.edges[0];let g=c;do{if(g!==s.leftEdge&&g!==s.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const v=M(g,o,t);this._processCandidateProposal(v.left,v.right,e,a,t,i)}g=g.rightVertex.rightEdge}while(g&&g!==c);return i}_processCandidateProposal(e,t,i,s,n,o){var c;const{spatialReference:h,pointer:a}=n,d=C();xe(d,e,t,i,n,this._geodesicLengthMeasurementUtils);const p=F(b(d));S(s,m(p,h,u,this.view))<this.squaredProximityThreshold(a)&&o.push(new ee({lineStart:e,lineEnd:t,targetPoint:p,isDraped:((c=n.elevationInfo)==null?void 0:c.mode)==="on-the-ground"}))}}function xe(r,e,t,i,s,n){ve(r,e,t,i,s,n)||Ee(r,i,e,t)}function ve(r,e,t,i,{spatialReference:s},n){const o=R(e,t,s,s);if(o==null)return!1;const h=R(t,i,s,s);if(h==null)return!1;const a=n.geodesicDistance(t,i,s);if(a==null)return!1;const d=Math.abs(W.shortestSignedDiff(o,h))>Math.PI/2?G.normalize(o+Math.PI):o;return z(r,t,s,H(a,"meters"),A(d,"radians","geographic"),"geodesic"),r[2]=i[2],!0}function Ee(r,e,t,i){te(e,{start:t,end:i,type:ie.LINE},r),r[2]=e[2]}let we=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=t.vertices.length,n=[];if(i<2)return n;const{view:o}=this,h=m(r,e.spatialReference,u,o),a=f(t.vertices[s-1].pos,o,e),d=f(t.vertices[0].pos,o,e),p=t.edges[i-1];let c=p;do{if(this.edgeExceedsShortLineThreshold(c,e)){const g=M(c,o,e);this._checkEdgeForParallelLines(g,a,r,h,e,n),this._checkEdgeForParallelLines(g,d,r,h,e,n)}c=c.leftVertex.leftEdge}while(c&&c!==p);return n}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<3)return t;const{view:n}=this,o=m(r,e.spatialReference,u,n),h=i.leftEdge,a=i.rightEdge,d=s.vertices[0],p=f(d.pos,n,e),c=s.vertices.length,g=s.vertices[c-1],v=f(g.pos,n,e),V=s.edges[0];let x=V;do{if(x!==h&&x!==a&&this.edgeExceedsShortLineThreshold(x,e)){const E=M(x,n,e);h&&this._checkEdgeForParallelLines(E,f(h.leftVertex.pos,n,e),r,o,e,t),a&&this._checkEdgeForParallelLines(E,f(a.rightVertex.pos,n,e),r,o,e,t),i===d?this._checkEdgeForParallelLines(E,v,r,o,e,t):i===g&&this._checkEdgeForParallelLines(E,p,r,o,e,t)}x=x.rightVertex.rightEdge}while(x&&x!==V);return t}_checkEdgeForParallelLines(r,e,t,i,s,n){var c;const o=r.left,h=r.right;if(q(w,l(e),l(o),l(h)),J(w,l(e))<y.parallelLineThreshold)return;q(w,l(t),l(o),l(h),l(e));const{spatialReference:a,pointer:d}=s,p=F(I(w[0],w[1],t[2]));if(S(i,m(p,a,u,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(p,e,s)||this.isVertical(o,h,s)||Ve(r,n))return;n.push(new se({referenceLine:r,lineStart:e,targetPoint:p,isDraped:((c=s.elevationInfo)==null?void 0:c.mode)==="on-the-ground"}))}}};function Ve(r,e){const t=r.left,i=r.right;for(const s of e)if(q(w,l(i),l(s.constraint.start),l(s.constraint.end),l(t)),J(w,l(i))<y.parallelLineThreshold)return s.addReferenceLine(r),!0;return!1}const w=O();class Le extends k{constructor(e,t,i){super(e,t),this._geodesicLengthMeasurementUtils=i}snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:n}=this,o=m(e,t.spatialReference,u,n),h=i.vertices.at(-1);this._checkForSnappingCandidate(T.LastVertex,s,h.leftEdge,h,h.leftEdge.leftVertex,e,o,t);const a=i.vertices[0];return this._checkForSnappingCandidate(T.FirstVertex,s,a.rightEdge,a,a.rightEdge.rightVertex,e,o,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:n}=this,o=m(e,t.spatialReference,u,n),h=s.leftEdge,a=s.rightEdge;if(h!=null&&h.leftVertex.leftEdge){const d=h.leftVertex.leftEdge;this._checkForSnappingCandidate(T.ExistingEdge,i,d,d.rightVertex,d.leftVertex,e,o,t)}if(a!=null&&a.rightVertex.rightEdge){const d=a.rightVertex.rightEdge;this._checkForSnappingCandidate(T.ExistingEdge,i,d,d.leftVertex,d.rightVertex,e,o,t)}return i}_checkForSnappingCandidate(e,t,i,s,n,o,h,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const d=this.view,p=f(s.pos,d,a),c=f(n.pos,d,a);_e(N,c,p,o,a,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(e,t,c,p,N,o,h,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,n,o,h,a){var E;const{spatialReference:d,pointer:p}=a,c=B(D,l(o),l(s)),g=de(n,c)/pe(n),v=ce(D,l(s),n,g),V=F(I(v[0],v[1],o[2]));if(S(h,m(V,d,u,this.view))>this.squaredProximityThreshold(p)||this.isVertical(V,s,a)||this.isVertical(s,i,a))return;const x=ge(C(),s,n,Math.sign(g));t.push(new re({targetPoint:V,constraint:new ne(s,b(x)),previousVertex:i,otherVertex:s,otherVertexType:oe.CENTER,selfSnappingType:e,isDraped:((E=a.elevationInfo)==null?void 0:E.mode)==="on-the-ground"}))}}function _e(r,e,t,i,s,n){ye(r,e,t,i,s,n)||Se(r,e,t)}function ye(r,e,t,i,{spatialReference:s},n){const o=R(e,t,s,s);if(o==null)return!1;const h=R(t,i,s,s);if(h==null)return!1;const a=Math.sign(G.shortestSignedDiff(o,h))*Math.PI*.5,d=A(o+a,"radians","geographic"),p=C(),c=n.geodesicDistance(t,i,s);return c!=null&&(z(p,t,s,H(c,"meters"),d,"geodesic"),fe(r,p,t),!0)}function Se(r,e,t){const i=B(D,l(t),l(e));ue(r,i[1],-i[0],0)}const D=O(),N=C();let Pe=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=[],s=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||s<2)return i;const{view:n}=this,o=t.vertices[0],h=t.vertices[s-1],a=f(o.pos,n,e),d=f(h.pos,n,e);return this._processCandidateProposal(a,d,r,e,i),i}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2||e.editGeometryOperations.data.type==="polyline"&&(i.index===0||i.index===s.vertices.length-1))return t;const{view:n}=this,o=f(i.leftEdge.leftVertex.pos,n,e),h=f(i.rightEdge.rightVertex.pos,n,e);return this._processCandidateProposal(o,h,r,e,t),t}_processCandidateProposal(r,e,t,i,s){var g;if(!this.exceedsShortLineThreshold(r,e,i))return;const n=le(U,l(r),l(e),.5),o=.5*j(l(r),l(e)),h=ae(U,l(t),n,o),a=F(I(h[0],h[1],t[2])),{spatialReference:d,pointer:p}=i,c=m(t,d,u,this.view);if(S(c,m(a,d,u,this.view))<this.squaredProximityThreshold(p)){if(this.isVertical(r,a,i)||this.isVertical(a,e,i))return;s.push(new he({targetPoint:a,point1:r,point2:e,isDraped:((g=i.elevationInfo)==null?void 0:g.mode)==="on-the-ground"}))}}};const U=O();let L=class extends X{constructor(r){super(r),this.updating=!1,this._snappers=new Y,this._domain=Z.SELF}initialize(){this._snappers.push(new we(this.view,this.options),new me(this.view,this.options,this.geodesicLengthMeasurementUtils),new Le(this.view,this.options,this.geodesicLengthMeasurementUtils),new Pe(this.view,this.options))}set options(r){this._set("options",r);for(const e of this._snappers)e.options=r}async fetchCandidates(r,e,t){if(!(e&this._domain&&this.options.effectiveSelfEnabled))return[];const i=[];for(const s of this._snappers.items)for(const n of s.snap(r,t))i.push(n);return $(r,i),i}};_([P({readOnly:!0})],L.prototype,"updating",void 0),_([P({constructOnly:!0})],L.prototype,"view",void 0),_([P({constructOnly:!0})],L.prototype,"geodesicLengthMeasurementUtils",void 0),_([P()],L.prototype,"options",null),L=_([K("esri.views.interactive.snapping.SelfSnappingEngine")],L);export{L as SelfSnappingEngine};
