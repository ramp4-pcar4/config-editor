import{jY as be,jZ as Pe}from"./index-BeTPrQ6f.js";import{Z as $,G as he,D as ye,R as xe,ba as le,q as Ce,ay as De,bb as we,J as Te,h as ce,v as f,s as ve,Y as se,N as U,aQ as Se,m as Ie,o as Me}from"./Point2D-BVUQyGsf-qih0ZuJV.js";import{e as te}from"./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js";import{p as ue,s as fe,t as Ve,u as A,x as _e,b as j,e as J,h as ie,E as Q,v as Ee,r as ne,M as Ye,P as re,F as K,G as de}from"./ProjectionTransformation-BXUROh_s-kKBZ5FDB.js";import{Envelope2D as G}from"./Envelope2D-2iYexKQo-BCKocNS7.js";import{E as ae}from"./Transformation2D-CZCvoz9N-B-IhcWnl.js";import{g as Re}from"./GeometryCleaner-BEJM7I4l-D17pxNCQ-DWXxThGT.js";import{y as ke}from"./OperatorSimplifyOGC-LxORArjZ-CAWJzjpM.js";import{j as Ae}from"./OperatorGeneralize-D1zTV4Nc-6bRWAUT6.js";var y;function z(a,e,t,s,r,n){return{m_from:a.clone(),m_to:e.clone(),m_center:t.clone(),m_next:r,m_type:s}}function W(a,e,t,s,r){return{m_from:a.clone(),m_to:e.clone(),m_next:t,m_type:4,m_center:new f}}(function(a){a[a.enumDummy=256]="enumDummy",a[a.enumLine=1]="enumLine",a[a.enumArc=2]="enumArc",a[a.enumMiter=8]="enumMiter",a[a.enumBevel=16]="enumBevel",a[a.enumJoinMask=26]="enumJoinMask",a[a.enumConnectionMask=27]="enumConnectionMask"})(y||(y={}));class Xe extends te{constructor(e,t,s,r,n,i,h,o,l,m){super(),this.m_index=0,this.m_bufferedPolygon=null,this.m_x=0,this.m_y=0,this.m_progressTracker=m,this.m_parent=e,this.m_mp=t,this.m_distance=s,this.m_spatialReference=r,this.m_densifyDist=o,this.m_maxVertexInCompleteCircle=l,this.m_joins=n,this.m_caps=i,this.m_miterLimit=h}next(){const e=new J;for(;;){if(this.m_index===this.m_mp.getPointCount())return null;if(this.m_caps===1)return this.m_index=this.m_mp.getPointCount(),new A({vd:this.m_mp.getDescription()});if(this.m_mp.getPointByVal(this.m_index,e),this.m_index++,!e.isEmpty())break}let t,s=!1;if(this.m_bufferedPolygon===null&&(this.m_x=e.getX(),this.m_y=e.getY(),this.m_bufferedPolygon=this.m_parent.buffer(e,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle),s=!0),t=this.m_index<this.m_mp.getPointCount()?this.m_bufferedPolygon.clone():this.m_bufferedPolygon,!s){const r=new ae,n=e.getX()-this.m_x,i=e.getY()-this.m_y;r.setShiftCoords(n,i),t.applyTransformation(r)}return de(t,0),t}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Be extends te{constructor(e){super(),this.m_currentPathIndex=0,this.m_polyline=e}next(){if(!this.m_polyline)return null;const e=this.m_polyline.getImpl(),t=e.getPathCount();if(this.m_currentPathIndex<t){const s=this.m_currentPathIndex;if(this.m_currentPathIndex++,!e.isClosedPathInXYPlane(s)){let n=e.getXY(e.getPathEnd(s)-1);for(;this.m_currentPathIndex<e.getPathCount();){const i=e.getXY(e.getPathStart(this.m_currentPathIndex));if(e.isClosedPathInXYPlane(this.m_currentPathIndex)||!i.equals(n))break;n=e.getXY(e.getPathEnd(this.m_currentPathIndex)-1),this.m_currentPathIndex++}}if(s===0&&this.m_currentPathIndex===this.m_polyline.getPathCount()){const n=this.m_polyline;return this.m_polyline=null,n}const r=new j({vd:this.m_polyline.getDescription()});r.addPath(this.m_polyline,s,!0);for(let n=s+1;n<this.m_currentPathIndex;n++)r.addSegmentsFromPath(this.m_polyline,n,0,e.getSegmentCountPath(n),!1);return this.m_currentPathIndex===this.m_polyline.getPathCount()&&(this.m_polyline=null),r}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class qe extends te{constructor(e,t,s){super(),this.m_geometry=null,this.m_index=0,this.m_bufferer=e,this.m_geoms=t,this.m_index=0,this.m_bFilter=s}next(){if(this.m_geometry===null&&(this.m_index=0,this.m_geometry=this.m_geoms.next(),!this.m_geometry))return null;const e=this.m_geometry.getImpl();if(this.m_index<e.getPathCount()){const t=this.m_index;return this.m_index++,this.m_bufferer.bufferPolylinePath(this.m_geometry,t,this.m_bFilter)}return this.m_geometry=null,this.next()}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class Fe extends te{constructor(e){super(),this.m_index=0,this.m_bufferer=e}next(){const e=this.m_bufferer.m_geometry;if(this.m_index<e.getPathCount()){const t=this.m_index,s=e.calculateRingArea2D(this.m_index);for(U(s>0),this.m_index++;this.m_index<e.getPathCount()&&!(e.calculateRingArea2D(this.m_index)>0);)this.m_index++;let r;return r=t===0&&this.m_index===e.getPathCount()?this.m_bufferer.bufferPolygonImpl(e,0,e.getPathCount()):this.m_bufferer.bufferPolygonImpl(e,t,this.m_index),r}return null}getGeometryID(){return 0}getRank(){return 1}tock(){return!0}}class We{constructor(e){this.m_geometry=null,this.m_bufferCommands=[],this.m_originalGeomType=$.enumUnknown,this.m_maxVertexInCompleteCircle=-1,this.m_circleTemplateSize=-1,this.m_oldCircleTemplateSize=0,this.m_spatialReference=null,this.m_tolerance=new ue(0,0),this.m_smallTolerance=new ue(0,0),this.m_filterTolerance=0,this.m_densifyDist=-1,this.m_distance=Number.NaN,this.m_absDistance=0,this.m_absDistanceReversed=0,this.m_dA=-1,this.m_miterLimit=4,this.m_joins=0,this.m_caps=0,this.m_bRoundBuffer=!0,this.m_bOutputLoops=!0,this.m_bFilter=!0,this.m_circleTemplate=[],this.m_leftStack=[],this.m_middleStack=[],this.m_helperLine1=new fe,this.m_helperLine2=new fe,this.m_helperArray=[],this.m_progressCounter=0,this.m_densificator=Ve.constructDefault(e),this.m_progressTracker=e}buffer(e,t,s,r,n,i,h,o){if(e||he("Geometry.Bufferer.Impl.Buffer"),h<0&&he("Geometry.Bufferer.Impl.Buffer"),ye(e.getGeometryType())&&xe("Unsupported geometry type."),e.isEmpty())return new A({vd:e.getDescription()});if(this.m_joins=r,this.m_caps=n,this.m_bRoundBuffer=!1,this.m_miterLimit=i,this.m_originalGeomType=e.getGeometryType(),le(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_joins===0:Ce(this.m_originalGeomType)?this.m_bRoundBuffer=this.m_caps===0:De(this.m_originalGeomType)&&(this.m_bRoundBuffer=this.m_joins===0&&this.m_caps===0),this.m_bFilter=this.m_bRoundBuffer,this.m_geometry=Re(e),this.m_geometry.isEmpty())return new A({vd:e.getDescription()});const l=new G;this.m_geometry.queryLooseEnvelope(l),t>0&&l.inflateCoords(t,t),this.m_tolerance=_e(s,l,!0),this.m_smallTolerance=_e(null,l,!0),o<=0&&(o=96),this.m_spatialReference=s,this.m_distance=t,this.m_absDistance=Math.abs(this.m_distance),this.m_absDistanceReversed=this.m_absDistance!==0?1/this.m_absDistance:0,Number.isNaN(h)||h===0?h=1e-5*this.m_absDistance:h>.5*this.m_absDistance&&(h=.5*this.m_absDistance),o<12&&(o=12);const m=Math.abs(t)*(1-Math.cos(Math.PI/o));if(m>h)h=m;else if(t!==0){const u=Math.PI/Math.acos(1-h/Math.abs(t));u<o-1&&(o=Math.trunc(u))<12&&(o=12,h=Math.abs(t)*(1-Math.cos(Math.PI/o)))}this.m_densifyDist=h,this.m_maxVertexInCompleteCircle=o,this.m_filterTolerance=this.m_bRoundBuffer?Math.min(this.m_smallTolerance.total(),.25*this.m_densifyDist):0,this.m_circleTemplateSize=this.calcN(),this.m_circleTemplateSize!==this.m_oldCircleTemplateSize&&(this.m_circleTemplate.length=0,this.m_oldCircleTemplateSize=this.m_circleTemplateSize),this.m_densifyDist>0&&we(this.m_geometry)&&(this.m_geometry=this.m_densificator.densifyEx(this.m_geometry,0,this.m_densifyDist,0,this.m_joins!==0,Te()));const c=this.bufferImpl();return this.m_geometry=null,c}generateCircleTemplate(){if(this.m_circleTemplate.length)return;const e=this.m_circleTemplateSize,t=Math.trunc((e+3)/4),s=.5*Math.PI/t;this.m_dA=s,this.m_circleTemplate=ce(f,4*t);const r=Math.cos(s),n=Math.sin(s),i=f.construct(0,1);for(let h=0;h<t;h++)this.m_circleTemplate[h+0*t].setCoords(i.y,-i.x),this.m_circleTemplate[h+1*t].setCoords(-i.x,-i.y),this.m_circleTemplate[h+2*t].setCoords(-i.y,i.x),this.m_circleTemplate[h+3*t].setCoords(i.x,i.y),i.rotateReverse(r,n)}bufferImpl(){const e=this.m_geometry.getGeometryType();if(ve(e)){const t=new j({vd:this.m_geometry.getDescription()});return t.addSegment(this.m_geometry,!0),this.m_geometry=t,this.bufferImpl()}if(this.m_distance<=this.m_tolerance.total()){if(!le(e))return new A({vd:this.m_geometry.getDescription()});if(this.m_distance<0){const t=new G;if(this.m_geometry.queryEnvelope(t),t.width()<=2*this.m_absDistance||t.height()<=2*this.m_absDistance)return new A({vd:this.m_geometry.getDescription()})}}switch(this.m_geometry.getGeometryType()){case $.enumPoint:return this.bufferPoint();case $.enumMultiPoint:return this.bufferMultiPoint();case $.enumPolyline:return this.bufferPolyline();case $.enumPolygon:return this.bufferPolygon();case $.enumEnvelope:return this.bufferEnvelope();default:se("")}}bufferPolyline(){if(this.isDegenerateGeometry(this.m_geometry)){const l=new J;this.m_geometry.getPointByVal(0,l);const m=new G;return this.m_geometry.queryEnvelope(m),l.setXY(m.getCenter()),this.bufferDegeneratePath(l,!0)}const e=this.m_geometry,t=this.m_geometry.getDescription();this.m_geometry=null;const s=new Be(e);let r,n;r=this.m_joins===0?new Ae().executeMany(s,.25*this.m_densifyDist,!1,this.m_progressTracker):s,n=this.m_bRoundBuffer?new ke().executeMany(r,null,!0,this.m_progressTracker):r;const i=new qe(this,n,this.m_bFilter),h=new ie().executeMany(i,this.m_spatialReference,this.m_progressTracker,2),o=new Q().executeMany(h,this.m_spatialReference,!1,this.m_progressTracker).next();return o!==null?o:new A({vd:t})}bufferPolygon(){if(this.m_distance===0)return this.m_geometry;this.generateCircleTemplate();const e=new Q().execute(this.m_geometry,null,!1,this.m_progressTracker);if(this.m_distance<0){if(this.m_geometry=e,this.m_geometry.isEmpty())return this.m_geometry;const t=this.m_geometry,s=this.bufferPolygonImpl(t,0,t.getPathCount());return new Q().execute(s,this.m_spatialReference,!1,this.m_progressTracker)}{if(this.m_geometry=e,this.isDegenerateGeometry(this.m_geometry)){const n=new J;this.m_geometry.getPointByVal(0,n);const i=new G;return this.m_geometry.queryEnvelope(i),n.setXY(i.getCenter()),this.bufferDegeneratePath(n,!0)}const t=new Fe(this),s=new ie().executeMany(t,this.m_spatialReference,this.m_progressTracker,2),r=new Q().executeMany(s,this.m_spatialReference,!1,this.m_progressTracker).next();return r!==null?r:new A({vd:this.m_geometry.getDescription()})}}bufferPolygonImpl(e,t,s){const r=e,n=r.getImpl();let i=new A({vd:e.getDescription()});for(let h=t;h<s;h++){if(n.getPathSize(h)<1)continue;const o=n.calculateRingArea2D(h),l=new G;if(n.queryPathEnvelope(h,l),this.m_distance>0)if(o>0)if(this.isDegeneratePath(n,h)){const m=new J;n.getPointByVal(n.getPathStart(h),m),m.setXY(l.getCenter()),i.add(this.bufferDegeneratePath(m,!0),!1)}else{const m=new j({vd:e.getDescription()}),c=m.getImpl();if(Ee(this.m_geometry,h)){const u=this.bufferConvexPath(r,h);i.add(u,!1)}else{this.bufferClosedPath(this.m_geometry,h,c,this.m_bRoundBuffer,1);const u=this.bufferCleanup(m);i.add(u,!1)}}else{if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const m=new j({vd:e.getDescription()}),c=m.getImpl();if(this.bufferClosedPath(this.m_geometry,h,c,this.m_bRoundBuffer,1),!m.isEmpty()){const u=l,_=Math.max(1,this.m_absDistance),d=u.clone();d.inflateCoords(_,_),c.addEnvelope(d,!1);const x=this.bufferCleanup(m);i.reserve(i.getPointCount()+x.getPointCount()-4),me(x,i,d,!0)}}else if(o>0){if(l.width()+this.m_tolerance.total()<=2*this.m_absDistance||l.height()+this.m_tolerance.total()<=2*this.m_absDistance)continue;const m=new j({vd:e.getDescription()}),c=m.getImpl();if(this.bufferClosedPath(this.m_geometry,h,c,this.m_bRoundBuffer,-1),!m.isEmpty()){const u=new G;c.queryLooseEnvelope(u);const _=Math.max(1,this.m_absDistance),d=u.clone();d.inflateCoords(_,_),c.addEnvelope(d,!1),me(this.bufferCleanup(m),i,d,!0)}}else{const m=new j({vd:e.getDescription()}),c=m.getImpl();this.bufferClosedPath(this.m_geometry,h,c,this.m_bRoundBuffer,-1);const u=this.bufferCleanup(m);for(let _=0,d=u.getPathCount();_<d;_++)i.addPath(u,_,!0)}}if(this.m_distance>0)return i.getPathCount()>1?this.bufferCleanup(i):ee(i);{const h=new G;if(i.queryLooseEnvelope(h),i.isEmpty())return ee(i);{const o=Math.max(1,this.m_absDistance),l=h.clone();l.inflateCoords(o,o),i.addEnvelope(l,!1);const m=this.bufferCleanup(i);i=new A;const c=new A({vd:m.getDescription()});return me(m,c,l,!1),ee(c)}}}bufferPoint(){return this.bufferPointImpl(this.m_geometry)}bufferPointImpl(e){const t=new A({vd:e.getDescription()});return this.m_caps===0?(this.addCircle(t.getImpl(),e),this.setStrongSimple(t)):this.m_caps===2?(this.addSquare(t.getImpl(),e),this.setStrongSimple(t)):t}bufferDegeneratePath(e,t){const s=new A({vd:e.getDescription()});return t&&this.m_joins===0||!t&&this.m_caps===0?(this.addCircle(s.getImpl(),e),this.setStrongSimple(s)):t||this.m_caps!==2?s:(this.addSquare(s.getImpl(),e),this.setStrongSimple(s))}bufferMultiPoint(){const e=new Xe(this,this.m_geometry,this.m_distance,this.m_spatialReference,this.m_joins,this.m_caps,this.m_miterLimit,this.m_densifyDist,this.m_maxVertexInCompleteCircle,this.m_progressTracker);return new ie().executeMany(e,this.m_spatialReference,this.m_progressTracker,2).next()}bufferEnvelope(){let e=new A({vd:this.m_geometry.getDescription()});if(this.m_distance<=0){if(this.m_distance===0)e.addEnvelope(this.m_geometry,!1),ge(this.m_geometry,this.m_tolerance.total())&&(e=this.setStrongSimple(e));else{const s=new ne;this.m_geometry.queryEnvelope(s),s.inflateCoords(this.m_distance,this.m_distance),e.addEnvelope(s,!1),ge(s,this.m_tolerance.total())&&(e=this.setStrongSimple(e))}return e}if(this.m_joins===1){const s=new ne({copy:this.m_geometry});return s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1),e}const t=this.m_geometry.clone();if(t.width()===0||t.height()===0){if(t.width()===0&&t.height()===0){const n=new J({vd:this.m_geometry.getDescription()});return t.queryCornerByVal(0,n),this.m_geometry=n,this.bufferImpl()}const s=new j({vd:this.m_geometry.getDescription()}),r=new J;return t.queryCornerByVal(0,r),s.startPathPoint(r),t.queryCornerByVal(2,r),s.lineToPoint(r),this.m_geometry=s,this.bufferImpl()}return e.addEnvelope(this.m_geometry,!1),this.m_geometry=e,this.bufferConvexPath(e,0)}bufferConvexPath(e,t){this.generateCircleTemplate();const s=e.hasAttribute(10),r=new A({vd:e.getDescription()}),n=r.getImpl();r.reserve((this.m_circleTemplate.length/10+4)*e.getPathSize(t));const i=new f,h=new f,o=new f,l=new f(0,0),m=new f,c=new f,u=e.getImpl(),_=e.getPathSize(t),d=e.getPathStart(t);for(let x=0,P=e.getPathSize(t);x<P;x++){const g=u.getXY(d+x),C=u.getXY(d+(x+1)%_),v=u.getXY(d+(x+2)%_);m.setSub(C,g),m.length()===0&&se("");const D=s&&!!(1&u.getAttributeAsInt(10,(x+1)%_,0));m.normalize();const b=m.clone();m.leftPerpendicularThis(),m.scale(this.m_absDistance),i.setAdd(m,g),h.setAdd(m,C),x===0?n.startPath(i):n.lineTo(i),n.lineTo(h),c.setSub(v,C),c.length()===0&&se(""),c.normalize();const V=c.clone();c.leftPerpendicularThis(),c.scale(this.m_absDistance),o.setAdd(c,C);let E=y.enumArc;const X=D?0:this.m_joins;if(X===2)E=y.enumBevel;else if(X===1){const H=-b.crossProduct(V);l.setSub(b,V),l.scale(this.m_absDistance/H),l.length()<this.m_miterLimit*this.m_absDistance?(l.addThis(C),E=y.enumMiter):E=y.enumBevel}else l.assign(C);this.addJoin(E,n,l,h,o,!1,!1)}return ee(r)}bufferPolylinePath(e,t,s){this.generateCircleTemplate();const r=e,n=r.getImpl();if(n.getPathSize(t)<1)return null;let i;if(i=this.m_bRoundBuffer?n.isClosedPathInXYPlane(t):n.isClosedPath(t),this.isDegeneratePath(n,t)&&this.m_distance>0){const l=new J;n.getPointByVal(n.getPathStart(t),l);const m=new G;return n.queryPathEnvelope(t,m),l.setXY(m.getCenter()),this.bufferDegeneratePath(l,i)}const h=new j({vd:e.getDescription()});h.reserve((Math.trunc(this.m_circleTemplate.length/10)+4)*n.getPathSize(t));const o=h.getImpl();return i?this.bufferClosedPath(r,t,o,s,1)!==2&&this.bufferClosedPath(r,t,o,s,-1):this.bufferOpenPath(r,t,o,s),this.bufferCleanup(h)}progress_(){}bufferCleanup(e,t=!1){const s=t?this.m_tolerance:this.m_smallTolerance;return Ye(e,s,!0,!t,-1,this.m_progressTracker,0,!1)}calcN(){if(this.m_densifyDist===0)return this.m_maxVertexInCompleteCircle;const e=1-this.m_densifyDist*Math.abs(this.m_absDistanceReversed);let t=4;return t=e<-1?4:2*Math.PI/Math.acos(e)+.5,t<4?t=4:t>this.m_maxVertexInCompleteCircle&&(t=this.m_maxVertexInCompleteCircle),Math.trunc(t)}addJoin(e,t,s,r,n,i,h){if(this.generateCircleTemplate(),i&&(t.startPath(r),i=!1),e===y.enumBevel)return void(h&&t.lineTo(n));if(e===y.enumMiter){const g=s.clone();return t.lineTo(g),void(h&&t.lineTo(n))}const o=new f;o.setSub(r,s),o.scale(this.m_absDistanceReversed);const l=new f;l.setSub(n,s),l.scale(this.m_absDistanceReversed);let m=Math.atan2(o.y,o.x)/this.m_dA;m<0&&(m=this.m_circleTemplate.length+m),m=this.m_circleTemplate.length-m;let c=Math.atan2(l.y,l.x)/this.m_dA;c<0&&(c=this.m_circleTemplate.length+c),c=this.m_circleTemplate.length-c,c<m&&(c+=this.m_circleTemplate.length);let u=Math.trunc(c),_=Math.ceil(m),d=this.m_circleTemplate[_%this.m_circleTemplate.length].clone();d.scaleAddThis(this.m_absDistance,s);const x=10*this.m_tolerance.total();d.sub(r).length()<x&&(_+=1),d=this.m_circleTemplate[u%this.m_circleTemplate.length].clone(),d.scaleAddThis(this.m_absDistance,s),d.sub(n).length()<x&&(u-=1);let P=u-_;P++;for(let g=0,C=_%this.m_circleTemplate.length;g<P;g++,C=(C+1)%this.m_circleTemplate.length)d=this.m_circleTemplate[C].clone(),d.scaleAddThis(this.m_absDistance,s),t.lineTo(d),this.progress_();h&&t.lineTo(n)}bufferClosedPath(e,t,s,r,n){const i=new re,h=i.addPathFromMultiPath(e,t,!0);return this.bufferClosedPathImpl(i,h,s,r,n)}bufferClosedPathImpl(e,t,s,r,n){const i=e.getFirstVertex(e.getFirstPath(t)),h=new J;if(e.queryPoint(i,h),e.filterClosePoints(this.m_filterTolerance,!1,!1,!1,-1),e.getPointCount(t)<2)return n<0?0:(this.m_bRoundBuffer&&this.addCircle(s,h),2);U(e.getFirstPath(t)!==K),U(e.getFirstVertex(e.getFirstPath(t))!==K);const o=e.getXY(e.getFirstVertex(e.getFirstPath(t))),l=new ae;if(l.setShift(o.negate()),e.applyTransformation(l),r){const T=Ge(e,t,n,!0,this.m_absDistance,this.m_filterTolerance,this.m_densifyDist);if(U(T===1),e.getPointCount(t)<2)return n<0?0:(this.addCircle(s,h),2)}const m=this.m_joins!==0&&e.getVertexDescription().hasAttribute(10);this.m_bufferCommands.length=0;const c=e.getFirstPath(t);let u=e.getFirstVertex(c),_=n===1?e.getPrevVertex(u):e.getNextVertex(u),d=n===1?e.getNextVertex(u):e.getPrevVertex(u),x=!0;const P=new f,g=new f,C=new f,v=new f,D=new f,b=new f,V=new f,E=new f,X=this.m_absDistance,H=e.getPathSize(c),q=new f(0,0);for(let T=0;T<H;T++){g.assign(e.getXY(d)),x&&(P.assign(e.getXY(u)),C.assign(e.getXY(_)),b.setSub(P,C),b.normalize(),E.leftPerpendicularOther(b),E.scale(X),v.setAdd(E,P));const p=m&&!!(1&e.getAttributeAsDbl(10,u,0));D.setSub(g,P),D.normalize(),V.leftPerpendicularOther(D),V.scale(X);const k=new f;k.setAdd(P,V);const L=b.crossProduct(D),w=b.dotProduct(D);if(L<0||w<0&&L<Math.abs(w)*Number.EPSILON*8){let B=!1;const F=p?0:this.m_joins;if(F===1){const Y=-L;q.setSub(b,D),q.scale(this.m_absDistance/Y),q.length()<this.m_miterLimit*this.m_absDistance&&(q.addThis(P),B=!0),this.m_bufferCommands.push(z(v,k,q,B?y.enumMiter:y.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(z(v,k,P,F===0?y.enumArc:y.enumBevel,this.m_bufferCommands.length+1))}else v.equals(k)||(this.m_bufferCommands.push(W(v,P,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(W(P,k,this.m_bufferCommands.length+1)));const M=new f;M.setAdd(g,V),this.m_bufferCommands.push(z(k,M,P,y.enumLine,this.m_bufferCommands.length+1)),v.setCoordsPoint2D(M),E.setCoordsPoint2D(V),C.setCoordsPoint2D(P),P.setCoordsPoint2D(g),b.setCoordsPoint2D(D),_=u,u=d,x=!1,d=n===1?e.getNextVertex(u):e.getPrevVertex(u)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),l.setShift(o),s.applyTransformationToPath(l,s.getPathCount()-1),1}bufferOpenPath(e,t,s,r){if(this.m_bRoundBuffer){const p=new j({vd:e.getDescription()});return p.addPath(e,t,!1),p.addSegmentsFromPath(e,t,0,e.getSegmentCountPath(t),!1),this.bufferClosedPath(p,0,s,r,1)}let n=0;const i=new j({vd:e.getDescription()}),h=new f(0,0);{const p=new re,k=p.addPathFromMultiPath(e,t,!1),L=p.getFirstVertex(p.getFirstPath(k)),w=new J;if(p.queryPoint(L,w),h.assign(w.getXY()),p.filterClosePoints(0,!1,!1,!1,-1),p.getPointCount(k)<2)return this.m_bRoundBuffer&&this.addCircle(s,w),2;const M=p.getGeometry(p.getFirstGeometry());i.addPath(M,0,!1),n=i.getPointCount()-1,i.addSegmentsFromPath(M,0,0,M.getSegmentCountPath(0)-1,!1)}const o=new re,l=o.addPathFromMultiPath(i,0,!0);U(o.getFirstPath(l)!==K),U(o.getFirstVertex(o.getFirstPath(l))!==K);const m=new ae;m.setShift(h.negate()),o.applyTransformation(m),this.m_bufferCommands.length=0;const c=o.getFirstPath(l),u=this.m_joins!==0&&o.getVertexDescription().hasAttribute(10);let _=o.getFirstVertex(c),d=o.getPrevVertex(_),x=o.getNextVertex(_),P=!0;const g=new f,C=new f,v=new f,D=new f,b=new f,V=new f,E=new f,X=new f,H=this.m_absDistance,q=o.getPathSize(c),T=new f(0,0);for(let p=0;p<q;p++){let k=!1;p!==0&&p!==n||(k=!0),C.assign(o.getXY(x)),P&&(g.assign(o.getXY(_)),v.assign(o.getXY(d)),V.setSub(g,v),V.normalize(),X.leftPerpendicularOther(V),X.scale(H),D.setAdd(X,g));const L=u&&!!(1&o.getAttributeAsDbl(10,_,0));b.setSub(C,g),b.normalize(),E.leftPerpendicularOther(b),E.scale(H);const w=new f;w.setAdd(g,E);const M=V.crossProduct(b),B=V.dotProduct(b);if(M<0||B<0&&M<Math.abs(B)*Number.EPSILON*8)if(k)if(this.m_caps===0)this.m_bufferCommands.push(z(D,w,g,y.enumArc,this.m_bufferCommands.length+1));else if(this.m_caps===1)this.m_bufferCommands.push(z(D,w,g,y.enumLine,this.m_bufferCommands.length+1));else{const Y=b.mul(this.m_absDistance).negate(),N=Y.clone();Y.addThis(D),N.addThis(w),this.m_bufferCommands.push(z(D,Y,g,y.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(z(Y,N,g,y.enumLine,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(z(N,w,g,y.enumLine,this.m_bufferCommands.length+1))}else{let Y=!1;const N=L?0:this.m_joins;if(N===1){const S=-M;T.setSub(V,b),T.scale(this.m_absDistance/S),T.length()<this.m_miterLimit*this.m_absDistance&&(T.addThis(g),Y=!0),this.m_bufferCommands.push(z(D,w,T,Y?y.enumMiter:y.enumBevel,this.m_bufferCommands.length+1))}else this.m_bufferCommands.push(z(D,w,g,N===0?y.enumArc:y.enumBevel,this.m_bufferCommands.length+1))}else D.equals(w)||(this.m_bufferCommands.push(W(D,g,this.m_bufferCommands.length+1)),this.m_bufferCommands.push(W(g,w,this.m_bufferCommands.length+1)));const F=new f;F.setAdd(C,E),this.m_bufferCommands.push(z(w,F,g,y.enumLine,this.m_bufferCommands.length+1)),D.setCoordsPoint2D(F),X.setCoordsPoint2D(E),v.setCoordsPoint2D(g),g.setCoordsPoint2D(C),V.setCoordsPoint2D(b),d=_,_=x,P=!1,x=o.getNextVertex(_)}return this.m_bufferCommands.at(-1).m_next=0,this.processBufferCommands(s),m.setShift(h),s.applyTransformationToPath(m,s.getPathCount()-1),1}processBufferCommands(e){const t=this.cleanupBufferCommands();let s=!0,r=t+1;for(let n=t;r!==t;n=r){const i=this.m_bufferCommands[n];r=i.m_next!==-1?i.m_next:(n+1)%this.m_bufferCommands.length,i.m_type&&(s&&(e.startPath(i.m_from),s=!1),i.m_type&y.enumJoinMask?this.addJoin(i.m_type,e,i.m_center,i.m_from,i.m_to,!1,!0):e.lineTo(i.m_to))}}cleanupBufferCommands(){this.m_helperArray=ce(f,9);let e=0;for(let s=0,r=this.m_bufferCommands.length;s<r;){const n=this.m_bufferCommands[s];if(n.m_type&y.enumConnectionMask){e=s;break}s=n.m_next}let t=e+1;for(let s=e;t!==e;s=t){const r=this.m_bufferCommands[s];t=r.m_next;let n=1,i=null;for(;t!==s&&(i=this.m_bufferCommands[t],!(i.m_type&y.enumConnectionMask));)t=i.m_next,n++;n!==1&&(r.m_type&i.m_type)===y.enumLine&&(this.m_helperLine1.setStartXY(r.m_from),this.m_helperLine1.setEndXY(r.m_to),this.m_helperLine2.setStartXY(i.m_from),this.m_helperLine2.setEndXY(i.m_to),this.m_helperLine1.intersect(this.m_helperLine2,this.m_helperArray,null,null,this.m_smallTolerance.total())===1&&(r.m_to.assign(this.m_helperArray[0]),i.m_from.assign(this.m_helperArray[0]),r.m_next=t))}return e}isDegeneratePath(e,t){if(e.getPathSize(t)===1)return!0;if(this.m_joins===0&&this.m_caps===0){const s=new G;if(e.queryPathEnvelope(t,s),Math.max(s.width(),s.height())<.5*this.m_densifyDist)return!0}return!1}isDegenerateGeometry(e){if(this.m_joins===0&&this.m_caps===0){const t=new G;if(e.queryEnvelope(t),Math.max(t.width(),t.height())<.5*this.m_densifyDist)return!0}return!1}addCircle(e,t){const s=t.getXY();if(this.m_circleTemplate.length!==0){let l=this.m_circleTemplate[0].clone();l.scaleAddThis(this.m_absDistance,s),e.startPath(l);for(let m=1,c=this.m_circleTemplate.length;m<c;m++)l=this.m_circleTemplate[m].clone(),l.scaleAddThis(this.m_absDistance,s),e.lineTo(l);return}const r=this.m_circleTemplateSize,n=Math.trunc((r+3)/4),i=.5*Math.PI/n;e.reserve(4*n);const h=Math.cos(i),o=Math.sin(i);for(let l=3;l>=0;l--){const m=f.construct(0,this.m_absDistance);switch(l){case 0:for(let c=0;c<n;c++)e.lineToCoords(m.x+s.x,m.y+s.y),m.rotateReverse(h,o);break;case 1:for(let c=0;c<n;c++)e.lineToCoords(-m.y+s.x,m.x+s.y),m.rotateReverse(h,o);break;case 2:for(let c=0;c<n;c++)e.lineToCoords(-m.x+s.x,-m.y+s.y),m.rotateReverse(h,o);break;default:e.startPathCoords(m.y+s.x,-m.x+s.y);for(let c=1;c<n;c++)m.rotateReverse(h,o),e.lineToCoords(m.y+s.x,-m.x+s.y)}this.progress_()}}addSquare(e,t){const s=new ne({vd:t.getDescription()});s.setCoords(t.getX(),t.getY(),t.getX(),t.getY()),s.inflateCoords(this.m_absDistance,this.m_absDistance),e.addEnvelope(s,!1)}setStrongSimple(e){return e.getImpl().setIsSimple(4,this.m_tolerance.total()),e.getImpl().updateOGCFlagsProtected(),e}}function ee(a){return de(a,0),a}function ge(a,e){return!!a.isEmpty()||Math.min(a.width(),a.height())>e}function ze(a,e,t,s,r,n,i,h){const o=a.getXY(t),l=a.getXY(s);if(o.equals(l))return-1;const m=.25*i,c=.25*i,u=new f;u.setSub(l,o);const _=u.length(),d=_*_*.25,x=n*n-d;if(x<=d)return-1;const P=Math.sqrt(x);u.normalize();const g=u.clone();g.rightPerpendicularThis();const C=d/P,v=C<=c,D=f.lerp(l,o,.5),b=g.clone(),V=C-m;b.scaleAddThis(Math.max(0,V),D),g.negate().scaleAddThis(P,D);const E=3.61*Me(n-c),X=b.sub(o),H=b.sub(l);let q=!1,T=0;const p=Ie(64,0);U(h===p.length);{for(let R=a.getPrevVertexEx(s,r);R!==t;){if(a.getUserIndex(R,e)===1)return-1;if(a.getXY(R).equals(l)){const O=a.getPrevVertexEx(R,r);a.removeVertex(R,!1),R=O;continue}break}const S=new f,I=o.clone();p[T++]=1;for(let R=a.getNextVertexEx(t,r);R!==s;){if(a.getUserIndex(R,e)===1)return-1;const O=a.getXY(R);if(O.equals(I)){const pe=a.getNextVertexEx(R,r);a.removeVertex(R,!1),R=pe;continue}p[T++]=0;const oe=new f;if(oe.setSub(O,o),oe.dotProduct(g)<0)return 0;(f.sqrDistance(O,o)>E||f.sqrDistance(O,l)>E)&&(q=!0);let Z=0;if(O.sub(o).crossProduct(X)>=0&&(Z=1),O.sub(l).crossProduct(H)<=0&&(Z|=2),Z===0)return 0;p[T-1]=Z,S.assign(I),I.assign(O),R=a.getNextVertexEx(R,r)}if(T===1)return 0;U(T<p.length),p[T++]=2}let k=!0;for(let S=1,I=0;S<T;S++)if(p[S]!==p[S-1]&&(I++,k=I<3&&(I===1&&p[S]===3||I===2&&p[S]===2),!k))return 0;if(T>2&&k&&(T===3||!q)){let S=0,I=a.getNextVertexEx(t,r);for(v||(a.setXY(I,b),I=a.getNextVertexEx(I,r));I!==s;){const R=a.getNextVertexEx(I,r);a.removeVertex(I,!1),I=R,++S}return S}if(U(T!==3),q&&T>3)return 0;const L=o.clone();let w=t;const M=o.clone();let B=1,F=-1,Y=w,N=0;for(T=1;Y!==s;){Y=a.getNextVertexEx(Y,r);const S=p[T++];if(S===0){if(Y===s)break;continue}const I=a.getXY(Y);if(F!==-1){if(3&(F&B&S)){a.removeVertex(w,!0),N++,w=Y,M.setCoordsPoint2D(I),B=S;continue}if(B===3&&F!==0&&S!==0){if(M.setCoordsPoint2D(b),v||M.equals(L)){a.removeVertex(w,!0),N++,w=Y,M.setCoordsPoint2D(I),B=S;continue}a.setXY(w,M)}}F=B,L.setCoordsPoint2D(M),w=Y,B=S,M.setCoordsPoint2D(I)}return N}function Le(a,e,t,s){let r=-1;const n=new f,i=new f,h=new f;for(let o=0,l=a.getPathSize(s),m=a.getFirstVertex(s);o<l;++o){r===-1&&(a.queryXY(m,i),r=a.getPrevVertex(m),r!==-1&&(a.queryXY(r,n),h.setSub(i,n),h.normalize()));const c=a.getNextVertex(m);if(c===-1)break;const u=a.getXY(c),_=u.sub(i);_.normalize(),r!==-1&&_.dotProduct(h)<-.99&&Math.abs(_.crossProduct(h))<1e-7&&a.setUserIndex(m,e,1),r=m,m=c,n.assign(i),i.assign(u),h.assign(_)}}function Ne(a,e,t,s,r,n,i){const h={stack:[],error:void 0,hasError:!1};try{const o=a.getFirstPath(e),l=a.createUserIndex();be(h,Se(()=>{a.removeUserIndex(l)},!1),!1),Le(a,l,e,o);for(let m=0;m<100;++m){if(a.getPathSize(o)===0)return 1;let c=a.getFirstVertex(o),u=a.getPathSize(o);if(u<3)return 1;a.isClosedPath(o)||(u-=1);const _=64;let d=0,x=!1;for(let P=0;P<u&&c!==K;P++){let g=0,C=c;for(let v=1,D=Math.min(_,u-P);v<D;v++)if(C=a.getNextVertexEx(C,t),v>1){const b=ze(a,l,c,C,t,r,i,_);if(b===-1)break;g+=b,u-=b}if(d+=g,x=g>0,x){const v=a.getPrevVertexEx(c,t);if(v!==-1){c=v,u++;continue}}c=a.getNextVertexEx(c,t)}if(d===0)break}return a.filterClosePoints(n,!1,!1,!1,-1),1}catch(o){h.error=o,h.hasError=!0}finally{Pe(h)}}function Ge(a,e,t,s,r,n,i){return Ne(a,e,t,s,r,n,i)}function me(a,e,t,s){for(let r=0,n=a.getPathCount();r<n;r++){const i=a.getXY(a.getPathStart(r));i.x!==t.xmin&&i.x!==t.xmax&&e.addPath(a,r,s)}}export{We as L};
