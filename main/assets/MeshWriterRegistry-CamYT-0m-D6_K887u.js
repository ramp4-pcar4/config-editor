import{aB as K,q as at,P as ct,l as lt,gj as P,kX as ht,a9 as X,am as Le,kL as ae,a2 as B,a8 as Ee,ac as ce,a5 as ut,a3 as De,bp as dt}from"./index-BeTPrQ6f.js";import{b as O}from"./labelPoint-DTWBMY-Z-DoXEvKTt.js";import{q as $}from"./rasterizingUtils-Cf1zdzIw-BfJyHaiy.js";import{C as ft,Q as pt,v as mt,I as gt,r as yt}from"./CIMSymbolHelper-C-M9oL19-BYnF76mM.js";import{N as U,a as C,Y as _t,X as xt,c as Pt,H as D,e as Mt}from"./definitions-DVO21zOC-BwakNu1s.js";import{Q as vt,e as bt,B as wt,R as St,K as kt,n as It,H as zt,O as Tt,I as At,a as Lt,q,F as Et,L as Dt,g as Bt,v as Rt,A as Ct,b as Ft,c as z,X as j,T as Yt,t as Ot,d as L,f as le}from"./TexturedLineMeshWriter-BCl73Ao0-B8_pfMVJ.js";import{c as Y,O as E}from"./UpdateTracking2D-CIKx7GWt-CEE8vGb9.js";import{r as Qe,f as Wt}from"./grouping-CrNPfBhl-Dqv5TxZv.js";import{_ as y}from"./enums-DDJfd4_p-D3z9tmVA.js";import{x as Nt,B as Gt,a as Xt}from"./constants-CWFGCPkc-B_3x8_48.js";import{P as $t,E as Ht}from"./TurboLine-CvWJ2xTB-C5q-5bd9.js";import{j as he,q as me,x as Vt,_ as Qt}from"./mat2d-Cf4xHr3Z-u09Kv-lR.js";import{u as G}from"./mat2df32-fg3OHsAI-BF2V2zqo.js";import{r as ee}from"./vec2f32-hTAvipMV-C0AQcwEv.js";import{o as W}from"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{q as Ut,u as Be}from"./featureConversionUtils-CZmIxyv5-DHwRSztU.js";import{c as ue}from"./OptimizedGeometry-BYxlP_oK-DvAqrgO1.js";import{r as Re}from"./BoundingBox-DlCd_wcU-DBB4UfPl.js";import{f as qt,g as Ce}from"./Utils-CYY0kXyb-BZKnUtTY.js";import{d as Ue}from"./utils-CIm5uQvO-CtKf129F.js";import{A as jt}from"./ArcadeExpression-BGPPS6z--7N6gsB31.js";import{x as Zt}from"./AttributeStore-DvLAcaW_-yhKHITeD.js";let Me=class{static getPlacement(i,e,t,r,o){const s=yt(t);return s?(e===-1&&i.invertY(),s.execute(i,t,r,o)):null}},qe=class extends j{};function Jt(i){const{sprite:e,isMapAligned:t,colorLocked:r,scaleSymbolsProportionally:o,isStroke:s}=i;let n=0;return t&&(n|=L(E.bitset.isMapAligned)),r&&(n|=L(E.bitset.colorLocked)),e.sdf&&(n|=L(E.bitset.isSDF)),o&&(n|=L(E.bitset.scaleSymbolsProportionally)),s&&(n|=L(E.bitset.isStroke)),n}function Z(i){return i instanceof J?i:typeof i=="object"&&"type"in i?ii[i.type].hydrate(i):new V(i)}let J=class{constructor(i){this.inputs=i}encode(){const i=[];for(const e of this.inputs)i.push(...e.encode());return i.push(...this.instructions),i}},V=class extends J{constructor(i){super([]),this.value=i}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[i,e,t,r]=this.value;return r!=null?Y.vector4.encode([i,e||0,t||0,r]):Y.vector3.encode([i,e||0,t||0])}return Y.scalar.encode(this.value)}},Kt=class ge extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ge(e,Z(e.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const e=this._parent.simplify();if(!(e instanceof V))return this;const[t,r,o,s]=e.value,n=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(n===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=o+c,p=s*l,d=Math.sin(o),f=Math.cos(o);return new V([f*s*n-d*s*a+t,d*s*n+f*s*a+r,h,p])}return new ge(this._config,e)}get instructions(){return Y.animatedTransform.encode(this._config)}},ei=class ye extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new ye(e,Z(e.parent))}simplify(){const e=this._parent.simplify();if(!(e instanceof V))return this;const[t,r,o,s]=e.value,n=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return n===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new V([t*n,r*a,o*c,s*l])):new ye(this._config,e)}get instructions(){return Y.animatedColor.encode(this._config)}},ti=class _e extends J{constructor(e,t){super([t]),this._config=e,this._parent=t}static hydrate(e){return new _e(e,Z(e.parent))}simplify(){const e=this._parent.simplify();return e instanceof V?new _e(this._config,e):this}get instructions(){return Y.animatedShift.encode(this._config)}};const ii={AnimatedTransform:Kt,AnimatedColor:ei,AnimatedShift:ti};function si(i){return je(i.map(e=>I(e)).map(e=>Z(e).simplify()))}function ri(i){const e=[];return e.push(i.transform),e.push(i.fromColor),e.push(i.toColor),e.push(i.colorMix),e.push(i.toOpacity),e.push(i.opacityMix),i!=null&&i.shift?e.push(i==null?void 0:i.shift):e.push([1,1,1,1]),e}function je(i){const e=[],t=[];let r=0;for(const o of i){const s=[...o.encode(),...Y.ret.encode()];e.push([r+i.length,0,0,0]),t.push(...s),r+=s.length}return[...e,...t]}async function xe(i,e){const t=i;let r;if(typeof t=="number"||typeof t=="string"||typeof t=="boolean")r=t;else if(Array.isArray(t))r=await Promise.all(t.map(o=>xe(o,e)));else if(typeof t=="object")if("valueExpressionInfo"in t){const{valueExpressionInfo:o}=t,{expression:s}=o;r={...t,computed:await e.createComputedField({expression:s})}}else{r={};for(const o in t)r[o]=await xe(t[o],e)}return r}function I(i,e,t){function r(n){if(!("computed"in n))return n;let a=n.computed.readWithDefault(e,t,[255*n.defaultValue[0],255*n.defaultValue[1],255*n.defaultValue[2],n.defaultValue[3]]);if(typeof a=="string"){const c=dt.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const o=i;let s;if(typeof o=="number"||typeof o=="string"||typeof o=="boolean")s=o;else if(Array.isArray(o))s=o.map(n=>I(n,e,t));else if(typeof o=="object")if("type"in o&&o.type!=null&&o.type==="Process")switch(o.op){case"ArcadeColor":{const n=I(o.value,e,t);Q(Array.isArray(n)&&n.length===4),s=[n[0]/255,n[1]/255,n[2]/255,n[3]]}break;case"Transparency":{const n=I(o.value,e,t);Q(typeof n=="number"),s=1-n/100}break;case"Divide":case"Multiply":case"Add":{const n=I(o.left,e,t);Q(typeof n=="number");const a=I(o.right,e,t);switch(Q(typeof a=="number"),o.op){case"Divide":s=n/a;break;case"Multiply":s=n*a;break;case"Add":s=n+a}}break;case"Random":{const n=I(o.seed,e,t),a=I(o.min,e,t),c=I(o.max,e,t),l=e.getObjectId(),h=Qe(l||0);s=a+Wt(h,n)*(c-a)}break;case"Cond":{const n=I(o.condition,e,t),a=I(o.ifTrue,e,t),c=I(o.ifFalse,e,t);s=n?a:c}break;case"MatchWinding":{const n=I(o.sign,e,t);let a=I(o.angle,e,t);if(n>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;s=a}}else if("computed"in o)s=r(o);else{s={};for(const n in o)s[n]=I(o[n],e,t)}return s}function*T(i){const e=i;if(Array.isArray(e))for(const t of e)yield*T(t);else if(typeof e=="object")if("type"in e&&e.type!=null&&e.type==="Process")switch(e.op){case"ArcadeColor":case"Transparency":yield*T(e.value);break;case"Divide":case"Multiply":case"Add":yield*T(e.left),yield*T(e.right);break;case"Random":yield*T(e.seed),yield*T(e.min),yield*T(e.max);break;case"Cond":yield*T(e.condition),yield*T(e.ifTrue),yield*T(e.ifFalse);break;case"MatchWinding":yield*T(e.sign),yield*T(e.angle)}else if("computed"in e)yield e.computed;else for(const t in e)yield*T(e[t])}function Q(i){if(!i)throw new Error("Assertion failed.")}const ve={type:y.SHORT,count:2,packPrecisionFactor:U,pack:({scaleInfo:i},{tileInfo:e})=>q(i,e)},oi={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:i})=>(Q(i),i)},Ze={type:y.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},ni={type:y.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},Je={type:y.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:i})=>i},ai={type:y.UNSIGNED_SHORT,count:1,packTessellation:({distance:i})=>i},ci={type:y.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:i,directionY:e})=>[i,e]},li={type:y.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:i,normalY:e})=>[i,e]},be={type:y.UNSIGNED_BYTE,count:3,pack:"id"},we={type:y.UNSIGNED_BYTE,count:1,pack:Jt},Se={type:y.SHORT,count:2,pack:"position",packPrecisionFactor:1},ke={marker:{type:y.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:i})=>[[-.5*i[0],-.5*i[1]],[.5*i[0],-.5*i[1]],[-.5*i[0],.5*i[1]],[.5*i[0],.5*i[1]]]}},line:{type:y.FLOAT,count:2,packTessellation:({extrusionOffsetX:i,extrusionOffsetY:e},{baseSize:t})=>[i*t/2,e*t/2]},fill:{type:y.FLOAT,count:2,packTessellation:()=>[0,0]}},hi={marker:{type:y.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:i,texXmin:e,texYmax:t,texYmin:r})=>[[e,r],[i,r],[e,t],[i,t]]}}},Ke={type:y.UNSIGNED_SHORT,count:4,pack:({sprite:i})=>{const{rect:e,width:t,height:r}=i,o=e.x+D,s=e.y+D;return[o+1,s+1,o+t-1,s+r-1]}},Ie={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:i,baseSize:e,referenceSize:t})=>[i.dataColumn,i.dataRow,e,t]},ze={type:y.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:i,pixelDimensions:e,baseSize:t,sprite:r,sizeRatio:o})=>{const s=Math.max(t*r.width/r.height,t),n=r.sdfDecodeCoeff*s*o;return[e[0],e[1],i,n]}},ui={type:y.BYTE,count:1,packTessellation:({angle:i})=>i};function Te(i){let{pixelDimensions:e,texelDimensions:t,baseSize:r,referenceSize:o,strokeWidth:s,sizeRatio:n}=i;if(e||(e=i.sprite.sdf?[0,0]:[i.sprite.width,i.sprite.height]),t||(t=i.sprite.sdf?[0,0]:e),i.patternHeight!=null){const c=i.patternHeight/e[1];e[1]*=c,e[0]*=c}r===-1&&(r=e[1]),r=P(r),o=P(o),s=P(s);const a=(i.sprite.sdfDecodeCoeff??1)*n;return{...i,pixelDimensions:e,texelDimensions:t,baseSize:r,referenceSize:o,strokeWidth:s,sdfDecodeCoeff:a}}const de=64,di=64,fi=2;let et=class extends qe{get vertexSpec(){return{createComputedParams:Te,optionalAttributes:{zoomRange:ve,value1Position2Value2:oi,lineLength:Je},attributes:{id:be,bitset:we,pos:Se,offset:ke.marker,uv:hi.marker,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze,angle:ui}}}_write(i,e,t){const r=this.evaluatedMeshParams.sprite,{textureBinding:o}=r;i.recordStart(this.instanceId,this.attributeLayout,o);const s=e.getDisplayId();if(this.shift&&e.geometryType==="esriGeometryPolyline"){if(!t){const n=O.fromFeatureSetReaderCIM(e);n&&this._writeParticles(i,e,n)}}else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(i,e);else if(e.geometryType==="esriGeometryPolygon"){const n=e.readCentroidForDisplay();if(!n)return;const[a,c]=n.coords;this._writeQuad(i,s,a,c)}else if(e.geometryType==="esriGeometryPoint"){const n=e.readXForDisplay(),a=e.readYForDisplay();this._writeQuad(i,s,n,a)}else{const n=e.readGeometryForDisplay();n&&n.forEachVertex((a,c)=>{this._writeQuad(i,s,a,c)})}i.recordEnd()}_writePlacedMarkers(i,e){var c;const t=(c=O.fromFeatureSetReaderCIM(e))==null?void 0:c.clone();if(!t)return;const r=-1,o=Me.getPlacement(t,r,this.evaluatedMeshParams.placement,P(1),i.id);if(!o)return;const s=e.getDisplayId();let n=o.next(),a=null;for(;n!=null;){const l=n.tx,h=-n.ty;if(Math.abs(l)>$||Math.abs(h)>$){n=o.next();continue}const p=-n.getAngle();i.recordBounds(l,h,de,di),this.shift?a&&this._writeQuad(i,s,a[0],a[1],void 0,p):this._writeQuad(i,s,l,h,void 0,p),a=[l,h],n=o.next()}}_writeParticles(i,e,t){const r=e.getDisplayId();for(;t.nextPath();){const o=[];for(;t.nextPoint();)o.push([t.x,t.y]);const s=pi(o);let n=0;for(let l=1;l<o.length;l++){const h=o[l][0]-o[l-1][0],p=o[l][1]-o[l-1][1],d=Math.sqrt(h*h+p*p);n+=d}const a=l=>{for(const h of s){const{a:p,b:d}=h;this._writeQuad(i,r,p.position[0],p.position[1],[p.distance-l,d.position[0],d.position[1],d.distance-l],this.evaluatedMeshParams.angleToLine?Math.atan2(p.direction[1],p.direction[0]):0,n,!0)}},{placement:c}=this.evaluatedMeshParams;if(!c||"placementTemplate"in c||c.type==="CIMMarkerPlacementOnVertices"){let l;if(c&&c.type!=="CIMMarkerPlacementOnVertices")l=c.placementTemplate;else{l=[0];for(const p of s){const{a:d,b:f}=p,u=d.position[0]-f.position[0],m=d.position[1]-f.position[1],g=Math.sqrt(u*u+m*m);l.push(g)}}let h=-1*n;for(;h<(1+fi/2)*n;)for(const p of l)h+=p,a(h)}else c.type==="CIMMarkerPlacementAtExtremities"?c.extremityPlacement==="JustBegin"?a(1):c.extremityPlacement==="JustEnd"?(a(n-1),a(-1)):c.extremityPlacement==="Both"&&(a(1),a(n-1)):c.type==="CIMMarkerPlacementOnLine"&&(c.relativeTo==="LineBeginning"?a(1):c.relativeTo==="LineEnd"?(a(n-1),a(-1)):c.relativeTo==="LineMiddle"&&a(n/2))}}_writeQuad(i,e,t,r,o,s=0,n=0,a=!1){const c=this.evaluatedMeshParams.sprite,{rect:l}=c,h=l.x+D,p=l.y+D,d=l.x+l.width-D,f=l.y+l.height-D,u=i.vertexCount();a||i.recordBounds(t,r,de,de);const m={texXmin:h,texYmin:p,texXmax:d,texYmax:f,value1Position2Value2:o,angle:s/Xt,lineLength:n};for(let g=0;g<4;g++)this._writeVertex(i,e,t,r,m);i.indexEnsureSize(6),i.indexWrite(u),i.indexWrite(u+1),i.indexWrite(u+2),i.indexWrite(u+1),i.indexWrite(u+3),i.indexWrite(u+2)}};function pi(i){const e=[];let t=0;for(let r=1;r<i.length;r++){const o=i[r-1],s=i[r],n=s[0]-o[0],a=s[1]-o[1],c=Math.sqrt(n*n+a*a),l=n/c,h=a/c;e.push({a:{position:o,distance:t,direction:[l,h]},b:{position:s,distance:t+c,direction:[l,h]}}),t+=c}return e}let mi=class extends et{constructor(){super(...arguments),this.shift=!1}},gi=class extends et{constructor(){super(...arguments),this.shift=!0}};class tt extends qe{_write(e,t,r){const o=r??O.fromFeatureSetReaderCIM(t);if(!o)return;const s=this.evaluatedMeshParams.sprite,{textureBinding:n}=s;e.recordStart(this.instanceId,this.attributeLayout,n);const a=t.getDisplayId();this._writePoly(e,a,o.asOptimized()),e.recordEnd()}}let yi=class extends tt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Te,attributes:{id:be,bitset:we,pos:Se,offset:ke.fill,tlbr:Ke,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze},optionalAttributes:{zoomRange:ve,value1Position2Value2:Ze,lineLength:ni}}}_writePoly(i,e,t){const r=this._clip(t);if(!r)return;t=r;const o=[],s=i.vertexCount();let n;if(Ct(o,t)){if(o.length===0)return;n=0;for(const a of o){const c=t.coords[2*a],l=t.coords[2*a+1];this._writeVertex(i,e,c,l),n++}}else{const{coords:a,lengths:c}=t,l=Ht(a,c);n=l.vertexCount;for(let h=0;h<l.buffer.length/2;h++){const p=l.buffer[2*h],d=l.buffer[2*h+1];this._writeVertex(i,e,p,d)}}if(n>0){i.indexEnsureSize(n);for(let a=0;a<n;a++)i.indexWrite(a+s)}}_clip(i){const e=this.hasEffects;return Ft(i,e?256:8)}},_i=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Fe=65535;let xi=class extends tt{constructor(){super(...arguments),this.vertexSpec={createComputedParams:Te,attributes:{id:be,bitset:we,pos:Se,offset:ke.line,tlbr:Ke,animationPointerAndBaseSizeAndReferenceSize:Ie,sizing:ze,accumulatedDistance:ai,normal:li,segmentDirection:ci},optionalAttributes:{zoomRange:ve,value1Position2Value2:Ze,lineLength:Je}},this._tessParams=new Et,this._currentWrite=new _i,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Fe,textured:!1},this._lineLength=0,this._lineTessellator=new $t((i,e,t,r,o,s,n,a,c,l,h)=>this._writeTesselatedVertex(i,e,t,r,o,s,n,a,c,l,h,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(i,e,t){const r=Dt(O.fromOptimized(t,"esriGeometryPolyline"),64);if(r==null)return;const{_currentWrite:o,_tessellationOptions:s}=this,{baseSize:n,capType:a,joinType:c,miterLimit:l}=this.evaluatedMeshParams,h=P(.5*n);s.halfWidth=h,s.capType=Bt(a||"Round"),s.joinType=Rt(c||"Round"),s.miterLimit=l||2,o.out=i,o.id=e,o.vertexCount=0,o.indexCount=0,o.vertexFrom=i.vertexCount(),o.vertexBounds=1;for(const{line:p,start:d,pathLength:f}of r){s.initialDistance=d%Fe,o.pathLength=f,this._lineLength=0;for(let u=1;u<p.length;u++){const m=p[u].x-p[u-1].x,g=p[u].y-p[u-1].y;this._lineLength+=Math.sqrt(m*m+g*g)}this._lineTessellator.tessellate(p,s,!1)}}_writeTesselatedVertex(i,e,t,r,o,s,n,a,c,l,h,p){const{out:d,id:f,vertexBounds:u,pathLength:m}=this._currentWrite;return this.hasEffects&&d.recordBounds(i,e,u,u),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=o,this._tessParams.directionY=s,this._tessParams.distance=h,this._tessParams.pathLength=m,this._tessParams.lineLength=p,this._writeVertex(d,f,i,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(i,e,t){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(i),r.indexWrite(e),r.indexWrite(t),this._currentWrite.indexCount+=3}};const Pi={createComputedParams:i=>i,optionalAttributes:{},attributes:{id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:y.FLOAT,count:1,packTessellation:({inverseArea:i})=>i}}};let Mi=class extends Ot{constructor(){super(...arguments),this.vertexSpec=Pi}createTesselationParams(i){return{inverseArea:1/i.readGeometryArea()}}};const vi={createComputedParams:i=>i,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1},offset:{type:y.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let bi=class extends j{constructor(){super(...arguments),this.vertexSpec=vi}_write(i,e){var r;i.recordStart(this.instanceId,this.attributeLayout);const t=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const o=e.readXForDisplay(),s=e.readYForDisplay();this._writeQuad(i,t,o,s)}else e.geometryType==="esriGeometryMultipoint"&&((r=e.readGeometryForDisplay())==null||r.forEachVertex((o,s)=>{o>=0&&o<=512&&s>=0&&s<=512&&this._writeQuad(i,t,o,s)}));i.recordEnd()}_writeQuad(i,e,t,r){const o=i.vertexCount();this._writeVertex(i,e,t,r),i.indexWrite(o+0),i.indexWrite(o+1),i.indexWrite(o+2),i.indexWrite(o+1),i.indexWrite(o+3),i.indexWrite(o+2)}};function Ye(i,e,t){return i[0]=e[0]-t[0],i[1]=e[1]-t[1],i}function it(i,e){return Math.sqrt(i*i+e*e)}function Oe(i){const e=it(i[0],i[1]);i[0]/=e,i[1]/=e}function wi(i,e){return it(i[0]-e[0],i[1]-e[1])}function Si(i,e){return i[e+1]}function st(i){return i.length-1}function ki(i){let e=0;for(let t=0;t<st(i);t++)e+=Ii(i,t);return e}function Ii(i,e,t=1){let[r,o]=Si(i,e);return[r,o]=[Math.round(r),Math.round(o)],Math.sqrt(r*r+o*o)*t}class re{constructor(e,t,r,o,s){this._segments=e,this._index=t,this._distance=r,this._xStart=o,this._yStart=s,this._done=!1}static create(e){return new re(e,0,0,e[0][0],e[0][1])}clone(){return new re(this._segments,this._index,this._distance,this.xStart,this.yStart)}equals(e){return this._index===e._index||e._index===this._index-1&&(this._distance===0||e._distance===1)||e._index===this._index+1&&(this._distance===1||e._distance===0)}leq(e){return this._index<e._index||this._index===e._index&&this._distance<=e._distance}geq(e){return this._index>e._index||this._index===e._index&&this._distance>=e._distance}get _segment(){return this._segments[this._index+1]}get angle(){const e=this.dy,t=(0*e+-1*-this.dx)/(1*this.length);let r=Math.acos(t);return e>0&&(r=2*Math.PI-r),r}get xStart(){return this._xStart}get yStart(){return this._yStart}get x(){return this.xStart+this.distance*this.dx}get y(){return this.yStart+this.distance*this.dy}get dx(){return this._segment[0]}get dy(){return this._segment[1]}get xMidpoint(){return this.xStart+.5*this.dx}get yMidpoint(){return this.yStart+.5*this.dy}get xEnd(){return this.xStart+this.dx}get yEnd(){return this.yStart+this.dy}get length(){const{dx:e,dy:t}=this;return Math.sqrt(e*e+t*t)}get remainingLength(){return this.length*(1-this._distance)}get backwardLength(){return this.length*this._distance}get distance(){return this._distance}get done(){return this._done}hasPrev(){return this._index-1>=0}hasNext(){return this._index+1<st(this._segments)}next(){return this.hasNext()?(this._xStart+=this.dx,this._yStart+=this.dy,this._distance=0,this._index+=1,this):null}prev(){return this.hasPrev()?(this._index-=1,this._xStart-=this.dx,this._yStart-=this.dy,this._distance=1,this):(this._done=!0,null)}_seekBackwards(e,t){const r=this.backwardLength;if(e<=r)return this._distance=(r-e)/this.length,this;let o=this.backwardLength;for(;this.prev();){if(o+this.length>e)return this._seekBackwards(e-o);o+=this.length}return this._distance=0,t?this:null}seek(e,t=!1){if(e<0)return this._seekBackwards(Math.abs(e),t);if(e<=this.remainingLength)return this._distance=(this.backwardLength+e)/this.length,this;let r=this.remainingLength;for(;this.next();){if(r+this.length>e)return this.seek(e-r,t);r+=this.length}return this._distance=1,t?this:null}}function fe(i,e,t,r=!0){const o=ki(i),s=re.create(i),n=o/2;if(!r)return s.seek(n),void(s.x<C&&s.y<C&&s.x>=0&&s.y>=0&&t(s.clone(),0,n+0*e,o));const a=Math.max((o-e)/2,0),c=Math.floor(a/e),l=n-c*e;s.seek(l);for(let h=-c;h<=c;h++)s.x<C&&s.y<C&&s.x>=0&&s.y>=0&&t(s.clone(),h,n+h*e,o),s.seek(e)}function pe(i,e){const t=e;for(let r=0;r<i.length;r++){let o=i[r];zi(o,t);const s=[];s.push(o[0]);for(let n=1;n<o.length;n++){const[a,c]=o[n-1],[l,h]=o[n],p=l-a,d=h-c;s.push([p,d])}i[r]=s,o=s}return i}function zi(i,e){if(e<=0)return;const t=i.length;if(t<3)return;const r=[];let o=0;r.push(0);for(let h=1;h<t;h++)o+=wi(i[h],i[h-1]),r.push(o);e=Math.min(e,.2*o);const s=[];s.push(i[0][0]),s.push(i[0][1]);const n=i[t-1][0],a=i[t-1][1],c=Ye([0,0],i[0],i[1]);Oe(c),i[0][0]+=e*c[0],i[0][1]+=e*c[1],Ye(c,i[t-1],i[t-2]),Oe(c),i[t-1][0]+=e*c[0],i[t-1][1]+=e*c[1];for(let h=1;h<t;h++)r[h]+=e;r[t-1]+=e;const l=.5*e;for(let h=1;h<t-1;h++){let p=0,d=0,f=0;for(let u=h-1;u>=0&&!(r[u+1]<r[h]-l);u--){const m=l+r[u+1]-r[h],g=r[u+1]-r[u],_=r[h]-r[u]<l?1:m/g;if(Math.abs(_)<1e-6)break;const M=_*_,b=_*m-.5*M*g,x=_*g/e,v=i[u+1],S=i[u][0]-v[0],w=i[u][1]-v[1];p+=x/b*(v[0]*_*m+.5*M*(m*S-g*v[0])-M*_*g*S/3),d+=x/b*(v[1]*_*m+.5*M*(m*w-g*v[1])-M*_*g*w/3),f+=x}for(let u=h+1;u<t&&!(r[u-1]>r[h]+l);u++){const m=l-r[u-1]+r[h],g=r[u]-r[u-1],_=r[u]-r[h]<l?1:m/g;if(Math.abs(_)<1e-6)break;const M=_*_,b=_*m-.5*M*g,x=_*g/e,v=i[u-1],S=i[u][0]-v[0],w=i[u][1]-v[1];p+=x/b*(v[0]*_*m+.5*M*(m*S-g*v[0])-M*_*g*S/3),d+=x/b*(v[1]*_*m+.5*M*(m*w-g*v[1])-M*_*g*w/3),f+=x}s.push(p/f),s.push(d/f)}s.push(n),s.push(a);for(let h=0,p=0;h<t;h++)i[h][0]=s[p++],i[h][1]=s[p++]}const We=96;class Ti{constructor(e){const{offsetX:t,offsetY:r,postAngle:o,fontSize:s,haloSize:n,outlineSize:a,scaleFactor:c,transforms:l}=e;if(this.offsetX=t,this.offsetY=r,this.postAngle=o,this.fontSize=Math.min(s,We),this.haloSize=n??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=Ue(s,o,!1,t,r,l,!1);this.fontSize=Math.min(h.size,We);const p=h.size/s;this.haloSize*=p,this.outlineSize*=p,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const H=28,F=[4,4],te=[16,4],Ai={topLeft:te,topRight:te,bottomLeft:te,bottomRight:te},oe=[4,2],A=[4,6],Ne={topLeft:oe,topRight:oe,bottomLeft:A,bottomRight:A},Ge={topLeft:oe,topRight:A,bottomLeft:oe,bottomRight:A},Li={topLeft:A,topRight:A,bottomLeft:F,bottomRight:F},Ei={topLeft:F,topRight:F,bottomLeft:A,bottomRight:A},Di={topLeft:A,topRight:F,bottomLeft:A,bottomRight:F},Bi={topLeft:F,topRight:A,bottomLeft:F,bottomRight:A},Ri={createComputedParams:i=>i,optionalAttributes:{zoomRange:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:U,packTessellation:({minZoom:i,maxZoom:e})=>[i||0,e||H]},clipAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:i})=>Ci(i||0)},referenceSymbol:{type:y.BYTE,count:4,packPrecisionFactor:1,packTessellation:(i,e)=>{const t=i.isLineLabel||!i.referenceBounds,r=mt(t?"center":e.horizontalAlignment),o=gt(t?"middle":e.verticalAlignment),{offsetX:s,offsetY:n,size:a}=t?{offsetX:0,offsetY:0,size:0}:i.referenceBounds;return[P(s),-P(n),Math.round(P(a)),r+1<<2|o+1]}},visibility:{type:y.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:i,mapAligned:e})=>Yt([[Nt,i],[Gt,!!e]])},offset:{type:y.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:i})=>{const{bottomLeft:e,bottomRight:t,topLeft:r,topRight:o}=i;return[r,o,e,t]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:i})=>{const{bottomLeft:e,bottomRight:t,topLeft:r,topRight:o}=i;return[r,o,e,t]}}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:i})=>i},fontAndReferenceSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:i},{referenceSize:e})=>[Math.round(P(i)),Math.round(P(e??i))]},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:i})=>z(i)},haloColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:i})=>z(i)},outlineAndHaloSize:{type:y.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:i,haloSize:e})=>[Math.round(P(i)),Math.round(P(e))]}}};class rt extends j{constructor(){super(...arguments),this.vertexSpec=Ri,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,t,r){super.ensurePacked(e,t,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Ti(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,t,r){var c;const o=this._getShaping();if(!o)return;const s=t.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,t,o,r);if(r!=null&&r.nextPath())return r.nextPoint(),this._writeGlyphs(e,s,r.x,r.y,o,0);if(t.geometryType==="esriGeometryPolygon"){const l=t.readCentroidForDisplay();if(!l)return;const[h,p]=l.coords;return this._writeGlyphs(e,s,h,p,o,0)}if(t.geometryType==="esriGeometryMultipoint")return void((c=t.readGeometryForDisplay())==null?void 0:c.forEachVertex((l,h)=>this._writeGlyphs(e,s,l,h,o,0)));const n=t.readXForDisplay(),a=t.readYForDisplay();return this._writeGlyphs(e,s,n,a,o,0)}_writePlacedTextMarkers(e,t,r,o){const s=o??O.fromFeatureSetReaderCIM(t);if(!s)return;const n=-1,a=Me.getPlacement(s,n,this.evaluatedMeshParams.placement,P(1),e.id);if(!a)return;const c=t.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,p=-l.ty,d=-l.getAngle();this._writeGlyphs(e,c,h,p,r,d),l=a.next()}}_getShaping(e){var l;const t=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!((l=r.glyphs)!=null&&l.glyphs.length))return null;const o=P(t.fontSize),s=P(t.offsetX),n=P(t.offsetY),a=Le(P(r.lineWidth),xt,_t),c=Pt*Le(r.lineHeightRatio,.25,4);return ft(r.glyphs,{scale:o/Mt,angle:t.postAngle,xOffset:s,yOffset:n,horizontalAlignment:r.horizontalAlignment,verticalAlignment:e||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:P(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(e,t,r,o,s,n,a,c,l=!0){const h=this.evaluatedMeshParams,p=this._textMeshTransformProps,d=P(p.fontSize),f=p.haloSize,u=p.outlineSize,m=P(p.offsetX),g=P(p.offsetY),[_,M]=q(h.scaleInfo,this.getTileInfo());n!==0&&s.setRotation(n);const b=s.bounds,x=r+b.x+m,v=o+b.y-g,S=2*(h.minPixelBuffer?h.minPixelBuffer/d:1),w=Math.max(b.width,b.height)*S;s.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,s.glyphs[0].textureBinding),l&&e.recordBounds(x,v,w,w),this._writeTextBox(e,t,r,o,s.textBox,a,c),e.recordEnd());for(const k of s.glyphs){e.recordStart(this.instanceId,this.attributeLayout,k.textureBinding),l&&e.recordBounds(x,v,w,w);const{texcoords:R,offsets:nt}=k;this._writeQuad(e,t,r,o,{texcoords:R,offsets:nt,fontSize:d,haloSize:f,outlineSize:u,color:z(h.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:M,...c}),e.recordEnd()}n!==0&&s.setRotation(-n)}_writeTextBox(e,t,r,o,s,n,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:d,boxBorderLineColor:f}=c,u={isBackground:!0,fontSize:l,haloSize:h,outlineSize:p,referenceBounds:n,...a};d&&(this._writeQuad(e,t,r,o,{texcoords:Ai,offsets:s.main,color:z(d),...u}),f||(this._writeQuad(e,t,r,o,{texcoords:Li,offsets:s.top,color:z(d),...u}),this._writeQuad(e,t,r,o,{texcoords:Ei,offsets:s.bot,color:z(d),...u}),this._writeQuad(e,t,r,o,{texcoords:Di,offsets:s.left,color:z(d),...u}),this._writeQuad(e,t,r,o,{texcoords:Bi,offsets:s.right,color:z(d),...u}))),f&&(this._writeQuad(e,t,r,o,{texcoords:Ne,offsets:s.top,color:z(f),...u}),this._writeQuad(e,t,r,o,{texcoords:Ne,offsets:s.bot,color:z(f),...u}),this._writeQuad(e,t,r,o,{texcoords:Ge,offsets:s.left,color:z(f),...u}),this._writeQuad(e,t,r,o,{texcoords:Ge,offsets:s.right,color:z(f),...u}))}_writeQuad(e,t,r,o,s){const n=e.vertexCount();this._writeVertex(e,t,r,o,s),e.indexWrite(n+0),e.indexWrite(n+1),e.indexWrite(n+2),e.indexWrite(n+1),e.indexWrite(n+3),e.indexWrite(n+2)}}const Ci=i=>Math.round(i*(254/360)),ie=1,N=0,Fi=128;function Yi(i,e,t){return ae(`${i}${e}${t}`)}function Oi(i,e,t,r,o){return ae(`${i}${e}${t}${r*2**(H-o)}`)}function Wi(i,e,t){return ae(`${i}${e}${t}`)}function Ni(i,e,t,r,o){return ae(`${i}${o}${e}${t*2**(H-r)}`)}const Gi=ht(i=>{let e=0;if(i===0)return 1/0;for(;!(i%2);)e++,i/=2;return e});class Xi extends rt{constructor(){super(...arguments),this._zoomLevel=0}_write(e,t,r,o){if(this._zoomLevel=o||0,r!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(t.geometryType){case"esriGeometryPoint":{const s=t.readXForDisplay(),n=t.readYForDisplay();this._writePoint(e,s,n,0,t);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const s=t.readCentroidForDisplay();if(!s)return;const[n,a]=s.coords;this._writePoint(e,n,a,0,t);break}case"esriGeometryMultipoint":{let s=0;const n=O.fromFeatureSetReader(t);if(n!=null&&n.nextPath())for(;n.nextPoint();)this._writePoint(e,n.x,n.y,s++,t);break}case"esriGeometryPolyline":this._writeLines(e,t)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:t}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,t==="middle"?0:t==="bottom"?-1:1]}_createLineLabelMetric(e,t,r,o,s,n){var d,f;const[a,c]=this._getMetricDir(),l=((d=this.evaluatedMeshParams.scaleInfo)==null?void 0:d.maxScale)??0,h=((f=this.evaluatedMeshParams.scaleInfo)==null?void 0:f.minScale)??0,p=this.evaluatedMeshParams.labelClassId;return new Ce(e,p,t,r,o,s,a,c,l,h,n)}_writePoint(e,t,r,o,s){var g,_;if(t<0||t>C||r<0||r>C)return;const n=this._getShaping();if(!n)return;const a=s.getDisplayId(),c=this.evaluatedMeshParams.labelClassId,l=Yi(this.evaluatedMeshParams.layerId,s.getObjectId(),o),h=Wi(s.getObjectId(),c,o),[p,d]=this._getMetricDir(),f=((g=this.evaluatedMeshParams.scaleInfo)==null?void 0:g.maxScale)??0,u=((_=this.evaluatedMeshParams.scaleInfo)==null?void 0:_.minScale)??0,m=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new Ce(a,c,l,h,t,r,p,d,f,u,m)),this._writeGlyphs(e,a,t,r,n,0,m,void 0,!1),e.metricBoxWrite(n.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const t=e.getBoundsInfo();if(t)return t}return null}_writeLines(e,t){const{scaleInfo:r,verticalAlignment:o}=this.evaluatedMeshParams,s=this.evaluatedMeshParams.repeatLabelDistance||128,n=this._getShaping("middle");if(!n)return;const a=(l,h,p,d)=>this._placeSubdivGlyphs(l,h,p,d),c=(n.bounds.width+s)/(1<<ie);this._current={out:e,id:t.getDisplayId(),objId:t.getObjectId(),shaping:n,zoomRange:q(r,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=o==="bottom"?"above":o==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(t,a,c):this._writeCenterAlong(t,a,c)}_writeAboveAndBelowAlong(e,t,r){const{repeatLabel:o}=this.evaluatedMeshParams,{shaping:s}=this._current,n=s.bounds.halfHeight,a=e.readGeometryForDisplay();if(!a)return;const c=new ue;Ut(c,a,!1,!1,"esriGeometryPolyline",1);const l=Xe(new ue,c,n),h=Xe(new ue,c,-n),p=Be(h,"esriGeometryPolyline",!1,!1),d=Be(l,"esriGeometryPolyline",!1,!1),f=pe(d.paths,s.bounds.width),u=pe(p.paths,s.bounds.width);this._current.offsetDirection="above";for(let m=0;m<f.length;m++)this._current.pathIndex=m,fe(f[m],r,t,!!o);this._current.offsetDirection="below";for(let m=0;m<u.length;m++)this._current.pathIndex=m,fe(u[m],r,t,!!o)}_writeCenterAlong(e,t,r){const{repeatLabel:o}=this.evaluatedMeshParams,{shaping:s}=this._current,n=pe(e.readLegacyGeometryForDisplay().paths,s.bounds.width);for(let a=0;a<n.length;a++)this._current.pathIndex=a,fe(n[a],r,t,!!o)}_placeSubdivGlyphs(e,t,r,o){const{allowOverrun:s,labelPosition:n,repeatLabelDistance:a,layerId:c,labelClassId:l}=this.evaluatedMeshParams,{objId:h,shaping:p,pathIndex:d}=this._current,f=this._current.zoomRange[0],u=Gi(t),m=this._current.shaping.bounds.width/(1<<ie),g=Math.sqrt(a||Fi)/(1<<ie),_=Math.min(r,o-r),M=p.isMultiline?H:Math.log2(_/(g+m/2)),b=t===0?M:Math.min(u,M),x=Math.max(f,this._zoomLevel+ie-b),v=this._zoomLevel-x,S=p.bounds.width/2*2**v,w=Oi(c,h,d,t,this._zoomLevel),k=Ni(h,d,t,this._zoomLevel,l);this._current.shaping.isMultiline?t===0&&this._placeStraight(e,x,w,k):s&&v<0?this._placeStraightAlong(e,f,w,k):n==="parallel"?this._placeStraightAlong(e,x,w,k):n==="curved"&&this._placeCurved(e,x,S,w,k)}_placeStraight(e,t,r,o){const{out:s,id:n,shaping:a,referenceBounds:c}=this._current,{x:l,y:h}=e;s.metricStart(this._createLineLabelMetric(n,r,o,l,h)),s.metricBoxWrite(a.boundsT);const p=e.angle*(180/Math.PI)%360,d=(e.angle*(180/Math.PI)+180)%360;if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const f={clipAngle:p,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,h,a,0,c,f,!1)}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const f={clipAngle:d,mapAligned:!0,isLineLabel:!0,minZoom:t};this._writeGlyphs(s,n,l,h,a,0,c,f,!1)}s.metricEnd()}_placeCurved(e,t,r,o,s){const{out:n,id:a}=this._current;n.metricStart(this._createLineLabelMetric(a,o,s,e.x,e.y));const c=e.clone(),l=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(c,t,1,l),this._placeBack(e,c,t,r,1,l),this._placeForward(e,c,t,r,1,l)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(c,t,0,h),this._placeBack(e,c,t,r,0,h),this._placeForward(e,c,t,r,0,h)),n.metricEnd()}_placeStraightAlong(e,t,r,o){const{out:s,id:n,shaping:a,zoomRange:c,referenceBounds:l}=this._current,{boxBorderLineColor:h,boxBackgroundColor:p}=this.evaluatedMeshParams,d=e.clone(),f=e.angle*(180/Math.PI)%360,u=(e.angle*(180/Math.PI)+180)%360,m=a.glyphs.length>0&&!(!h&&!p);if(s.metricStart(this._createLineLabelMetric(n,r,o,e.x,e.y)),m){const g=Math.max(t,c[0],0),_=Math.min(H,c[1]),M=he(G(),-e.angle),b={minZoom:g,maxZoom:_,clipAngle:f,mapAligned:!0,isLineLabel:!0},x=P(this.evaluatedMeshParams.offsetX),v=P(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const S=ee(x,-1*v),[w,k]=a.shapeBackground(me(G(),M,S));s.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,k,l,b),s.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const S=ee(x,v),[w,k]=a.shapeBackground(me(G(),M,S));b.clipAngle=u,s.recordStart(this.instanceId,this.attributeLayout,a.glyphs[0].textureBinding),this._writeTextBox(s,n,e.x,e.y,k,l,b),s.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(d,t,1,f,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(d,t,0,u,!0),s.metricEnd()}_placeBack(e,t,r,o,s,n){const a=e.clone();let c=e.backwardLength+N;for(;a.prev()&&!(c>=o);)this._placeOnSegment(a,t,c,r,-1,s,n),c+=a.length+N}_placeForward(e,t,r,o,s,n){const a=e.clone();let c=e.remainingLength+N;for(;a.next()&&!(c>=o);)this._placeOnSegment(a,t,c,r,1,s,n),c+=a.length+N}_placeFirst(e,t,r,o,s=!1){const{out:n,id:a,shaping:c,zoomRange:l,referenceBounds:h}=this._current,p=c.glyphs,d=P(this.evaluatedMeshParams.offsetX),f=P(this.evaluatedMeshParams.offsetY),u=ee(d,f),m=he(G(),-e.angle);X(u,u,m);for(const g of p){const _=g.x>c.bounds.x?r:1-r,M=_*e.remainingLength+(1-_)*e.backwardLength,b=Math.abs(g.x+g.width/2-c.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(b/(M+N))),v=Math.max(t,s?0:x);if(g.maxZoom=Math.min(l[1],H),g.angle=e.angle+(1-r)*Math.PI,g.minZoom=Math.max(l[0],v),this._writeLineGlyph(n,a,e.x,e.y,g,o,h,!0),(r||this._current.offsetDirection)&&this._isVisible(g.minZoom,g.maxZoom)){const S=new Re(g.bounds.x+u[0],g.bounds.y+u[1],g.bounds.width,g.bounds.height);n.metricBoxWrite(S)}}}_placeOnSegment(e,t,r,o,s,n,a){const{out:c,id:l,shaping:h,referenceBounds:p}=this._current,d=h.glyphs,f=e.dx/e.length,u=e.dy/e.length,m={x:e.x+r*-s*f,y:e.y+r*-s*u},g=P(this.evaluatedMeshParams.offsetX),_=P(this.evaluatedMeshParams.offsetY),M=ee(g,_),b=he(G(),-e.angle);X(M,M,b);for(const x of d){const v=x.x>h.bounds.x?n:1-n;if(!(v&&s===1||!v&&s===-1))continue;const S=Math.abs(x.x+x.width/2-h.bounds.x),w=Math.max(0,this._zoomLevel+Math.log2(S/r)-.1),k=Math.max(o,this._zoomLevel+Math.log2(S/(r+e.length+N)));if(w!==0&&(x.angle=e.angle+(1-n)*Math.PI,x.minZoom=k,x.maxZoom=w,this._writeLineGlyph(c,l,m.x,m.y,x,a,p,!0),(n||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const R=new Re(x.bounds.x+M[0],x.bounds.y+M[1],x.bounds.width,x.bounds.height);c.metricBoxWrite(R)}}}_writeLineGlyph(e,t,r,o,s,n,a,c){if(r<0||r>C||o<0||o>C)return;e.recordStart(this.instanceId,this.attributeLayout,s.textureBinding);const{texcoords:l,offsets:h}=s,{fontSize:p,haloSize:d,outlineSize:f}=this._textMeshTransformProps;this._writeQuad(e,t,r,o,{texcoords:l,offsets:h,fontSize:p,haloSize:d,outlineSize:f,color:z(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:a,minZoom:Math.max(this._current.zoomRange[0],s.minZoom),maxZoom:Math.min(this._current.zoomRange[1],s.maxZoom),clipAngle:n,mapAligned:c,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*U)/U}_isVisible(e,t){let r=Math.max(this._current.zoomRange[0],e),o=Math.min(this._current.zoomRange[1],t);r=this._packedZoom(r),o=this._packedZoom(o);const s=this._packedZoom(this._zoomLevel);return r<=s&&s<=o}}function Xe(i,e,t){const{coords:r,lengths:o}=e,s=W(),n=W(),a=W(),c=W(),l=W(),h=W(),p=2;let d=0;for(let f=0;f<o.length;f++){const u=o[f];for(let m=0;m<u;m++){const g=p*(m+d-1),_=p*(m+d),M=p*(m+d+1);m>0?B(s,r[g],r[g+1]):B(s,0,0),B(n,r[_],r[_+1]),m<u-1?B(a,r[M],r[M+1]):B(a,0,0),m===0?B(c,0,0):(Ee(c,n,s),ce(c,c),B(c,c[1],-c[0])),m===u-1?B(l,0,0):(Ee(l,a,n),ce(l,l),B(l,l[1],-l[0])),ut(h,c,l),ce(h,h);const b=h[0]*l[0]+h[1]*l[1];b!==0&&De(h,h,b),De(h,h,t),i.coords.push(n[0]+h[0],n[1]+h[1])}i.lengths.push(u),d+=u}return i}let $i=class Pe{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const t=new Pe(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:r,width:o,height:s,angle:n,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:p}=e;return t.rawWidth=P(o),t.rawHeight=P(s),t.angle=n,t.alignment=a,t.outlineSize=P(c),t.referenceSize=P(l),t.overrideOutlineColor=p,t.offsetX=P(e.offsetX),t.offsetY=P(e.offsetY),r!=="simple"||h.sdf||(t.rawWidth=h.width,t.rawHeight=h.height),t._computeSize(e,!1),t}static fromComplexMeshParams(e){const t=new Pe(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:r,transforms:o,size:s,scaleX:n,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:p,widthRatio:d,offsetX:f,offsetY:u,outlineSize:m,referenceSize:g,scaleFactor:_,sizeRatio:M,isAbsoluteAnchorPoint:b,rotateClockwise:x,scaleSymbolsProportionally:v,sprite:S}=e;if(o&&o.infos.length>0){const R=Ue(s,l,x,f,u,o);s=R.size,l=R.rotation,f=R.offsetX,u=R.offsetY,x=!1}_&&(s*=_,f*=_,u*=_);const w=n*(S.width/S.height);t.alignment=r,t.rawHeight=P(s),t.rawWidth=t.rawHeight*w,t.referenceSize=P(g),t.sizeRatio=M,t.sdfDecodeCoeff=(S.sdfDecodeCoeff??1)*M,t.angle=l,t.rotateClockwise=x,t.anchorX=a,t.anchorY=c,t.offsetX=P(f),t.offsetY=P(u),b&&s&&(S.sdf?t.anchorX=a/(s*d):t.anchorX=a/(s*w),t.anchorY=c/s);const k=v&&p?s/p:1;return t.outlineSize=m===0||isNaN(m)?0:P(m)*k,t.scaleSymbolsProportionally=v,t.colorLocked=h,t._computeSize(e,!0),t}constructor(e,t,r,o,s,n,a){this.sprite=e,this.color=t,this.outlineColor=r,this.minPixelBuffer=o,this.placement=s,this.scaleInfo=n,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=0,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,t){const{sprite:r,hasSizeVV:o}=e,s=!!r.sdf,n=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,p=r.rect;let d=a*l,f=c*l,u=0,m=0;if(s){const x=1/(1-n);if(d*=x,f*=x,o)this.computedWidth=d,this.computedHeight=f;else{const v=t&&a>c?d:a,S=c,w=h+2;this.computedWidth=Math.min(v+w,d),this.computedHeight=Math.min(S+w,f);const k=Math.max(r.width,r.height)/Math.max(d,f);u=(this.computedWidth-d)*k,m=(this.computedHeight-f)*k}}else this.computedWidth=d*(p.width/r.width),this.computedHeight=f*(p.height/r.height),u=2*D,m=2*D;const g=p.x+D-u/2,_=p.y+D-m/2,M=g+r.width+u,b=_+r.height+m;this.texXmin=$e(g),this.texYmin=$e(_),this.texXmax=He(M),this.texYmax=He(b),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(b-_),this.anchorX*=d/this.computedWidth,this.anchorY*=f/this.computedHeight}};function $e(i,e=1e-7){const t=Math.ceil(i);return t-i<e?t:Math.floor(i)}function He(i,e=1e-7){const t=Math.floor(i);return i-t<e?t:Math.ceil(i)}const Hi=3.14159265359/180,Vi=128/Math.PI;function Qi(i,e){return i%=e,Math.abs(i>=0?i:i+e)}function Ui(i){return Qi(i*Vi,256)}function qi(i,e,t,r,o=!1){const s=G(),n=o?1:-1;return Vt(s),(e||t)&&me(s,s,[e,-t]),r&&Qt(s,s,n*Hi*-r),s}const ji={createComputedParams:i=>$i.from(i),optionalAttributes:{zoomRange:{type:y.SHORT,count:2,packPrecisionFactor:U,pack:({scaleInfo:i},{tileInfo:e})=>q(i,e)}},attributes:{pos:{type:y.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:({sprite:i,alignment:e,scaleSymbolsProportionally:t,overrideOutlineColor:r,colorLocked:o})=>{let s=0;return i.sdf&&(s|=L(E.bitset.isSDF)),e===1&&(s|=L(E.bitset.isMapAligned)),t&&(s|=L(E.bitset.scaleSymbolsProportionally)),r&&(s|=L(E.bitset.overrideOutlineColor)),o&&(s|=L(E.bitset.colorLocked)),s}},offset:{type:y.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:i,computedWidth:e,computedHeight:t,anchorX:r,anchorY:o,offsetX:s,offsetY:n,rotateClockwise:a})=>{const c=qi(0,s,n,-i,a),l=-(.5+r)*e,h=-(.5-o)*t,p=[l,h],d=[l+e,h],f=[l,h+t],u=[l+e,h+t];return X(p,p,c),X(d,d,c),X(f,f,c),X(u,u,c),[p,d,f,u]}}},textureUV:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:i,texXmin:e,texYmax:t,texYmin:r})=>[[e,r],[i,r],[e,t],[i,t]]}},color:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:i})=>z(i)},outlineColor:{type:y.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:i})=>z(i)},sizing:{type:y.UNSIGNED_BYTE,count:4,pack:({rawWidth:i,rawHeight:e,outlineSize:t,referenceSize:r})=>{const o=Math.max(i,e);return[le(o,128),le(t,128),le(r,128),0]}},placementAngle:{type:y.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:i})=>Ui(i)},sdfDecodeCoeff:{type:y.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:i})=>i}}};let Zi=class extends j{constructor(){super(...arguments),this.vertexSpec=ji}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(i,e,t){var d,f;const r=(d=this.evaluatedMeshParams.sprite)==null?void 0:d.textureBinding,o=e.getDisplayId();i.recordStart(this.instanceId,this.attributeLayout,r);const s=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(this.evaluatedMeshParams.computedWidth,s),a=Math.max(this.evaluatedMeshParams.computedHeight,s),c=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,h=this.evaluatedMeshParams.offsetX+c,p=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null){let u=null;if(t!=null){const m=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(u=pt(t,2*m,!1),u===null)return}this._writePlacedMarkers(i,e,u,n,a)}else if(t!=null&&t.nextPath()){t.nextPoint();const u=t.x,m=t.y;i.recordBounds(u+h,m+p,n,a),this._writeQuad(i,o,u,m)}else if(e.geometryType==="esriGeometryPolygon"){const u=e.readCentroidForDisplay();if(!u)return;const[m,g]=u.coords;i.recordBounds(m+h,g+p,n,a),this._writeQuad(i,o,m,g)}else if(e.geometryType==="esriGeometryPoint"){const u=e.readXForDisplay(),m=e.readYForDisplay();i.recordBounds(u+h,m+p,n,a),this._writeQuad(i,o,u,m)}else(f=e.readGeometryForDisplay())==null||f.forEachVertex((u,m)=>{i.recordBounds(u+h,m+p,n,a),Math.abs(u)>$||Math.abs(m)>$||this._writeQuad(i,o,u,m)});i.recordEnd()}_writePlacedMarkers(i,e,t,r,o){const s=t??O.fromFeatureSetReaderCIM(e);if(!s)return;const n=-1,a=Me.getPlacement(s,n,this.evaluatedMeshParams.placement,P(1),i.id);if(!a)return;const c=e.getDisplayId();let l=a.next();const h=this.evaluatedMeshParams.offsetX,p=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const d=l.tx,f=-l.ty;if(Math.abs(d)>$||Math.abs(f)>$){l=a.next();continue}const u=-l.getAngle();i.recordBounds(d+h,f+p,r,o),this._writeQuad(i,c,d,f,u),l=a.next()}}_writeQuad(i,e,t,r,o){const s=i.vertexCount(),n=o==null?null:{placementAngle:o};this._writeVertex(i,e,t,r,n),i.indexWrite(s+0),i.indexWrite(s+1),i.indexWrite(s+2),i.indexWrite(s+1),i.indexWrite(s+3),i.indexWrite(s+2)}};class Ji extends Zt{constructor(e){super(),this._value=e}resize(e){}read(e,t){return this._value}readWithDefault(e,t,r){return this._value}hasArcadeDependency(e){return!1}}const Ki=()=>ct.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function se(i,e,t,r){const{defaultValue:o,valueExpressionInfo:s,value:n}=e;if(s){if(s.type==="dictionary-template")return{...e,computed:i.createDictionaryTemplateField(s,t),defaultValue:o};const{expression:a}=s,c=await i.createComputedField({expression:a},r);return c?{...e,computed:c,defaultValue:o}:null}return{...e,computed:new Ji(n),defaultValue:o}}async function Ve(i,e,t){const{valueExpressionInfo:r}=e,o=r.type==="dictionary-template"?i.createDictionaryTemplateField(r,t):await i.createComputedField({expression:r.expression});return o?{...e,computed:o}:null}function ot(i){return typeof i=="object"&&i!=null&&(!(!("valueExpressionInfo"in i)||!i.valueExpressionInfo)||"type"in i&&i.type==="Process"&&"op"in i&&i.op==="Random")}function ne(i){if(Array.isArray(i)){for(const e of i)if(ne(e))return!0}if(typeof i=="object"){if(ot(i))return!0;for(const e in i)if(ne(i[e]))return!0}return!1}class Ae{static async create(e,t,r,o){const s={},n=new Map,a=new Map,c=new Map,l=new Map,h=new Map,p=new Map;for(const d in r){const f=r[d];if(f!=null&&typeof f=="object")if(Array.isArray(f)){if(typeof f[0]=="object")throw new Error(`InternalError: Cannot handle ${d}. Nested array params are not supported`);s[d]=f}else{if("valueExpressionInfo"in f){if(f.value){s[d]=f.value;continue}const u=await Ve(e,f,o);if(!u){s[d]=f.defaultValue;continue}n.set(d,u),s[d]=null;continue}switch(f.type){case"cim-effect-infos":if(f.effectInfos.some(u=>u.overrides.length)){a.set(d,{effects:await Promise.all(f.effectInfos.map(async u=>{const m=u.overrides.map(g=>se(e,g,o,!1));return{effect:u.effect,compiledOverrides:(await Promise.all(m)).filter(K)}}))});break}s[d]=f.effectInfos.map(u=>u.effect);break;case"cim-marker-placement-param":f.overrides.length&&c.set(d,{placementInfo:f,compiledOverrides:(await Promise.all(f.overrides.map(u=>se(e,u,o,!1)))).filter(K)}),s[d]=f.placement;break;case"text-rasterization-param":{if(f.overrides.length){const m=f.overrides.map(g=>se(e,g,o,f.useLegacyLabelEvaluationRules??!1));l.set(d,{compiledOverrides:(await Promise.all(m)).filter(K),rasterizationParam:f,objectIdToResourceId:new Map});continue}const u={type:"cim-rasterization-info",resource:f.resource};s[d]=await t.fetchResourceImmediate(u)??null;break}case"sprite-rasterization-param":{if(f.overrides.length){const m=f.overrides.map(g=>se(e,g,o,!1));l.set(d,{compiledOverrides:(await Promise.all(m)).filter(K),rasterizationParam:f,objectIdToResourceId:new Map});continue}if(f.resource.type==="animated"){l.set(d,{compiledOverrides:[],rasterizationParam:f,objectIdToResourceId:new Map});continue}const u={type:"cim-rasterization-info",resource:f.resource};s[d]=await t.fetchResourceImmediate(u)??null;break}case"cim-marker-transform-param":{const{params:u}=f;if(ne(u)){const m={compiledMarkerInfos:[]};await Promise.all(u.map(async g=>{const _={props:{}};for(const M in g)if(ot(g[M])){const b=await Ve(e,g[M],o);_.compiledExpressionMap||(_.compiledExpressionMap=new Map);const x=_.compiledExpressionMap;b&&x.set(M,b)}else _.props[M]=g[M];m.compiledMarkerInfos.push(_)})),h.set(d,m)}else s[d]={type:"cim-marker-transform-info",infos:u};break}case"animation-params":{const{params:u}=f,m=ri(u);if(ne(m)){const g=await Promise.all(m.map(_=>xe(_,e)));p.set(d,{params:g,propertyIdToResourceId:new Map,key:d})}else{const g=si(m),_=await t.fetchResourceImmediate({type:"animation-info",resource:g});_!=null&&_.type==="sprite"&&(s[d]={dataRow:_.rect.y,dataColumn:_.rect.x})}break}default:s[d]=f}}else s[d]=f}return new Ae(r,s,n,a,c,l,h,p)}constructor(e,t,r,o,s,n,a,c){this.inputMeshParams=e,this._resolvedMeshParams=t,this._dynamicProperties=r,this._dynamicEffectProperties=o,this._dynamicPlacementProperties=s,this._dynamicAsyncProperties=n,this._dynamicTransformProperties=a,this._dynamicAsyncAnimations=c,this.evaluator=l=>l,this._arcadeDependencies=new Set;for(const l of this._expressions())jt(this._arcadeDependencies,l)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,t,r){for(const o of this._dynamicAsyncProperties.values()){const s=at(o.rasterizationParam.resource);o.rasterizationParam.resource.type==="animated"&&o.rasterizationParam.resource.randomizeStartTime&&(s.primitiveName="__RESERVED__PRIMITIVE__NAME__",s.startGroup=Qe(t.getObjectId()||0));for(const{primitiveName:a,propertyName:c,computed:l,defaultValue:h,valueExpressionInfo:p}of o.compiledOverrides)try{const d=o.rasterizationParam.resource.type==="animated"?s.primitiveName:a;qt(s,d,c,l,t,r,h)}catch(d){Ki().errorOnce(new lt("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:d,valueExpressionInfo:p}))}const n=e.enqueueRequest({type:"cim-rasterization-info",resource:s});o.objectIdToResourceId.set(t.getObjectId(),n)}for(const o of this._dynamicAsyncAnimations.values()){const s=o.params.map(c=>I(c,t,r)).map(Z).map(c=>c.simplify()),n=je(s),a=e.enqueueRequest({type:"animation-info",resource:n});o.propertyIdToResourceId.set(t.getObjectId()+"."+o.key,a)}}evaluateMeshParams(e,t,r){for(const[o,s]of this._dynamicProperties.entries())this._resolvedMeshParams[o]=s.computed.readWithDefault(t,r,s.defaultValue);for(const[o,s]of this._dynamicPlacementProperties.entries())for(const{computed:n,defaultValue:a,propertyName:c}of s.compiledOverrides){const l=n.readWithDefault(t,r,a);s.placementInfo.placement[c]=l,this._resolvedMeshParams[o]=s.placementInfo.placement}for(const[o,s]of this._dynamicEffectProperties.entries())for(const n of s.effects){for(const{computed:a,defaultValue:c,propertyName:l}of n.compiledOverrides){const h=a.readWithDefault(t,r,c);n.effect[l]=h}this._resolvedMeshParams[o]=s.effects.map(a=>a.effect)}for(const[o,s]of this._dynamicTransformProperties.entries()){const n={type:"cim-marker-transform-info",infos:[]};for(const a of s.compiledMarkerInfos){const c={...a.props};if(a.compiledExpressionMap)for(const[l,h]of a.compiledExpressionMap){const p=h.computed.readWithDefault(t,r,h.defaultValue);c[l]=typeof p=="number"||typeof p=="boolean"?p:h.defaultValue}n.infos.push(c)}this._resolvedMeshParams[o]=n}for(const[o,s]of this._dynamicAsyncProperties.entries()){const n=s.objectIdToResourceId.get(t.getObjectId());if(n==null)continue;const a=e.getResource(n);this._resolvedMeshParams[o]=a}for(const[o,s]of this._dynamicAsyncAnimations.entries()){const n=s.propertyIdToResourceId.get(t.getObjectId()+"."+o);if(n==null)continue;const a=e.getResource(n);this._resolvedMeshParams[o]={dataRow:a.rect.y,dataColumn:a.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const t of e.effects)for(const r of t.compiledOverrides)yield r.computed;for(const e of this._dynamicPlacementProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicAsyncProperties.values())for(const t of e.compiledOverrides)yield t.computed;for(const e of this._dynamicTransformProperties.values())for(const t of e.compiledMarkerInfos)if(t.compiledExpressionMap!=null)for(const r of t.compiledExpressionMap.values())yield r.computed;for(const e of this._dynamicAsyncAnimations.values())for(const t of e.params)yield*T(t)}}const es={createComputedParams:i=>i,optionalAttributes:{},attributes:{pos:{type:y.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:y.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:y.UNSIGNED_BYTE,count:1,pack:i=>0},offset:{type:y.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:i})=>{const e=P(i),t=-e/2,r=-e/2;return[[t,r],[t+e,r],[t,r+e],[t+e,r+e]]}}},texCoords:{type:y.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:y.UNSIGNED_BYTE,count:2,pack:({size:i})=>[i,i]},referenceSize:{type:y.UNSIGNED_BYTE,count:1,pack:({size:i})=>P(i)},zoomRange:{type:y.UNSIGNED_BYTE,count:2,pack:({scaleInfo:i},{tileInfo:e})=>q(i,e)}}};class ts extends j{constructor(){super(...arguments),this.vertexSpec=es}_write(e,t){const r=t.getDisplayId(),o=this.evaluatedMeshParams.minPixelBuffer,s=Math.max(P(this.evaluatedMeshParams.size),o);let n,a;if(t.geometryType==="esriGeometryPoint")n=t.readXForDisplay(),a=t.readYForDisplay();else{const l=t.readCentroidForDisplay();if(!l)return;n=l==null?void 0:l.coords[0],a=l==null?void 0:l.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(n,a,s,s);const c=e.vertexCount();this._writeVertex(e,r,n,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}class ws{async createMeshWriter(e,t,r,o,s){const n=this._getMeshWriter(o.techniqueType),a=await Ae.create(e,t,o.inputParams,s),c=new n(o.id,a,o.optionalAttributes,r);return await c.loadDependencies(),c}_getMeshWriter(e){switch(e){case 13:return Lt;case 11:return Mi;case 9:return At;case 26:return Tt;case 14:return zt;case 24:return It;case 27:return kt;case 10:return St;case 21:return Zi;case 28:return ts;case 30:return rt;case 19:return wt;case 31:return bt;case 15:return vt;case 17:return bi;case 18:return Xi;case 2:return mi;case 3:return gi;case 0:return yi;case 1:return xi;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{Ji as r,ws as s};
