import{aa as J,aM as Y,f8 as G,aI as H,f9 as U,aj as ee,ar as te,x as se,fa as ie,ba as oe,fb as re,ax as j,A as le,cT as ne,c as he,V as X,aw as ae,aR as ce,fc as W,m as k,E as b,n as ue}from"./index-BeTPrQ6f.js";import{s as q}from"./TileKey-BZu7Ia24-BiyRHU0x.js";import{r as fe}from"./Queue-CK6TduSr-C-T211SM.js";import{o as N}from"./ReactiveMap-cp6PWICM-990o5_5b.js";import{o as de}from"./signal-DHxLvooI-Bin-tnuW.js";import{m as _e}from"./Query-DKLDaFaA-I4zhlfzt.js";import{y as ge}from"./arcadeUtils-BkvNBhzm-KzAaTYHA.js";function R(s,e){return[s,e]}function M(s,e,t){return s[0]=e,s[1]=t,s}function me(s,e,t,i,o){return s[0]=e,s[1]=t,s[2]=i,s[3]=o,s}const I=new q("0/0/0/0");let pe=class Z{static create(e,t,i=null){const o=J(e.spatialReference),r=t.origin||R(e.origin.x,e.origin.y),n=R(e.size[0]*t.resolution,e.size[1]*t.resolution),l=R(-1/0,-1/0),a=R(1/0,1/0),h=R(1/0,1/0);i!=null&&(M(l,Math.max(0,Math.floor((i.xmin-r[0])/n[0])),Math.max(0,Math.floor((r[1]-i.ymax)/n[1]))),M(a,Math.max(0,Math.floor((i.xmax-r[0])/n[0])),Math.max(0,Math.floor((r[1]-i.ymin)/n[1]))),M(h,a[0]-l[0]+1,a[1]-l[1]+1));const{cols:c,rows:f}=t;let _,y,g,v;return!i&&c&&f&&(M(l,c[0],f[0]),M(a,c[1],f[1]),M(h,c[1]-c[0]+1,f[1]-f[0]+1)),e.isWrappable?(_=R(Math.ceil(Math.round((o.valid[1]-o.valid[0])/t.resolution)/e.size[0]),h[1]),y=!0,g=o.origin,v=o.valid):(_=h,y=!1),new Z(t.level,t.resolution,t.scale,r,l,a,h,n,_,y,g,v)}constructor(e,t,i,o,r,n,l,a,h,c,f,_){this.level=e,this.resolution=t,this.scale=i,this.origin=o,this.first=r,this.last=n,this.size=l,this.norm=a,this.worldSize=h,this.wrap=c,this._spatialReferenceOrigin=f,this._spatialReferenceValid=_}normalizeCol(e){if(!this.wrap)return e;const t=this.worldSize[0];return e<0?t-1-Math.abs((e+1)%t):e%t}normalizeKey(e){if(!this.wrap)return;const t=this.worldSize[0],i=e.col;i<0?(e.col=i+t,e.world-=1):i>=t&&(e.col=i-t,e.world+=1)}denormalizeCol(e,t){return this.wrap?this.worldSize[0]*t+e:e}getWorldForColumn(e){return this.wrap?Math.floor(e/this.worldSize[0]):0}getFirstColumnForWorld(e){return e*this.worldSize[0]+this.first[0]}getLastColumnForWorld(e){return e*this.worldSize[0]+this.first[0]+this.size[0]-1}getColumnForX(e){return(e-this.origin[0])/this.norm[0]}getXForColumn(e){const t=this.origin[0]+e*this.norm[0],i=this._spatialReferenceOrigin,o=this._spatialReferenceValid;return this.wrap&&i&&o?t===i[0]?o[0]:this.origin[0]===i[0]&&e===this.worldSize[0]?o[1]:t:t}getRowForY(e){return(this.origin[1]-e)/this.norm[1]}getYForRow(e){return this.origin[1]-e*this.norm[1]}getTileBounds(e,t,i=!1){I.set(t);const o=i?I.col:this.denormalizeCol(I.col,I.world),r=I.row;return me(e,this.getXForColumn(o),this.getYForRow(r+1),this.getXForColumn(o+1),this.getYForRow(r)),e}getTileCoords(e,t,i=!1){I.set(t);const o=i?I.col:this.denormalizeCol(I.col,I.world);return Array.isArray(e)?M(e,this.getXForColumn(o),this.getYForRow(I.row)):(e.x=this.getXForColumn(o),e.y=this.getYForRow(I.row)),e}};const A=class A{constructor(){this.spans=[]}acquire(e){this.lodInfo=e}release(){this.lodInfo=null,this.spans.length=0}*keys(){const e=this.lodInfo;for(const{row:t,colFrom:i,colTo:o}of this.spans)for(let r=i;r<=o;r++){const n=e.getWorldForColumn(r);yield new q(e.level,t,e.normalizeCol(r),n)}}forEach(e,t){const{spans:i,lodInfo:o}=this,{level:r}=o;if(i.length!==0)for(const{row:n,colFrom:l,colTo:a}of i)for(let h=l;h<=a;h++)e.call(t,r,n,o.normalizeCol(h),o.getWorldForColumn(h))}};A.pool=new U(()=>new A);let V=A,O=class{constructor(s,e,t){this.row=s,this.colFrom=e,this.colTo=t}};const d=new q("0/0/0/0");class K{static create(e,t){e[1]>t[1]&&([e,t]=[t,e]);const[i,o]=e,[r,n]=t,l=r-i,a=n-o,h=a!==0?l/a:0,c=(Math.ceil(o)-o)*h,f=(Math.floor(o)-o)*h;return new K(i,Math.floor(o),Math.ceil(n),h,l<0?c:f,l<0?f:c,l<0?r:i,l<0?i:r)}constructor(e,t,i,o,r,n,l,a){this.x=e,this.ymin=t,this.ymax=i,this.invM=o,this.leftAdjust=r,this.rightAdjust=n,this.leftBound=l,this.rightBound=a}incrRow(){this.x+=this.invM}getLeftCol(){return Math.max(this.x+this.leftAdjust,this.leftBound)}getRightCol(){return Math.min(this.x+this.rightAdjust,this.rightBound)}}const w=[[0,0],[0,0],[0,0],[0,0]],ye=1e-6;let Me=class{constructor(s,e=null,t=s.lods[0].level,i=s.lods[s.lods.length-1].level){this.tileInfo=s,this.fullExtent=e,this.scales=[],this._infoByScale={},this._infoByLevel={};const o=s.lods.filter(n=>n.level>=t&&n.level<=i);this.minScale=o[0].scale,this.maxScale=o[o.length-1].scale;const r=this._lodInfos=o.map(n=>pe.create(s,n,e));o.forEach((n,l)=>{this._infoByLevel[n.level]=r[l],this._infoByScale[n.scale]=r[l],this.scales[l]=n.scale},this),this._wrap=s.isWrappable}get spatialReference(){return this.tileInfo.spatialReference}getLODInfoAt(s){return this._infoByLevel[typeof s=="number"?s:s.level]}getTileBounds(s,e,t=!1){d.set(e);const i=this._infoByLevel[d.level];return i?i.getTileBounds(s,d,t):s}getTileCoords(s,e,t=!1){d.set(e);const i=this._infoByLevel[d.level];return i?i.getTileCoords(s,d,t):s}getTileCoverage(s,e=192,t=!0,i="closest"){if(!t&&(s.scale>this.minScale||s.scale<this.maxScale))return null;const o=i==="closest"?this.getClosestInfoForScale(s.scale):this.getSmallestInfoForScale(s.scale),r=V.pool.acquire(o),n=this._wrap;let l,a,h,c=1/0,f=-1/0;const _=r.spans;w[0][0]=w[0][1]=w[1][1]=w[3][0]=-e,w[1][0]=w[2][0]=s.size[0]+e,w[2][1]=w[3][1]=s.size[1]+e;for(const u of w)s.toMap(u,u),u[0]=o.getColumnForX(u[0]),u[1]=o.getRowForY(u[1]);const y=[];let g=3;for(let u=0;u<4;u++){if(w[u][1]===w[g][1]){g=u;continue}const m=K.create(w[u],w[g]);c=Math.min(m.ymin,c),f=Math.max(m.ymax,f),y[m.ymin]===void 0&&(y[m.ymin]=[]),y[m.ymin].push(m),g=u}if(c==null||f==null||f-c>100)return null;let v=[];for(l=c;l<f;){y[l]!=null&&(v=v.concat(y[l])),a=1/0,h=-1/0;for(let u=v.length-1;u>=0;u--){const m=v[u];a=Math.min(a,m.getLeftCol()),h=Math.max(h,m.getRightCol())}if(a=Math.floor(a),h=Math.floor(h),l>=o.first[1]&&l<=o.last[1])if(n)if(o.size[0]<o.worldSize[0]){const u=Math.floor(h/o.worldSize[0]);for(let m=Math.floor(a/o.worldSize[0]);m<=u;m++)_.push(new O(l,Math.max(o.getFirstColumnForWorld(m),a),Math.min(o.getLastColumnForWorld(m),h)))}else _.push(new O(l,a,h));else a>o.last[0]||h<o.first[0]||(a=Math.max(a,o.first[0]),h=Math.min(h,o.last[0]),_.push(new O(l,a,h)));l+=1;for(let u=v.length-1;u>=0;u--){const m=v[u];m.ymax>=l?m.incrRow():v.splice(u,1)}}return r}getTileParentId(s){d.set(s);const e=this._infoByLevel[d.level],t=this._lodInfos.indexOf(e)-1;return t<0?null:(this._getTileIdAtLOD(d,this._lodInfos[t],d),d.id)}getTileResolution(s){const e=this._infoByLevel[typeof s=="object"?s.level:s];return e?e.resolution:-1}getTileScale(s){const e=this._infoByLevel[s.level];return e?e.scale:-1}intersects(s,e){d.set(e);const t=this._infoByLevel[d.level],i=s.lodInfo;if(i.resolution>t.resolution){this._getTileIdAtLOD(d,i,d);const r=i.denormalizeCol(d.col,d.world);for(const n of s.spans)if(n.row===d.row&&n.colFrom<=r&&n.colTo>=r)return!0}if(i.resolution<t.resolution){const[r,n,l,a]=s.spans.reduce((g,v)=>(g[0]=Math.min(g[0],v.row),g[1]=Math.max(g[1],v.row),g[2]=Math.min(g[2],v.colFrom),g[3]=Math.max(g[3],v.colTo),g),[1/0,-1/0,1/0,-1/0]),h=t.denormalizeCol(d.col,d.world),c=i.getColumnForX(t.getXForColumn(h)),f=i.getRowForY(t.getYForRow(d.row)),_=i.getColumnForX(t.getXForColumn(h+1))-1,y=i.getRowForY(t.getYForRow(d.row+1))-1;return!(c>a||_<l||f>n||y<r)}const o=i.denormalizeCol(d.col,d.world);return s.spans.some(r=>r.row===d.row&&r.colFrom<=o&&r.colTo>=o)}normalizeBounds(s,e,t){if(s[0]=e[0],s[1]=e[1],s[2]=e[2],s[3]=e[3],this._wrap){const i=J(this.tileInfo.spatialReference),o=-t*(i.valid[1]-i.valid[0]);s[0]+=o,s[2]+=o}return s}getSmallestInfoForScale(s){const e=this.scales;if(this._infoByScale[s])return this._infoByScale[s];if(s>e[0])return this._infoByScale[e[0]];for(let t=1;t<e.length-1;t++)if(s>e[t]+ye)return this._infoByScale[e[t-1]];return this._infoByScale[e[e.length-1]]}getClosestInfoForScale(s){const e=this.scales;return this._infoByScale[s]||(s=e.reduce((t,i)=>Math.abs(i-s)<Math.abs(t-s)?i:t,e[0])),this._infoByScale[s]}scaleToLevel(s){const e=this.scales;if(this._infoByScale[s])return this._infoByScale[s].level;for(let t=e.length-1;t>=0;t--)if(s<e[t])return t===e.length-1?this._infoByScale[e[e.length-1]].level:this._infoByScale[e[t]].level+(e[t]-s)/(e[t]-e[t+1]);return this._infoByScale[e[0]].level}scaleToZoom(s){return this.tileInfo.scaleToZoom(s)}zoomToScale(s){return this.tileInfo.zoomToScale(s)}_getTileIdAtLOD(s,e,t){const i=this._infoByLevel[t.level];return s.set(t),e.resolution<i.resolution?null:(e.resolution===i.resolution||(s.level=e.level,s.col=Math.floor(t.col*i.resolution/e.resolution+.01),s.row=Math.floor(t.row*i.resolution/e.resolution+.01)),s)}};class ve{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class we{constructor(e){this._schedule=null,this._task=null,this._deferreds=new N,this._controllers=new N,this._processingItems=new N,this._pausedSignal=de(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new fe(e.peeker),this.process=e.process;const t=e.scheduler;e.priority&&t&&(this._task=t.registerTask(e.priority,this))}destroy(){this.clear(),this._schedule=j(this._schedule),this._task=j(this._task)}get updating(){var e;return!!((e=this._task)!=null&&e.updating)||this.readyToRun}get length(){return this._processingItems.size+this._queue.length}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach(t=>e.push(t)),this._controllers.clear(),e.forEach(t=>t.abort()),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach((t,i)=>e(i))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const i=this.get(e);if(i)return i;const o=new AbortController;let r=null;t&&(r=le(t,()=>o.abort()));const n=()=>{const c=this._processingItems.get(e);c&&c.controller.abort(),l(),h.reject(X())},l=()=>{a.remove(),r==null||r.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},a=ne(o.signal,n),h=he();return this._deferreds.set(e,h),this._controllers.set(e,o),h.promise.then(l,l),this._queue.push(e),this._scheduleNext(),h.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){var t;const e=this._queue.popLast();return e&&((t=this._deferreds.get(e))==null||t.reject(X()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}get readyToRun(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}runTask(e){for(;!e.done&&this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop()),e.madeProgress()}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._task||this._pausedSignal.value||this._schedule||(this._schedule=ae(()=>{this._schedule=null,this._next()}))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(e==null)return;let t;const i=new AbortController,o=new ve(e,i);this._processingItems.set(e,o);try{t=this.process(e,i.signal)}catch(r){this._processError(o,r)}ce(t)?(o.promise=t,t.then(r=>this._processResult(o,r),r=>this._processError(o,r))):this._processResult(o,t)}get test(){}}const D=[0,0];let C=class extends ee{constructor(s){super(s),this._keyToItem=new Map,this._tilesByScale=new Map,this.concurrency=6}initialize(){const{concurrency:s,process:e,scheduler:t,priority:i}=this;this._queue=new we({concurrency:s,scheduler:t,priority:i,process:(o,r)=>{const n=this._keyToItem.get(o);return e(n,{signal:r})},peeker:o=>this._peek(o)})}destroy(){this.clear(),this._queue=te(this._queue)}get length(){return this._queue?this._queue.length:0}abort(s){const e=typeof s=="string"?s:s.id;this._queue.abort(e)}clear(){this._queue.clear(),this._keyToItem.clear(),this._tilesByScale.clear()}has(s){return typeof s=="string"?this._keyToItem.has(s):this._keyToItem.has(s.id)}pause(){this._queue.pause()}push(s){const e=s.key.id;if(this._queue.has(e))return this._queue.get(e);const t=this._queue.push(e),i=this.tileInfoView.getTileScale(s.key),o=se(this._tilesByScale,i,()=>new Set),r=()=>{o.delete(s.key),o.size===0&&this._tilesByScale.delete(i),this._keyToItem.delete(e)};return o.add(s.key),this._keyToItem.set(e,s),t.then(r,r),t}reset(){this._queue.reset()}resume(){this._queue.resume()}_peek(s){if(!this.state)return s.values().next().value;const e=new Set;for(const r of s)e.add(this._keyToItem.get(r).key);const t=this.state.scale;let i,o=Number.POSITIVE_INFINITY;for(const[r,n]of this._tilesByScale)if(ie(n,l=>e.has(l))){const l=Math.abs(r-t);l<o&&(i=n,o=l)}return this._getClosestTileKey(i,s).id}_getClosestTileKey(s,e){const t=this.tileInfoView,i=this.state.center;let o,r=Number.POSITIVE_INFINITY;for(const n of s)if(e.has(n.id)){t.getTileCoords(D,n);const l=oe(D,i);l<r&&(r=l,o=n)}return o}};k([b({constructOnly:!0})],C.prototype,"concurrency",void 0),k([b({constructOnly:!0})],C.prototype,"priority",void 0),k([b({constructOnly:!0})],C.prototype,"process",void 0),k([b({constructOnly:!0})],C.prototype,"scheduler",void 0),k([b()],C.prototype,"state",void 0),k([b({constructOnly:!0})],C.prototype,"tileInfoView",void 0),C=k([ue("esri.views.2d.tiling.TileQueue")],C);const Pe=C;class Ie{constructor(e,t,i){this.maxSize=e,this._tileInfoView=t,this._removedFunc=i,this._tilePerId=new Map,this._tileKeysPerLevel=[]}clear(){this._tilePerId.clear(),this._tileKeysPerLevel=[]}has(e){return this._tilePerId.has(e)}get(e){return this._tilePerId.get(e)}pop(e){const t=this._tilePerId.get(e);if(!t)return;const i=t.key.level,o=this._tileKeysPerLevel[i];$(this._tilePerId,e);for(let r=0;r<o.length;r++)if(o[r].id===e){o.splice(r,1);break}return t.visible=!0,t}add(e){e.visible=!1;const t=e.key,i=t.id;if(this._tilePerId.has(i))return;this._tilePerId.set(i,e);const o=t.level;this._tileKeysPerLevel[o]||(this._tileKeysPerLevel[o]=[]),this._tileKeysPerLevel[o].push(t)}prune(e,t,i){let o=this._tilePerId.size;if(o<=this.maxSize)return;let r=this._tileKeysPerLevel.length-1;for(;o>this.maxSize&&r>=0;)r!==e&&(o=this._pruneAroundCenterTile(o,t,i,r)),r--;o>this.maxSize&&(o=this._pruneAroundCenterTile(o,t,i,e))}_pruneAroundCenterTile(e,t,i,o){const r=this._tileKeysPerLevel[o];if(!r||r.length===0)return e;const{size:n,origin:l}=this._tileInfoView.tileInfo,a=i*n[0],h=i*n[1],c=[0,0],f=[0,0];for(r.sort((_,y)=>(c[0]=l.x+a*(_.col+.5),c[1]=l.y-h*(_.row+.5),f[0]=l.x+a*(y.col+.5),f[1]=l.y-h*(y.row+.5),W(c,t)-W(f,t)));r.length>0;){const _=r.pop();if(this._removeTile(_.id),--e===this.maxSize)break}return e}_removeTile(e){const t=this._tilePerId.get(e);this._removedFunc&&t&&this._removedFunc(t),$(this._tilePerId,e)}}function $(s,e){s.delete(e)}const P=new q(0,0,0,0),T=new Map,B=[],E=[];let be=class{constructor(s){this._previousScale=Number.POSITIVE_INFINITY,this.cachePolicy="keep",this.coveragePolicy="closest",this.resampling=!0,this.tileIndex=new Map,this.tiles=[],this.buffer=192,this.acquireTile=s.acquireTile,this.releaseTile=s.releaseTile,this.tileInfoView=s.tileInfoView,s.resampling!=null&&(this.resampling=s.resampling),s.cachePolicy&&(this.cachePolicy=s.cachePolicy),s.coveragePolicy&&(this.coveragePolicy=s.coveragePolicy),s.buffer!=null&&(this.buffer=s.buffer),s.cacheSize&&(this._tileCache=new Ie(s.cacheSize,this.tileInfoView,e=>{this.releaseTile(e)}))}destroy(){this.tileIndex.clear()}update(s){var u,m;const{resampling:e,tileIndex:t}=this,{scale:i,center:o,resolution:r}=s.state,{minScale:n,maxScale:l}=this.tileInfoView,a=!s.stationary&&i>this._previousScale;if(this._previousScale=i,!e&&(i>n||i<l))return this.tiles.length=0,void this.clear();const h=this.tileInfoView.getTileCoverage(s.state,this.buffer,this.resampling,this.coveragePolicy);if(!h)return this.tiles.length=0,void this.clear();const{spans:c,lodInfo:f}=h,{level:_}=f;this.tiles.length=0,t.forEach(p=>p.visible=!0);let y=0,g=0;if(c.length>0)for(const{row:p,colFrom:F,colTo:L}of c)for(let z=F;z<=L;z++){y++;const S=P.set(_,p,f.normalizeCol(z),f.getWorldForColumn(z)).id;let x=t.get(S);if(x)x.isReady?(T.set(S,x),g++):a||this._addParentTile(S,T);else{if((u=this._tileCache)!=null&&u.has(S)){if(x=this._tileCache.pop(S),this.tileIndex.set(S,x),x.isReady){T.set(S,x),g++;continue}}else x=this.acquireTile(P),this.tileIndex.set(S,x);a||this._addParentTile(S,T)}}const v=g===y;for(const[p,F]of t){if(T.has(p))continue;P.set(p);const L=this.tileInfoView.intersects(h,P),z=this.cachePolicy==="purge"?P.level!==_:P.level>_;!L||!a&&v?!z&&L||B.push(F):F.isReady?z&&this.cachePolicy==="purge"&&this._hasReadyAncestor(P,_)?B.push(F):E.push(F):z&&B.push(F)}for(const p of E)p.isReady&&T.set(p.key.id,p);for(const p of B)this._tileCache?this._tileCache.add(p):this.releaseTile(p),t.delete(p.key.id);for(const p of T.values())this.tiles.push(p);for(const p of t.values())T.has(p.key.id)||(p.visible=!1);(m=this._tileCache)==null||m.prune(_,o,r),V.pool.release(h),E.length=0,B.length=0,T.clear()}clear(){const{tileIndex:s}=this;for(const e of s.values())this.releaseTile(e);s.clear()}refresh(s){var e;for(const t of this.tileIndex.values())s(t);(e=this._tileCache)==null||e.clear()}updateCacheSize(s){this._tileCache&&(this._tileCache.maxSize=s)}_addParentTile(s,e){var o;let t=s,i=null;for(;t=this.tileInfoView.getTileParentId(t),t;)if(this.tileIndex.has(t)){if(i=this.tileIndex.get(t),i==null?void 0:i.isReady){e.has(i.key.id)||e.set(i.key.id,i);break}}else if((o=this._tileCache)!=null&&o.has(t)&&(i=this._tileCache.pop(t),this.tileIndex.set(t,i),i==null?void 0:i.isReady)){e.has(i.key.id)||e.set(i.key.id,i);break}}_hasReadyAncestor(s,e){const t=Y();this.tileInfoView.getTileBounds(t,s,!0);for(const i of this.tileIndex.values())if(i.isReady&&i.key.level>=e&&i.key.level<s.level){const o=Y();if(this.tileInfoView.getTileBounds(o,i.key,!0),re(o,t))return!0}return!1}};class Q{constructor(e,t){this.key=new q(0,0,0,0),this.bounds=Y(),this.objectIds=new Set,this.key.set(t);const i=e.getLODInfoAt(this.key);this.tileInfoView=e,this.tileInfoView.getTileBounds(this.bounds,this.key,!0),this.resolution=i.resolution,this.level=i.level,this.scale=i.scale,this.minScale=e.zoomToScale(i.level-1),this.maxScale=e.zoomToScale(i.level+1)}get lod(){return this.tileInfoView.getLODInfoAt(this.key)}get id(){return this.key.id}get extent(){return G(this.bounds,this.tileInfoView.tileInfo.spatialReference)}get transform(){return{originPosition:"upperLeft",scale:[this.resolution,this.resolution],translate:[this.bounds[0],this.bounds[3]]}}createArcadeEvaluationOptions(e){return ge(this.scale,e)}createChildTiles(){const e=this.key.getChildKeys(),t=H.acquire();for(let i=0;i<e.length;i++)t[i]=new Q(this.tileInfoView,e[i]);return t}getQuantizationParameters(){return _e.fromJSON({mode:"view",originPosition:"upperLeft",tolerance:this.resolution,extent:{xmin:this.bounds[0],ymin:this.bounds[1],xmax:this.bounds[2],ymax:this.bounds[3],spatialReference:this.tileInfoView.tileInfo.spatialReference}})}}export{V as B,Q as E,be as I,we as j,Me as m,Pe as v};
