var f=Object.defineProperty;var w=(o,e,i)=>e in o?f(o,e,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[e]=i;var n=(o,e,i)=>w(o,typeof e!="symbol"?e+"":e,i);import{gV as A,hB as u,iE as L,iF as $,gT as g,iG as v,iH as H,iI as O}from"./index-BeTPrQ6f.js";import{a as c,t as G,l,s as d}from"./hilight-defs-DzKgjtLG-D-utaUCJ.js";class p extends L{constructor(i,t){super(t);n(this,"config",{});n(this,"mode",c.NONE);this.config=i,this.mode=i.mode}async add(i){this.notImplementedError("addGraphics")}async remove(i){this.notImplementedError("removeGraphics")}async reloadHilight(i){this.notImplementedError("reloadHilight")}async getHilightLayer(){const i=await this.layerFetcher();if(i){if(i.isLoaded&&i instanceof $)return i;console.warn("Hilight layer exists but is in bad form.");return}else{console.warn("Hilight layer could not be fetched.");return}}notImplementedError(i){console.warn(`Hilight mode method ${i} was not implemented by subclass.`)}layerFetcher(){const i=this.$iApi.geo.layer.getLayer(l);return i?Promise.resolve(i):new Promise(t=>{let a=0;const s=setInterval(()=>{const r=this.$iApi.geo.layer.getLayer(l);if(r)clearInterval(s),t(r);else if(a+=125,a>=1125){clearInterval(s),t(void 0);return}},125)})}}class y extends p{async add(e){const i=await this.getHilightLayer();i&&await i.addGraphic(e)}async remove(e){const i=await this.getHilightLayer();i&&i.removeGraphic(e)}async reloadHilight(e){await this.remove(e),await this.add(e)}}class M extends y{constructor(i,t){var a,s;super(i,t);n(this,"handlers",[]);n(this,"onOpacity");n(this,"offOpacity");n(this,"lastAdd",0);this.onOpacity=((a=i.options)==null?void 0:a.onOpacity)??.75,this.offOpacity=((s=i.options)==null?void 0:s.offOpacity)>.02?i.options.offOpacity:.02,this.$iApi.geo.map.created?this.hilightSetup():this.handlers.push(this.$iApi.event.on(g.MAP_CREATED,()=>{this.hilightSetup()})),this.handlers.push(this.$iApi.event.on(g.MAP_BASEMAPCHANGE,()=>{this.getHilightLayer().then(r=>{r&&r.graphics.length===0&&this.updateFogLayer()})}))}async hilightSetup(){const i=v(this.$vApp.$pinia).activeBasemapConfig;try{const t=this.$iApi.geo.layer.createLayer({id:d,layerType:u.TILE,cosmetic:!0,system:!0,url:i.layers[0].url});await this.$iApi.geo.map.addLayer(t),t.opacity=this.offOpacity,await this.reorderFogLayer()}catch{console.error("Something went wrong while setting up the hilighter.")}}async updateFogLayer(){this.$iApi.geo.map.removeLayer(d),await this.hilightSetup()}async reorderFogLayer(){const i=this.getFogLayer(),t=await this.getHilightLayer();if(!t||!i)return;const a=this.$iApi.geo.layer.layerOrderIds(),s=a.indexOf(i.id),r=a.indexOf(t.id);r<s&&r>-1&&s>-1&&this.$iApi.geo.map.reorder(t,s,!1)}async add(i){this.lastAdd=Date.now();const t=this.getFogLayer();t&&(t.opacity=this.onOpacity,await super.add(i))}async remove(i){await super.remove(i);const t=this.getFogLayer();if(!t)return;const a=Date.now(),s=await this.getHilightLayer();s&&setTimeout(()=>{this.lastAdd<a&&!s.getGraphicCount()&&(t.opacity=this.offOpacity)},300)}async reloadHilight(i){await this.updateFogLayer(),await super.reloadHilight(i)}getFogLayer(){const i=this.$iApi.geo.layer.getLayer(d);if(i&&i instanceof H)return i;console.warn("Hilight fog layer could not be fetched.")}}class m extends y{constructor(i,t){super(i,t);n(this,"handlers",[]);this.hilightSetup(i),this.handlers.push(this.$iApi.event.on(g.MAP_CREATED,()=>{this.hilightSetup(i)}))}hilightSetup(i){this.$iApi.geo.map.viewPromise.then(()=>{this.$iApi.geo.map.esriView.highlightOptions=i.options})}async add(i){await super.add(i);const t=this.$iApi.geo.layer.getLayer(l);if(t&&t.esriLayer&&t.isLoaded&&t instanceof O){const a=i instanceof Array?i:[i];await t.viewPromise(),t.esriView.highlight(a.map(s=>t.getEsriGraphic(s.id)))}}async remove(i){await super.remove(i)}}class E extends A{constructor(){super(...arguments);n(this,"hilightMode",new p({},this.$iApi))}initialized(){this.initHilightLayer()}_parseConfig(i){if(i)switch(i.mode){case c.NONE:this.hilightMode=new p(i,this.$iApi);break;case c.GLOW:this.hilightMode=new m(i,this.$iApi);break;case c.LIFT:this.hilightMode=new y(i,this.$iApi);break;case c.FOG:this.hilightMode=new M(i,this.$iApi);break;default:console.error("Could not find hilight mode:",i.mode);break}else this.hilightMode=new m(G,this.$iApi)}async initHilightLayer(){const i=this.$iApi.geo.layer.createLayer({id:l,layerType:u.GRAPHIC,cosmetic:!0,system:!0,url:""});await this.$iApi.geo.map.addLayer(i)}async addHilight(i){const t=i instanceof Array?i:[i];await this.hilightMode.add(t)}async removeHilight(i){const t=i?i instanceof Array?i:[i]:void 0;await this.hilightMode.remove(t)}async reloadHilight(i){const t=i instanceof Array?i:[i];await this.hilightMode.reloadHilight(t)}async getGraphicsByKey(i,t,a){const s=await this.getHilightLayer();if(!s)return[];let r=s.graphics.map(h=>({...this.deconstructGraphicKey(h.id),og:h}));return i&&(r=r.filter(h=>h.origin===i)),t&&(r=r.filter(h=>h.uid===t)),a&&(r=r.filter(h=>h.oid===a)),r.map(h=>h.og)}constructGraphicKey(i,t,a){return`${l}~${i}~${t}~${a}`}deconstructGraphicKey(i){const t=i.split("~");return t.length!==4&&console.warn("Malformed Hilight Graphic key provided:",i),{origin:t[1],uid:t[2],oid:parseInt(t[3])}}async getHilightLayer(){if(this.hilightMode)return await this.hilightMode.getHilightLayer();console.warn("API get layer request before highlight mode object exists")}}class x extends E{async added(){this._parseConfig(this.config);const e=this.$vApp.$watch(()=>this.config,i=>this._parseConfig(i));this.removed=()=>{e()}}}export{x as default};
