import{U as h}from"./workers-0oosFQiO-BAPpAYPM.js";import{E as l,bI as w}from"./index-Byk76P34.js";import"./Queue-B8H6jIv7-D5YH_9sS.js";import"./intl-DLmy-Li5-BiwIvMxv.js";function a(e){var t;return Array.isArray(e)?(t=e[0])==null?void 0:t.spatialReference:e==null?void 0:e.spatialReference}function p(e){return e&&(Array.isArray(e)?e.map(p):e.toJSON?e.toJSON():e)}function c(e){return Array.isArray(e)?e.map(t=>w(t)):w(e)}function S(e,t){let n;return Array.isArray(e)?n=e:(n=[],n.push(e),t!=null&&n.push(t)),n}let f;async function d(){return f||(f=h("geometryEngineWorker",{strategy:"distributed"})),f}async function r(e,t){return(await d()).invoke("executeGEOperation",{operation:e,parameters:p(t)})}async function m(e,t){const n=await d();return Promise.all(n.broadcast("executeGEOperation",{operation:e,parameters:p(t)}))}function D(e){return r("extendedSpatialReferenceInfo",[e])}async function J(e,t){return c(await r("clip",[a(e),e,t]))}async function N(e,t){return c(await r("cut",[a(e),e,t]))}function E(e,t){return r("contains",[a(e),e,t])}function L(e,t){return r("crosses",[a(e),e,t])}function T(e,t,n){return r("distance",[a(e),e,t,n])}function V(e,t){return r("equals",[a(e),e,t])}function b(e,t){return r("intersects",[a(e),e,t])}function v(e,t){return r("touches",[a(e),e,t])}function z(e,t){return r("within",[a(e),e,t])}function H(e,t){return r("disjoint",[a(e),e,t])}function I(e,t){return r("overlaps",[a(e),e,t])}function P(e,t,n){return r("relate",[a(e),e,t,n])}function j(e){return r("isSimple",[a(e),e])}async function k(e){return c(await r("simplify",[a(e),e]))}async function q(e,t=!1){return c(await r("convexHull",[a(e),e,t]))}async function B(e,t){return c(await r("difference",[a(e),e,t]))}async function C(e,t){return c(await r("symmetricDifference",[a(e),e,t]))}async function G(e,t){return c(await r("intersect",[a(e),e,t]))}async function U(e,t=null){const n=S(e,t);return c(await r("union",[a(n),n]))}async function W(e,t,n,i,s,u){return c(await r("offset",[a(e),e,t,n,i,s,u]))}async function F(e,t,n,i=!1){const s=[a(e),e,t,n,i];return c(await r("buffer",s))}async function K(e,t,n,i,s,u){const g=[a(e),e,t,n,i,s,u];return c(await r("geodesicBuffer",g))}async function M(e,t,n=!0){const i=await r("nearestCoordinate",[a(e),e,t,n]);return{...i,coordinate:l.fromJSON(i.coordinate)}}async function Q(e,t){const n=await r("nearestVertex",[a(e),e,t]);return{...n,coordinate:l.fromJSON(n.coordinate)}}async function X(e,t,n,i){return(await r("nearestVertices",[a(e),e,t,n,i])).map(s=>({...s,coordinate:l.fromJSON(s.coordinate)}))}function y(e){var t;return"xmin"in e?e.center:"x"in e?e:(t=e.extent)==null?void 0:t.center}async function Y(e,t,n){if(e==null)throw new o;const i=e.spatialReference;if((n=n??y(e))==null)throw new o;const s=e.constructor.fromJSON(await r("rotate",[i,e,t,n]));return s.spatialReference=i,s}async function Z(e,t){if(e==null)throw new o;const n=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await r("flipHorizontal",[n,e,t]));return i.spatialReference=n,i}async function _(e,t){if(e==null)throw new o;const n=e.spatialReference;if((t=t??y(e))==null)throw new o;const i=e.constructor.fromJSON(await r("flipVertical",[n,e,t]));return i.spatialReference=n,i}async function $(e,t,n,i){return c(await r("generalize",[a(e),e,t,n,i]))}async function ee(e,t,n){return c(await r("densify",[a(e),e,t,n]))}async function te(e,t,n,i=0){return c(await r("geodesicDensify",[a(e),e,t,n,i]))}function ne(e,t){return r("planarArea",[a(e),e,t])}function re(e,t){return r("planarLength",[a(e),e,t])}function ae(e,t,n){return r("geodesicArea",[a(e),e,t,n])}function ie(e,t,n){return r("geodesicLength",[a(e),e,t,n])}async function ce(e,t){return c(await r("intersectLinesToPoints",[a(e),e,t]))}async function se(e,t){await m("changeDefaultSpatialReferenceTolerance",[e,t])}async function oe(e){await m("clearDefaultSpatialReferenceTolerance",[e])}class o extends Error{constructor(){super("Illegal Argument Exception")}}export{F as buffer,se as changeDefaultSpatialReferenceTolerance,oe as clearDefaultSpatialReferenceTolerance,J as clip,E as contains,q as convexHull,L as crosses,N as cut,ee as densify,B as difference,H as disjoint,T as distance,V as equals,D as extendedSpatialReferenceInfo,Z as flipHorizontal,_ as flipVertical,$ as generalize,ae as geodesicArea,K as geodesicBuffer,te as geodesicDensify,ie as geodesicLength,G as intersect,ce as intersectLinesToPoints,b as intersects,j as isSimple,M as nearestCoordinate,Q as nearestVertex,X as nearestVertices,W as offset,I as overlaps,ne as planarArea,re as planarLength,P as relate,Y as rotate,k as simplify,C as symmetricDifference,v as touches,U as union,z as within};
