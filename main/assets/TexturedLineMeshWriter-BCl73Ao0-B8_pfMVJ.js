import{gj as g,bp as Fe,P as ue,l as Oe,aO as De,kZ as Ie,ah as Ne}from"./index-BeTPrQ6f.js";import{A as ze,D as le}from"./GeometryUtils-C8-DjR3I-DcNL1Jc6.js";import{n as he,u as Ge,w as Ce,E as z,r as Re,F as te,p as pe,G as Ye}from"./constants-CWFGCPkc-B_3x8_48.js";import{_ as l}from"./enums-DDJfd4_p-D3z9tmVA.js";import{e as G}from"./defaultCIMValues-BWu-APou-XI-Li77m.js";import{N as fe,z as Ue,H as k,M as C,a as R}from"./definitions-DVO21zOC-BwakNu1s.js";import{E as V,U as H,N as se}from"./UpdateTracking2D-CIKx7GWt-CEE8vGb9.js";import{b as P}from"./labelPoint-DTWBMY-Z-DoXEvKTt.js";import{P as Be,k as Ve,E as He}from"./TurboLine-CvWJ2xTB-C5q-5bd9.js";import{X as xe,H as We,K as Ze,G as qe}from"./Utils-CYY0kXyb-BZKnUtTY.js";import{c as $e}from"./OptimizedGeometry-BYxlP_oK-DvAqrgO1.js";import{g as Xe,a as re,i as ie,t as ne}from"./CIMSymbolHelper-C-M9oL19-BYnF76mM.js";const Ke=()=>ue.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),je=0,Je=100;function de(e,t){return[!!(e!=null&&e.minScale)&&t.scaleToZoom(e.minScale)||je,!!(e!=null&&e.maxScale)&&t.scaleToZoom(e.maxScale)||Je]}function ae(e){return 1<<e}function D(e){let t=0;for(const[s,i]of e)i&&(t|=1<<s);return t}function B(e){let t;if(!e)return[0,0,0,0];if(typeof e=="string"){const a=Fe.fromString(e);if(!a)return Ke().errorOnce(new Oe("mapview:mesh-processing","Unable to parse string into color",{color:e})),[0,0,0,0];t=a.toArray()}else t=e;const[s,i,r,n]=t;return[s*(n/255),i*(n/255),r*(n/255),n]}function Qe(e){switch(e){case"butt":case"Butt":return 0;case"round":case"Round":return 1;case"square":case"Square":return 2}}function et(e){switch(e){case"bevel":case"Bevel":return 0;case"miter":case"Miter":return 2;case"round":case"Round":return 1}}function os(e,t){return Math.round(Math.min(Math.sqrt(e*t),255))}function I(e,t){return Math.round(e*t)/t}const tt=96/72;let st=class{static executeEffects(e,t,s,i){const r=tt,n=re(e);let a=new ne(t);for(const o of e){const c=ie(o);c&&(a=c.execute(a,o,r,s,n,i))}return a}static applyEffects(e,t){if(!e)return t;const s=re(e);let i,r=new ne(P.fromJSONCIM(t));for(const o of e){const c=ie(o);c&&(r=c.execute(r,o,1,null,s,!1))}const n=[];let a=null;for(;i=r.next();)n.push(...Ie(i)),a=i.geometryType;return n.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:n}:{paths:n}}};function me(e){switch(e){case l.BYTE:case l.UNSIGNED_BYTE:return 1;case l.SHORT:case l.UNSIGNED_SHORT:case l.HALF_FLOAT:return 2;case l.FLOAT:case l.INT:case l.UNSIGNED_INT:return 4}}function rt(e){const t=[],s=[],i=[];for(const r of e){const n=me(r.type)*r.count;switch(n%2||n%4||4){case 4:t.push(r);continue;case 2:s.push(r);continue;case 1:i.push(r);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...s),t.push(...i),t}let it=class ye{static fromVertexSpec(t,s){const{attributes:i,optionalAttributes:r}=t;let n,a,o;const c=[];for(const m in i){if(i[m].otherSource)continue;const y=i[m];y.pack==="position"?n={...y,name:m,offset:0}:y.pack==="id"?a={...y,name:m,offset:4}:m==="bitset"?o={...y,name:m,offset:7}:c.push({...y,name:m})}for(const m in r)if(s[m]===!0){const y=r[m];c.push({...y,name:m})}const u=rt(c),h=[];let p=8,d=1;for(const m of u)h.push({...m,offset:p}),p+=me(m.type)*m.count,m.packAlternating&&(d=Math.max(m.packAlternating.count,d));const f=Uint32Array.BYTES_PER_ELEMENT,x=p%f;return new ye(n,a,o,h,p+(x?f-x:0),d)}constructor(t,s,i,r,n,a){this.position=t,this.id=s,this.bitset=i,this.standardAttributes=r,this.stride=n,this.packVertexCount=a,r.push(i),this._attributes=[t,s,i,...r]}get attributeLayout(){if(!this._attributeLayout){const t=qe(this._attributes),s=this._attributes.map(i=>({name:i.name,count:i.count,offset:i.offset,type:i.type,packPrecisionFactor:i.packPrecisionFactor,normalized:i.normalized??!1}));this._attributeLayout={attributes:s,hash:t,stride:this.stride}}return this._attributeLayout}},nt=class _e{static fromVertexSpec(t,s){const i=it.fromVertexSpec(t,s);return new _e(i)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,s,i,r,n,a){var o;for(let c=0;c<this._spec.packVertexCount;c++){const u=c*this._spec.stride;this._packPosition(i,r,u),this._packId(s,u);const h=this._spec.bitset;if(a){if(h.packTessellation){const p=h.packTessellation(a,n,i,r);this._pack(p,h,u)}for(const p of this._spec.standardAttributes)if(p.packTessellation!=null){const d=p.packTessellation(a,n,i,r);this._pack(d,p,u)}else if((o=p.packAlternating)!=null&&o.packTessellation){const d=p.packAlternating.packTessellation(a,n,i,r);for(let f=0;f<this._spec.packVertexCount;f++){const x=d[f];this._pack(x,p,f*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,s){var i;for(const r of this._spec.standardAttributes)if(r.pack&&typeof r.pack!="string"){const n=r.pack(t,s);for(let a=0;a<this._spec.packVertexCount;a++)this._pack(n,r,a*this._spec.stride)}else if((i=r.packAlternating)!=null&&i.pack){const n=r.packAlternating.pack(t,s);for(let a=0;a<this._spec.packVertexCount;a++){const o=n[a];this._pack(o,r,a*this._spec.stride)}}}_packPosition(t,s,i){const{offset:r}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,a=We(t*n,s*n);this._dataView.setUint32(i+r,a,!0)}_packId(t,s){const i=t*(this._spec.id.packPrecisionFactor??1),r=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,i|r,!0)}_pack(t,s,i){Ze(this._dataView,t,s,i)}},ge=class{constructor(e,t,s,i){this._instanceId=e,this._evaluator=t,this._enabledOptionalAttributes=s,this._viewParams=i,this._evaluator.evaluator=r=>this.vertexSpec.createComputedParams(r)}get _vertexPack(){if(!this._cachedVertexPack){const e=nt.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||e.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=e}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){var e;return(e=this._evaluator.inputMeshParams.effects)==null?void 0:e.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(e){this._references=e}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){for(const{effect:e}of this.effectInfos||[])await Xe(e)}enqueueRequest(e,t,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(e,t,s)}write(e,t,s,i,r){this.ensurePacked(t,s,i);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(e,s,void 0,r);const a=this.getEffectCursor(e,s,n);if(!a)return;let o;for(;o=a.next();)o.invertY(),this._write(e,s,o,r)}ensurePacked(e,t,s){if(!this._evaluator.hasDynamicProperties)return;const i=this._evaluator.evaluateMeshParams(e,t,s);this._vertexPack.pack(i,this._viewParams)}hasArcadeDependency(e){return this._evaluator.hasArcadeDependency(e)}_writeVertex(e,t,s,i,r){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(e,t,s,i,n,r)}getEffectCursor(e,t,s){var a;const i=(a=t.readGeometryForDisplay())==null?void 0:a.clone();if(!i)return;const r=P.fromOptimizedCIM(i,t.geometryType);r.invertY();const n=e.id||"";return st.executeEffects(s,r,n,this._preventEffectClipping)}};function at(e,t,s,i,r,n,a){q=0;const o=(i-s)*n,c=r&&r.length,u=c?(r[0]-s)*n:o;let h,p,d,f,x,m=ve(t,s,i,0,u,n,!0);if(m&&m.next!==m.prev){if(c&&(m=lt(t,s,i,r,m,n)),o>80*n){h=d=t[0+s*n],p=f=t[1+s*n];for(let y=n;y<u;y+=n){const Q=t[y+s*n],ee=t[y+1+s*n];h=Math.min(h,Q),p=Math.min(p,ee),d=Math.max(d,Q),f=Math.max(f,ee)}x=Math.max(d-h,f-p),x=x!==0?1/x:0}A(m,e,n,h,p,x,a,0)}}function ve(e,t,s,i,r,n,a){let o;if(a===dt(e,t,s,i,r,n)>0)for(let c=i;c<r;c+=n)o=oe(c+t*n,e[c+t*n],e[c+1+t*n],o);else for(let c=r-n;c>=i;c-=n)o=oe(c+t*n,e[c+t*n],e[c+1+t*n],o);return o&&w(o,o.next)&&(L(o),o=o.next),o}function M(e,t=e){if(!e)return e;let s,i=e;do if(s=!1,i.steiner||!w(i,i.next)&&_(i.prev,i,i.next)!==0)i=i.next;else{if(L(i),i=t=i.prev,i===i.next)break;s=!0}while(s||i!==t);return t}function A(e,t,s,i,r,n,a,o){if(!e)return;!o&&n&&(e=ke(e,i,r,n));let c=e;for(;e.prev!==e.next;){const u=e.prev,h=e.next;if(n?ct(e,i,r,n):ot(e))t.push(u.index/s+a),t.push(e.index/s+a),t.push(h.index/s+a),L(e),e=h.next,c=h.next;else if((e=h)===c){o?o===1?A(e=yt(e,t,s,a),t,s,i,r,n,a,2):o===2&&_t(e,t,s,i,r,n,a):A(M(e),t,s,i,r,n,a,1);break}}}function ot(e){const t=e.prev,s=e,i=e.next;if(_(t,s,i)>=0)return!1;let r=e.next.next;const n=r;let a=0;for(;r!==e.prev&&(a===0||r!==n);){if(a++,T(t.x,t.y,s.x,s.y,i.x,i.y,r.x,r.y)&&_(r.prev,r,r.next)>=0)return!1;r=r.next}return!0}function ct(e,t,s,i){const r=e.prev,n=e,a=e.next;if(_(r,n,a)>=0)return!1;const o=r.x<n.x?r.x<a.x?r.x:a.x:n.x<a.x?n.x:a.x,c=r.y<n.y?r.y<a.y?r.y:a.y:n.y<a.y?n.y:a.y,u=r.x>n.x?r.x>a.x?r.x:a.x:n.x>a.x?n.x:a.x,h=r.y>n.y?r.y>a.y?r.y:a.y:n.y>a.y?n.y:a.y,p=W(o,c,t,s,i),d=W(u,h,t,s,i);let f=e.prevZ,x=e.nextZ;for(;f&&f.z>=p&&x&&x.z<=d;){if(f!==e.prev&&f!==e.next&&T(r.x,r.y,n.x,n.y,a.x,a.y,f.x,f.y)&&_(f.prev,f,f.next)>=0||(f=f.prevZ,x!==e.prev&&x!==e.next&&T(r.x,r.y,n.x,n.y,a.x,a.y,x.x,x.y)&&_(x.prev,x,x.next)>=0))return!1;x=x.nextZ}for(;f&&f.z>=p;){if(f!==e.prev&&f!==e.next&&T(r.x,r.y,n.x,n.y,a.x,a.y,f.x,f.y)&&_(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;x&&x.z<=d;){if(x!==e.prev&&x!==e.next&&T(r.x,r.y,n.x,n.y,a.x,a.y,x.x,x.y)&&_(x.prev,x,x.next)>=0)return!1;x=x.nextZ}return!0}function oe(e,t,s,i){const r=E.create(e,t,s);return i?(r.next=i.next,r.prev=i,i.next.prev=r,i.next=r):(r.prev=r,r.next=r),r}function L(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function ut(e){let t=e,s=e;do(t.x<s.x||t.x===s.x&&t.y<s.y)&&(s=t),t=t.next;while(t!==e);return s}function lt(e,t,s,i,r,n){const a=new Array;for(let o=0,c=i.length;o<c;o++){const u=ve(e,t,s,i[o]*n,o<c-1?i[o+1]*n:s*n,n,!1);u===u.next&&(u.steiner=!0),a.push(ut(u))}a.sort(mt);for(const o of a)r=ht(o,r);return r}function ht(e,t){const s=pt(e,t);if(!s)return t;const i=we(s,e);return M(i,i.next),M(s,s.next)}function pt(e,t){let s=t;const i=e.x,r=e.y;let n,a=-1/0;do{if(r<=s.y&&r>=s.next.y&&s.next.y!==s.y){const d=s.x+(r-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(d<=i&&d>a){if(a=d,d===i){if(r===s.y)return s;if(r===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==t);if(!n)return null;if(i===a)return n.prev;const o=n,c=n.x,u=n.y;let h,p=1/0;for(s=n.next;s!==o;)i>=s.x&&s.x>=c&&i!==s.x&&T(r<u?i:a,r,c,u,r<u?a:i,r,s.x,s.y)&&(h=Math.abs(r-s.y)/(i-s.x),(h<p||h===p&&s.x>n.x)&&F(s,e)&&(n=s,p=h)),s=s.next;return n}function ke(e,t,s,i){let r;for(;r!==e;r=r.next){if(r=r||e,r.z===null&&(r.z=W(r.x,r.y,t,s,i)),r.prev.next!==r||r.next.prev!==r)return r.prev.next=r,r.next.prev=r,ke(e,t,s,i);r.prevZ=r.prev,r.nextZ=r.next}return e.prevZ.nextZ=null,e.prevZ=null,ft(e)}function ft(e){let t,s=1;for(;;){let i,r=e;e=null,t=null;let n=0;for(;r;){n++,i=r;let a=0;for(;a<s&&i;a++)i=i.nextZ;let o=s;for(;a>0||o>0&&i;){let c;a===0?(c=i,i=i.nextZ,o--):o!==0&&i?r.z<=i.z?(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--),t?t.nextZ=c:e=c,c.prevZ=t,t=c}r=i}if(t.nextZ=null,s*=2,n<2)return e}}function _(e,t,s){return(t.y-e.y)*(s.x-t.x)-(t.x-e.x)*(s.y-t.y)}function be(e,t,s,i){return!!(w(e,t)&&w(s,i)||w(e,i)&&w(s,t))||_(e,t,s)>0!=_(e,t,i)>0&&_(s,i,e)>0!=_(s,i,t)>0}function xt(e,t){let s=e;do{if(s.index!==e.index&&s.next.index!==e.index&&s.index!==t.index&&s.next.index!==t.index&&be(s,s.next,e,t))return!0;s=s.next}while(s!==e);return!1}function dt(e,t,s,i,r,n){let a=0;for(let o=i,c=r-n;o<r;o+=n)a+=(e[c+t*n]-e[o+t*n])*(e[o+1+t*n]+e[c+1+t*n]),c=o;return a}function T(e,t,s,i,r,n,a,o){return(r-a)*(t-o)-(e-a)*(n-o)>=0&&(e-a)*(i-o)-(s-a)*(t-o)>=0&&(s-a)*(n-o)-(r-a)*(i-o)>=0}function F(e,t){return _(e.prev,e,e.next)<0?_(e,t,e.next)>=0&&_(e,e.prev,t)>=0:_(e,t,e.prev)<0||_(e,e.next,t)<0}function W(e,t,s,i,r){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*r)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*r)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function w(e,t){return e.x===t.x&&e.y===t.y}function mt(e,t){return e.x-t.x}function yt(e,t,s,i){let r=e;do{const n=r.prev,a=r.next.next;!w(n,a)&&be(n,r,r.next,a)&&F(n,a)&&F(a,n)&&(t.push(n.index/s+i),t.push(r.index/s+i),t.push(a.index/s+i),L(r),L(r.next),r=e=a),r=r.next}while(r!==e);return r}function _t(e,t,s,i,r,n,a){let o=e;do{let c=o.next.next;for(;c!==o.prev;){if(o.index!==c.index&&gt(o,c)){let u=we(o,c);return o=M(o,o.next),u=M(u,u.next),A(o,t,s,i,r,n,a,0),void A(u,t,s,i,r,n,a,0)}c=c.next}o=o.next}while(o!==e)}function gt(e,t){return e.next.index!==t.index&&e.prev.index!==t.index&&!xt(e,t)&&F(e,t)&&F(t,e)&&vt(e,t)}function vt(e,t){let s=e,i=!1;const r=(e.x+t.x)/2,n=(e.y+t.y)/2;do s.y>n!=s.next.y>n&&s.next.y!==s.y&&r<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(i=!i),s=s.next;while(s!==e);return i}function we(e,t){const s=E.create(e.index,e.x,e.y),i=E.create(t.index,t.x,t.y),r=e.next,n=t.prev;return e.next=t,t.prev=e,s.next=r,r.prev=s,i.next=s,s.prev=i,n.next=i,i.prev=n,i}class E{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,s,i){const r=q<Z.length?Z[q++]:new E;return r.index=t,r.x=s,r.y=i,r.prev=null,r.next=null,r.z=null,r.prevZ=null,r.nextZ=null,r.steiner=!1,r}}const Z=[],kt=8096;let q=0;for(let e=0;e<kt;e++)Z.push(new E);const bt=1e-5,b=new le(0,0,0,1,0),$=new le(0,0,0,1,0);function ce(e,t,s){let i=0;for(let r=1;r<s;r++){const n=e[2*(t+r-1)],a=e[2*(t+r-1)+1];i+=(e[2*(t+r)]-n)*(e[2*(t+r)+1]+a)}return i}function wt(e,t,s,i,r){let n=0;const a=2;for(let o=s;o<i;o+=3){const c=(e[o]-r)*a,u=(e[o+1]-r)*a,h=(e[o+2]-r)*a;n+=Math.abs((t[c]-t[h])*(t[u+1]-t[c+1])-(t[c]-t[u])*(t[h+1]-t[c+1]))}return n}function Pt(e,t){const{coords:s,lengths:i}=t,r=0,n=e;let a=0;for(let o=0;o<i.length;){let c=o,u=i[o],h=ce(s,a,u);const p=[];for(;++c<i.length;){const m=i[c],y=ce(s,a+u,m);if(!(y>0))break;h+=y,p.push(a+u),u+=m}const d=n.length;at(n,s,a,a+u,p,2,r);const f=wt(n,s,d,n.length,r),x=Math.abs(h);if(Math.abs((f-x)/Math.max(1e-7,x))>bt)return n.length=0,!1;o=c,a+=u}return!0}function St(e){const{coords:t,lengths:s}=e,{buffer:i}=He(t,s);return i}function Tt(e,t,s){let i=0;for(let r=0;r<e.lengths.length;r++){const n=e.lengths[r];for(let a=0;a<n;a++){const o=e.coords[2*(a+i)],c=e.coords[2*(a+i)+1];if(o<t||o>s||c<t||c>s)return!0}i+=n}return!1}function Pe(e,t){if(e==null)return null;if(!Tt(e,-128,R+128))return e;b.setPixelMargin(t),b.reset(3);let s=0;for(let a=0;a<e.lengths.length;a++){const o=e.lengths[a];let c=e.coords[2*(0+s)],u=e.coords[2*(0+s)+1];b.moveTo(c,u);for(let h=1;h<o;h++)c=e.coords[2*(h+s)],u=e.coords[2*(h+s)+1],b.lineTo(c,u);b.close(),s+=o}const i=b.result(!1);if(!i)return null;const r=[],n=[];for(const a of i){let o=0;for(const c of a)n.push(c.x),n.push(c.y),o++;r.push(o)}return new $e(r,n)}function Et(e,t){$.setPixelMargin(t);const s=$,i=-t,r=R+t;let n=[],a=!1;if(!e.nextPath())return null;let o=e.pathLength(),c=!0;for(;c;){e.seekPathStart();const u=[];if(!e.pathSize)return null;s.reset(2),e.nextPoint();let h=e.x,p=e.y;if(a)s.moveTo(h,p);else{if(h<i||h>r||p<i||p>r){a=!0;continue}u.push({x:h,y:p})}let d=!1;for(;e.nextPoint();)if(h=e.x,p=e.y,a)s.lineTo(h,p);else{if(h<i||h>r||p<i||p>r){d=!0;break}u.push({x:h,y:p})}if(d)a=!0;else{if(a){const f=s.resultWithStarts();if(f)for(const x of f)n.push({...x,pathLength:o})}else n.push({line:u,start:0,pathLength:o});c=e.nextPath(),o=c?e.pathLength():0,a=!1}}return n=n.filter(u=>u.line.length>1),n.length===0?null:n}b.setExtent(R),$.setExtent(R);let Mt=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const v={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:l.SHORT,count:2,packPrecisionFactor:fe,pack:({scaleInfo:e},{tileInfo:t})=>de(e,t)}},attributes:{id:{type:l.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:l.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:l.UNSIGNED_BYTE,count:1},color:{type:l.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>B(e)},offset:{type:l.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[I(e,16),I(t,16)]},normal:{type:l.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[I(e,16),I(t,16)]},halfWidth:{type:l.HALF_FLOAT,count:1,pack:({width:e})=>g(.5*e)},referenceHalfWidth:{type:l.HALF_FLOAT,count:1,pack:({referenceWidth:e})=>g(.5*e)}}};class At{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}}const N=65535;class X extends ge{constructor(t,s,i,r){super(t,s,i,r),this.vertexSpec=v,this._currentWrite=new At,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:N,textured:!1},this._tessParams=new Mt,this._initializeTessellator()}writeLineVertices(t,s,i){const r=this._getLines(s);r!=null&&this._writeVertices(t,i,r)}_initializeTessellator(){this._lineTessellator=new Be(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,s,i){const r=i??P.fromFeatureSetReaderCIM(s);r&&this._writeGeometry(t,s,r)}_writeGeometry(t,s,i,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,i,s),t.recordEnd()}_getLines(t){return Et(t,xe(this.evaluatedMeshParams))}_writeVertices(t,s,i){const{_currentWrite:r,_tessellationOptions:n,evaluatedMeshParams:a}=this,{width:o,capType:c,joinType:u,miterLimit:h,hasSizeVV:p}=a,d=g(.5*o);n.halfWidth=d,n.capType=Qe(c),n.joinType=et(u),n.miterLimit=h;const f=!p;r.out=t,r.id=s.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=f&&d<Ue?0:1;for(const{line:x,start:m,pathLength:y}of i)n.initialDistance=m%N,r.pathLength=y,r.distanceOffset=Math.floor(m/N)*N,this._lineTessellator.tessellate(x,n,f)}_writeTesselatedVertex(t,s,i,r,n,a,o,c,u,h,p){const{out:d,id:f,vertexBounds:x,pathLength:m,distanceOffset:y}=this._currentWrite;return this.hasEffects&&d.recordBounds(t,s,x,x),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=c,this._tessParams.normalX=u,this._tessParams.normalY=h,this._tessParams.directionX=n,this._tessParams.directionY=a,this._tessParams.distance=p,this._tessParams.pathLength=m,this._tessParams.distanceOffset=y,this._writeVertex(d,f,t,s,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,s,i){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(s),r.indexWrite(i),this._currentWrite.indexCount+=3}}const Lt=100,Ft=Ne("featurelayer-fast-triangulation-enabled");let Se=class extends ge{async loadDependencies(){await Promise.all([super.loadDependencies(),Ve()])}_write(e,t,s){const i=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),r=this._clip(i);r&&(e.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(e,t,r),e.recordEnd())}_clip(e){if(!e)return null;const t=this.hasEffects;return Pe(e,t?256:8)}_writeGeometry(e,t,s){const i=s.maxLength>Lt,r=[],n=this.createTesselationParams(t);if(!i&&Ft&&Pt(r,s))return void(r.length&&this._writeVertices(e,t,s.coords,n,r));const a=St(s);this._writeVertices(e,t,a,n)}_writeVertices(e,t,s,i,r){const n=t.getDisplayId(),a=e.vertexCount(),o=this.hasEffects;let c=0;if(r)for(const u of r){const h=s[2*u],p=s[2*u+1];o&&e.recordBounds(h,p,0,0),this._writeVertex(e,n,h,p,i),c++}else for(let u=0;u<s.length;u+=2){const h=Math.round(s[u]),p=Math.round(s[u+1]);o&&e.recordBounds(h,p,0,0),this._writeVertex(e,n,h,p,i),c++}e.indexEnsureSize(c);for(let u=0;u<c;u++)e.indexWrite(u+a)}};const O={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:l.SHORT,count:2,packPrecisionFactor:fe,pack:({scaleInfo:e},{tileInfo:t})=>de(e,t)}},attributes:{id:{type:l.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:l.UNSIGNED_BYTE,count:1},pos:{type:l.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:l.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>B(e)}}};let Te=class extends Se{constructor(){super(...arguments),this.vertexSpec=O}createTesselationParams(e){return null}};const S={createComputedParams:e=>e,optionalAttributes:O.optionalAttributes,attributes:{...O.attributes,tlbr:{count:4,type:l.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+k,n=t.y+k;return[r,n,r+s,n+i]}},inverseRasterizationScale:{count:1,type:l.BYTE,packPrecisionFactor:16,pack:({sprite:e})=>1/e.rasterizationScale}}};let Ot=class extends Te{constructor(){super(...arguments),this.vertexSpec=S}_write(e,t,s){var a;const i=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),r=this._clip(i);if(!r)return;const n=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(e,t,r),e.recordEnd()}};function Y(e){const{sprite:t,aspectRatio:s,scaleProportionally:i}=e,r=g(e.height),n=r>0?r:t.height;let a=r*s;return a<=0?a=t.width:i&&(a*=t.width/t.height),{width:a,height:n}}function Ee(e){const{applyRandomOffset:t,sampleAlphaOnly:s}=e;return D([[Re,t],[he,s]])}const Me={createComputedParams:e=>e,optionalAttributes:S.optionalAttributes,attributes:{...S.attributes,bitset:{count:1,type:l.UNSIGNED_BYTE,pack:Ee},width:{count:1,type:l.HALF_FLOAT,pack:e=>Y(e).width},height:{count:1,type:l.HALF_FLOAT,pack:e=>Y(e).height},offset:{count:2,type:l.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[g(e),-g(t)]},scale:{count:2,type:l.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:e,scaleY:t})=>[e,t]},angle:{count:1,type:l.UNSIGNED_BYTE,pack:({angle:e})=>ze(e)}}};let cs=class extends Ot{constructor(){super(...arguments),this.vertexSpec=Me}};const Ae={createComputedParams:e=>e,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:e=>0},color:{type:l.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>B(e)}}},K={createComputedParams:e=>e,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:e=>D([[pe,!0],[Ye,e.outlineUsesColorVV]])},color:{type:l.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>B(e)}}};let j=class extends X{constructor(){super(...arguments),this.vertexSpec=K}},Le=class extends Te{constructor(e,t,s,i){super(e,t,s,i),this.vertexSpec=Ae,this._lineMeshWriter=this._createOutlineWriter(e,t,s,i)}_createOutlineWriter(e,t,s,i){return new j(e,t,s,i)}_write(e,t){const s=this.evaluatedMeshParams.effects,i=this.evaluatedMeshParams.outlineEffects;if(s!=null&&s.length||i!=null&&i.length){if(s!=null&&s.length){const r=this.getEffectCursor(e,t,s);if(r){let n;for(;n=r==null?void 0:r.next();)n.invertY(),this._writeFill(e,t,n)}}else this._writeFill(e,t);if(i!=null&&i.length){const r=this.getEffectCursor(e,t,i);if(r){let n;for(;n=r==null?void 0:r.next();)n.invertY(),this._writeOutline(e,t,n)}}else this._writeOutline(e,t)}else this._writeSimpleOutlineFill(e,t)}_writeSimpleOutlineFill(e,t){const s=t.readGeometryForDisplay(),i=this._clip(s);i&&(this._writeGeometry(e,t,i),this._lineMeshWriter.writeLineVertices(e,P.fromOptimizedCIM(i,"esriGeometryPolyline"),t))}_writeFill(e,t,s){const i=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),r=this._clip(i);r&&this._writeGeometry(e,t,r)}_writeOutline(e,t,s){const i=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),r=this._clip(i);r&&this._lineMeshWriter.writeLineVertices(e,P.fromOptimizedCIM(r,"esriGeometryPolyline"),t)}_clip(e){return e?Pe(e,xe(this.evaluatedMeshParams)):null}get effectInfos(){var e,t;return[...((e=this._evaluator.inputMeshParams.effects)==null?void 0:e.effectInfos)??[],...((t=this._evaluator.inputMeshParams.outlineEffects)==null?void 0:t.effectInfos)??[]]}write(e,t,s,i,r){this.ensurePacked(t,s,i),e.recordStart(this.instanceId,this.attributeLayout),this._write(e,s),e.recordEnd()}ensurePacked(e,t,s){super.ensurePacked(e,t,s),this._lineMeshWriter.ensurePacked(e,t,s)}enqueueRequest(e,t,s){super.enqueueRequest(e,t,s),this._lineMeshWriter.enqueueRequest(e,t,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const U=Me,Dt=K,It={createComputedParams:e=>e,optionalAttributes:U.optionalAttributes,attributes:{...U.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:e=>Ee(e)},aux1:{count:1,type:l.HALF_FLOAT,pack:e=>Y(e).width},aux2:{count:1,type:l.HALF_FLOAT,pack:e=>Y(e).height},aux3:{count:2,type:l.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[g(e),g(t)]},aux4:{count:2,type:l.UNSIGNED_BYTE,pack:({scaleX:e,scaleY:t})=>[e*z,t*z]}}},Nt={createComputedParams:e=>e,optionalAttributes:U.optionalAttributes,attributes:{...U.attributes,color:Dt.attributes.color,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:e=>D([[pe,!0]])},aux1:{count:1,type:l.HALF_FLOAT,pack:e=>g(.5*e.width)},aux2:{count:1,type:l.HALF_FLOAT,pack:e=>g(.5*e.referenceWidth)},aux3:{count:2,type:l.HALF_FLOAT,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[e,t]},aux4:{count:2,type:l.UNSIGNED_BYTE,packTessellation:({normalX:e,normalY:t})=>[e*z+te,t*z+te]}}};class zt extends j{constructor(){super(...arguments),this.vertexSpec=Nt}}class us extends Le{constructor(){super(...arguments),this.vertexSpec=It}_createOutlineWriter(t,s,i,r){return new zt(t,s,i,r)}write(t,s,i,r,n){var o;this.ensurePacked(s,i,r);const a=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._write(t,i),t.recordEnd()}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._lineMeshWriter.ensurePacked(t,s,i)}enqueueRequest(t,s,i){super.enqueueRequest(t,s,i),this._lineMeshWriter.enqueueRequest(t,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Gt=()=>ue.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Ct=class{constructor(e,t){this._size=e,this._sizeUnits=t,this._relativeSize=null}get relativeSize(){return this._relativeSize??(this._relativeSize=this.calculateRelativeSize()),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===G.Relative){const e=Math.min(this._size/100,1);return[e,e]}return this.calculateRelativeSizeFromAbsolute()}};class J extends Ct{constructor(t,s,i,r){super(s,i),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:n,rotationMatrix00:a,rotationMatrix01:o,rotationMatrix10:c,rotationMatrix11:u}=this;t.forEachVertex((h,p)=>{const d=h*a+p*o,f=h*c+p*u;n.xmin=Math.min(n.xmin,d),n.ymin=Math.min(n.ymin,f),n.xmax=Math.max(n.xmax,d),n.ymax=Math.max(n.ymax,f)}),this.center=[(n.xmin+n.xmax)/2,(n.ymin+n.ymax)/2]}}let Rt=class extends J{constructor(e,t,s,i){super(e,t,s,i),this.method="linear"}getRelativePosition(e,t){const{rotationMatrix00:s,rotationMatrix01:i,bounds:r}=this,{xmin:n,xmax:a}=r;return[(e*s+t*i-n)/(a-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:e,bounds:t}=this,{xmin:s,xmax:i}=t;return[g(e)/(i-s),0]}};class Yt extends J{constructor(t,s,i,r){super(t,s,i,r),this.method="rectangular"}getRelativePosition(t,s){const{bounds:i,center:r,rotationMatrix00:n,rotationMatrix01:a,rotationMatrix10:o,rotationMatrix11:c}=this,u=t*o+s*c,h=t*n+s*a-r[0],p=u-r[1];return[h*(2/(i.xmax-i.xmin)),-p*(2/(i.ymax-i.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:s}=this,{xmin:i,ymin:r,xmax:n,ymax:a}=s;return[g(2*t)/(n-i),g(2*t)/(a-r)]}}class Ut extends J{constructor(t,s,i){super(t,s,i,0),this.method="circular";const{xmin:r,xmax:n,ymin:a,ymax:o}=this.bounds,c=n-r,u=o-a;this.radius=Math.sqrt(c*c+u*u)/2}getRelativePosition(t,s){const{center:i,radius:r}=this;return[(t-i[0])/r,-((s-i[1])/r)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[g(t)/this.radius,0]}}function Bt(e,t){if(e==null)return null;const s=De(t.angle),i=t.gradientSize,r=t.gradientSizeUnits;switch(t.gradientMethod.toLowerCase()){case"linear":return new Rt(e,i,r,s);case"rectangular":return new Yt(e,i,r,s);case"circular":return new Ut(e,i,r);default:return Gt().errorOnce(`Gradient fill method "${t.gradientMethod}" currently unsupported.`),null}}const Vt={createComputedParams:e=>e,optionalAttributes:O.optionalAttributes,attributes:{...O.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:e,gradientType:t})=>{let s=0;return e===G.Absolute&&(s|=ae(se.isAbsolute)),t.toLowerCase()==="discrete"&&(s|=ae(se.isDiscrete)),s}},tlbr:{count:4,type:l.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+k+C,n=t.y+k;return[r,n,r+s-2*C,n+i]}},relativePosition:{count:2,type:l.HALF_FLOAT,packTessellation:({gradientStats:e},t,s,i)=>(e==null?void 0:e.getRelativePosition(s,i))??[0,0]},relativeGradientSize:{count:2,type:l.HALF_FLOAT,packTessellation:({gradientStats:e})=>(e==null?void 0:e.relativeSize)??[1,1]},gradientMethod:{count:1,type:l.UNSIGNED_BYTE,pack:({gradientMethod:e})=>{switch(e.toLowerCase()){case"rectangular":return H.rectangular;case"circular":return H.circular;default:return H.linear}}}}};let ls=class extends Se{constructor(){super(...arguments),this.vertexSpec=Vt}get _preventEffectClipping(){return!0}createTesselationParams(e){return{gradientStats:Bt(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(e,t,s){var a;const i=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay();this._unclippedGeometry=i;const r=this._clip(i);if(!r)return void(this._unclippedGeometry=null);const n=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(e,t,r),this._unclippedGeometry=null,e.recordEnd()}};const Ht={optionalAttributes:S.optionalAttributes,createComputedParams:e=>e,attributes:{...S.attributes,...Ae.attributes}},Wt={optionalAttributes:S.optionalAttributes,createComputedParams:e=>e,attributes:{...S.attributes,...K.attributes}};class Zt extends j{constructor(){super(...arguments),this.vertexSpec=Wt}}class hs extends Le{constructor(){super(...arguments),this.vertexSpec=Ht}_createOutlineWriter(t,s,i,r){return new Zt(t,s,i,r)}write(t,s,i,r,n){var o;this.ensurePacked(s,i,r);const a=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,a),this._write(t,i),t.recordEnd()}ensurePacked(t,s,i){super.ensurePacked(t,s,i),this._lineMeshWriter.ensurePacked(t,s,i)}enqueueRequest(t,s,i){super.enqueueRequest(t,s,i),this._lineMeshWriter.enqueueRequest(t,s,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const qt={createComputedParams:e=>e,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:({gradientMethod:e,gradientSizeUnits:t,gradientType:s})=>D([[V.isAlongLine,e.toLowerCase()==="alongline"],[V.isAbsoluteSize,t===G.Absolute],[V.isDiscrete,s.toLowerCase()==="discrete"]])},tlbr:{type:l.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+k+C,n=t.y+k;return[r,n,r+s-2*C,n+i]}},accumulatedDistance:{type:l.HALF_FLOAT,count:1,packTessellation:({distance:e,pathLength:t,distanceOffset:s})=>(s+e)/t},gradientSize:{type:l.HALF_FLOAT,count:1,pack:({gradientSize:e,gradientSizeUnits:t})=>t===G.Relative?e/100:g(e)},totalLength:{type:l.HALF_FLOAT,count:1,packTessellation:({pathLength:e})=>e},segmentDirection:{type:l.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]}}};let ps=class extends X{get _preventEffectClipping(){return!0}constructor(e,t,s,i){super(e,t,s,i),this.vertexSpec=qt,this._tessellationOptions.textured=!0}_write(e,t,s){const i=s??P.fromFeatureSetReaderCIM(t);if(!i)return;const{sprite:r}=this.evaluatedMeshParams;this._writeGeometry(e,t,i,r==null?void 0:r.textureBinding)}};const $t={createComputedParams:e=>e,optionalAttributes:v.optionalAttributes,attributes:{...v.attributes,bitset:{type:l.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:e,shouldScaleDash:t,isSDF:s})=>D([[he,e],[Ge,t],[Ce,s]])},tlbr:{type:l.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:i}=e,r=t.x+k,n=t.y+k;return[r,n,r+s,n+i]}},accumulatedDistance:{type:l.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},segmentDirection:{type:l.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},offsetAlongLine:{type:l.HALF_FLOAT,count:1,pack:({offsetAlongLine:e})=>g(e)},capType:{type:l.UNSIGNED_BYTE,count:1,pack:({capType:e})=>{switch(e){case"Butt":case"butt":default:return 0;case"Square":case"square":return 1;case"Round":case"round":return 2}}}}};class fs extends X{constructor(t,s,i,r){super(t,s,i,r),this.vertexSpec=$t,this._tessellationOptions.textured=!0}_write(t,s,i){const r=i??P.fromFeatureSetReaderCIM(s);if(!r)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,s,r,n==null?void 0:n.textureBinding)}}export{Pt as A,X as B,Mt as F,ls as H,cs as I,hs as K,Et as L,Ot as O,ps as Q,us as R,D as T,ge as X,Te as a,Pe as b,B as c,ae as d,fs as e,os as f,Qe as g,st as h,Le as n,de as q,Se as t,et as v};
