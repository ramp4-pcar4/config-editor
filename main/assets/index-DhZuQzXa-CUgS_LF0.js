var f=Object.defineProperty;var w=(o,t,i)=>t in o?f(o,t,{enumerable:!0,configurable:!0,writable:!0,value:i}):o[t]=i;var n=(o,t,i)=>w(o,typeof t!="symbol"?t+"":t,i);import{a_ as A,gw as u,g_ as L,g$ as $,at as g,h0 as v,h1 as H,h2 as O}from"./index-DT_2vTqg.js";import{a as c,t as M,l,s as d}from"./hilight-defs-DzKgjtLG-D-utaUCJ.js";class p extends L{constructor(i,e){super(e);n(this,"config",{});n(this,"mode",c.NONE);this.config=i,this.mode=i.mode}async add(i){this.notImplementedError("addGraphics")}async remove(i){this.notImplementedError("removeGraphics")}async reloadHilight(i){this.notImplementedError("reloadHilight")}async getHilightLayer(){const i=await this.layerFetcher();if(i){if(i.isLoaded&&i instanceof $)return i;console.warn("Hilight layer exists but is in bad form.");return}else{console.warn("Hilight layer could not be fetched.");return}}notImplementedError(i){console.warn(`Hilight mode method ${i} was not implemented by subclass.`)}layerFetcher(){const i=this.$iApi.geo.layer.getLayer(l);return i?Promise.resolve(i):new Promise(e=>{let a=0;const s=setInterval(()=>{const r=this.$iApi.geo.layer.getLayer(l);if(r)clearInterval(s),e(r);else if(a+=125,a>=1125){clearInterval(s),e(void 0);return}},125)})}}class y extends p{async add(t){const i=await this.getHilightLayer();i&&await i.addGraphic(t)}async remove(t){const i=await this.getHilightLayer();i&&i.removeGraphic(t)}async reloadHilight(t){await this.remove(t),await this.add(t)}}class G extends y{constructor(i,e){var a,s;super(i,e);n(this,"handlers",[]);n(this,"onOpacity");n(this,"offOpacity");n(this,"lastAdd",0);this.onOpacity=((a=i.options)==null?void 0:a.onOpacity)??.75,this.offOpacity=((s=i.options)==null?void 0:s.offOpacity)>.02?i.options.offOpacity:.02,this.$iApi.geo.map.created?this.hilightSetup():this.handlers.push(this.$iApi.event.on(g.MAP_CREATED,()=>{this.hilightSetup()})),this.handlers.push(this.$iApi.event.on(g.MAP_BASEMAPCHANGE,()=>{this.getHilightLayer().then(r=>{r&&r.graphics.length===0&&this.updateFogLayer()})}))}async hilightSetup(){const i=v(this.$vApp.$pinia).activeBasemapConfig;try{const e=this.$iApi.geo.layer.createLayer({id:d,layerType:u.TILE,cosmetic:!0,system:!0,url:i.layers[0].url});await this.$iApi.geo.map.addLayer(e),e.opacity=this.offOpacity,await this.reorderFogLayer()}catch{console.error("Something went wrong while setting up the hilighter.")}}async updateFogLayer(){this.$iApi.geo.map.removeLayer(d),await this.hilightSetup()}async reorderFogLayer(){const i=this.getFogLayer(),e=await this.getHilightLayer();if(!e||!i)return;const a=this.$iApi.geo.layer.layerOrderIds(),s=a.indexOf(i.id),r=a.indexOf(e.id);r<s&&r>-1&&s>-1&&this.$iApi.geo.map.reorder(e,s,!1)}async add(i){this.lastAdd=Date.now();const e=this.getFogLayer();e&&(e.opacity=this.onOpacity,await super.add(i))}async remove(i){await super.remove(i);const e=this.getFogLayer();if(!e)return;const a=Date.now(),s=await this.getHilightLayer();s&&setTimeout(()=>{this.lastAdd<a&&!s.getGraphicCount()&&(e.opacity=this.offOpacity)},300)}async reloadHilight(i){await this.updateFogLayer(),await super.reloadHilight(i)}getFogLayer(){const i=this.$iApi.geo.layer.getLayer(d);if(i&&i instanceof H)return i;console.warn("Hilight fog layer could not be fetched.")}}class m extends y{constructor(i,e){super(i,e);n(this,"handlers",[]);this.hilightSetup(i),this.handlers.push(this.$iApi.event.on(g.MAP_CREATED,()=>{this.hilightSetup(i)}))}hilightSetup(i){this.$iApi.geo.map.viewPromise.then(()=>{this.$iApi.geo.map.esriView.highlightOptions=i.options})}async add(i){await super.add(i);const e=this.$iApi.geo.layer.getLayer(l);if(e&&e.esriLayer&&e.isLoaded&&e instanceof O){const a=i instanceof Array?i:[i];await e.viewPromise(),e.esriView.highlight(a.map(s=>e.getEsriGraphic(s.id)))}}async remove(i){await super.remove(i)}}class E extends A{constructor(){super(...arguments);n(this,"hilightMode",new p({},this.$iApi))}initialized(){this.initHilightLayer()}_parseConfig(i){if(i)switch(i.mode){case c.NONE:this.hilightMode=new p(i,this.$iApi);break;case c.GLOW:this.hilightMode=new m(i,this.$iApi);break;case c.LIFT:this.hilightMode=new y(i,this.$iApi);break;case c.FOG:this.hilightMode=new G(i,this.$iApi);break;default:console.error("Could not find hilight mode:",i.mode);break}else this.hilightMode=new m(M,this.$iApi)}async initHilightLayer(){const i=this.$iApi.geo.layer.createLayer({id:l,layerType:u.GRAPHIC,cosmetic:!0,system:!0,url:""});await this.$iApi.geo.map.addLayer(i)}async addHilight(i){const e=i instanceof Array?i:[i];await this.hilightMode.add(e)}async removeHilight(i){const e=i?i instanceof Array?i:[i]:void 0;await this.hilightMode.remove(e)}async reloadHilight(i){const e=i instanceof Array?i:[i];await this.hilightMode.reloadHilight(e)}async getGraphicsByKey(i,e,a){const s=await this.getHilightLayer();if(!s)return[];let r=s.graphics.map(h=>({...this.deconstructGraphicKey(h.id),og:h}));return i&&(r=r.filter(h=>h.origin===i)),e&&(r=r.filter(h=>h.uid===e)),a&&(r=r.filter(h=>h.oid===a)),r.map(h=>h.og)}constructGraphicKey(i,e,a){return`${l}~${i}~${e}~${a}`}deconstructGraphicKey(i){const e=i.split("~");return e.length!==4&&console.warn("Malformed Hilight Graphic key provided:",i),{origin:e[1],uid:e[2],oid:parseInt(e[3])}}async getHilightLayer(){if(this.hilightMode)return await this.hilightMode.getHilightLayer();console.warn("API get layer request before highlight mode object exists")}}class x extends E{async added(){this._parseConfig(this.config);const t=this.$vApp.$watch(()=>this.config,i=>this._parseConfig(i));this.removed=()=>{t()}}}export{x as default};
