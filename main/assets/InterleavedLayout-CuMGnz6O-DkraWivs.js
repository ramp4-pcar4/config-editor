import{b as R,x as f,a as d,R as m,g as H,T as a,m as y,M as k,c,Y as E,L as w,C as T,w as g,N as v,O as b,B as Y,E as l,P as $,F as A,U as B,q as N,z as L,J as M,I as U,V as G,_ as O,Q as C,k as I,d as V,S as W,v as j,$ as q,W as J,j as K,D as P,G as Q,H as X,K as Z,X as tt,Z as et,t as rt,e as st}from"./BufferView-B6RYETl3-CMoUTBv6.js";import{c as F}from"./types-l27bT09Q-DE0QfIFp.js";import"./index-BeTPrQ6f.js";import{_ as h}from"./enums-DDJfd4_p-D3z9tmVA.js";import{c as it}from"./VertexElementDescriptor-DLvjNrmQ-Cuvx5w94.js";import{c as nt}from"./VertexAttributeLocations-DBgVVQz--D3wovAvC.js";function ht(i,t=0){const e=i.stride;return Array.from(i.fields.keys()).map(r=>{var _;const s=i.fields.get(r),n=s.constructor.ElementCount,u=ut(s.constructor.ElementType),z=s.offset,D=((_=s.optional)==null?void 0:_.glNormalized)??!1;return new it(r,n,u,z,e,D,t)})}function ut(i){switch(i){case"u8":return h.UNSIGNED_BYTE;case"u16":return h.UNSIGNED_SHORT;case"u32":return h.UNSIGNED_INT;case"i8":return h.BYTE;case"i16":return h.SHORT;case"i32":return h.INT;case"f16":return h.HALF_FLOAT;case"f32":return h.FLOAT;default:throw new Error("BufferType not supported in WebGL")}}class o{constructor(t,e){this.layout=t,this.buffer=typeof e=="number"?new ArrayBuffer(e*t.stride):e;for(const r of t.fields.keys()){const s=t.fields.get(r);this[r]=new s.constructor(this.buffer,s.offset,this.stride)}}get stride(){return this.layout.stride}get count(){return this.buffer.byteLength/this.stride}get byteLength(){return this.buffer.byteLength}getField(t,e){const r=this[t];return r&&r.elementCount===e.ElementCount&&r.elementType===e.ElementType?r:null}slice(t,e){return new o(this.layout,this.buffer.slice(t*this.stride,e*this.stride))}copyFrom(t,e=0,r=0,s=t.count){const n=this.stride;if(n%4==0){const u=new Uint32Array(t.buffer,e*n,s*n/4);new Uint32Array(this.buffer,r*n,s*n/4).set(u)}else{const u=new Uint8Array(t.buffer,e*n,s*n);new Uint8Array(this.buffer,r*n,s*n).set(u)}return this}get usedMemory(){return this.byteLength}dispose(){}}class p{constructor(t){this._stride=0,this._fields=new Map,t&&(this._stride=t.stride,t.fields.forEach(e=>this._fields.set(e[0],{...e[1],constructor:ot(e[1].constructor)})))}freeze(){return this}get locations(){return nt(ht(this))}vec2f16(t,e){return this._appendField(t,d?R:f,e),this}vec2f(t,e){return this._appendField(t,f,e),this}vec2f64(t,e){return this._appendField(t,m,e),this}vec3f16(t,e){return this._appendField(t,d?H:a,e),this}vec3f(t,e){return this._appendField(t,a,e),this}vec3f64(t,e){return this._appendField(t,y,e),this}vec4f16(t,e){return this._appendField(t,d?k:c,e),this}vec4f(t,e){return this._appendField(t,c,e),this}vec4f64(t,e){return this._appendField(t,E,e),this}mat3f(t,e){return this._appendField(t,w,e),this}mat3f64(t,e){return this._appendField(t,T,e),this}mat4f(t,e){return this._appendField(t,g,e),this}mat4f64(t,e){return this._appendField(t,v,e),this}vec4u8(t,e){return this._appendField(t,b,e),this}f16(t,e){return this._appendField(t,d?Y:l,e),this}f32(t,e){return this._appendField(t,l,e),this}f64(t,e){return this._appendField(t,$,e),this}u8(t,e){return this._appendField(t,A,e),this}u16(t,e){return this._appendField(t,B,e),this}i8(t,e){return this._appendField(t,N,e),this}vec2i8(t,e){return this._appendField(t,L,e),this}vec2i16(t,e){return this._appendField(t,M,e),this}vec2u8(t,e){return this._appendField(t,U,e),this}vec2u16(t,e){return this._appendField(t,G,e),this}vec4u16(t,e){return this._appendField(t,O,e),this}vec4i16(t,e){return this._appendField(t,C,e),this}u32(t,e){return this._appendField(t,I,e),this}_appendField(t,e,r){this._fields.has(t)&&V(!1,`${t} already added to vertex buffer layout`);const s=e.ElementCount*F(e.ElementType),n=this._stride;this._fields.set(t,{constructor:e,size:s,offset:n,optional:r}),this._alignFields()}_alignFields(){let t=0,e=1;this._fields.forEach(r=>{const s=F(r.constructor.ElementType);t=Math.floor((t+s-1)/s)*s,r.offset=t,t+=r.size,e=Math.max(e,s)}),t=Math.floor((t+e-1)/e)*e,this._stride=t}createBuffer(t){return new o(this,t)}createView(t){return new o(this,t)}clone(){const t=new p;return t._stride=this._stride,t._fields=new Map,this._fields.forEach((e,r)=>t._fields.set(r,e)),t.BufferType=this.BufferType,t}get stride(){return this._stride}get fields(){return this._fields}}function Ft(){return new p}class mt{constructor(t){this.fields=new Array,t.fields.forEach((e,r)=>{const s={...e,constructor:S(e.constructor)};this.fields.push([r,s])}),this.stride=t.stride}}const dt=[l,f,a,c,w,g,$,m,y,E,T,v,A,U,W,b,B,G,j,O,I,q,J,K,N,L,P,Q,X,M,Z,C,tt,et,rt,st];function S(i){return`${i.ElementType}_${i.ElementCount}`}function ot(i){return x.get(i)}const x=new Map;dt.forEach(i=>x.set(S(i),i));export{ht as G,Ft as h,p as o,mt as u};
