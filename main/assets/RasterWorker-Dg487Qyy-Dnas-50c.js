import{v as f,bf as p,n as u,o as l,l as d}from"./index-CQ8-0QQp.js";import{o as y}from"./GeographicTransformation-Ccb709r9-B7h4fHqa.js";import{V as i,y as S,a as x,c as h,T as O,u as N,f as J,d as v,I as k}from"./dataUtils-CfR0oe2x-BB-_-YEs.js";import{q as B,d as P,k as g,v as b}from"./RasterSymbolizer-BN6RVtx9-DcewRzCw.js";import{q as w}from"./rasterFunctionHelper-ABMN-R6n-CeG50SeL.js";import{W as z,D}from"./rasterProjectionHelper-DGqzGF1m-B4o9YpQp.js";import{y as T,d as I,c as F}from"./PolynomialTransform-XpKTtnAc-DKtjTbuv.js";import"./pixelRangeUtils-DcEknavd-CueOHV1N.js";import"./_commonjsHelpers-BITg13Vk-KnjfkSck.js";import"./colorUtils-Eg6lOlXm-7UV7YEXV.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./clipUtils-fw7VCGXU-DaiAI4fU.js";import"./colorRamps-trM-CPFS-C8zFo3rW.js";import"./Field-BIQ-quF4-kqmmAHwF.js";import"./fieldType-PhcL4ff8-X0HNaUrC.js";import"./projectionUtils-B-CplN3q-DW663dnS.js";var c;let m=c=class extends T{constructor(){super(...arguments),this.type="identity"}clone(){return new c}};f([p({IdentityXform:"identity"})],m.prototype,"type",void 0),m=c=f([u("esri.layers.support.rasterTransforms.IdentityTransform")],m);const E={GCSShiftXform:I,IdentityXform:m,PolynomialXform:F};function j(n){if(!(n!=null&&n.type))return null;const r=E[n==null?void 0:n.type];if(r){const t=new r;return t.read(n),t}return null}class rr{convertVectorFieldData(r){const t=i.fromJSON(r.pixelBlock),o=S(t,r.type);return Promise.resolve(o!=null?o.toJSON():null)}computeStatisticsHistograms(r){const t=i.fromJSON(r.pixelBlock),o=B(t);return Promise.resolve(o)}async decode(r){const t=await P(r.data,r.options);return t&&t.toJSON()}symbolize(r){r.pixelBlock=i.fromJSON(r.pixelBlock),r.extent=r.extent?l.fromJSON(r.extent):null;const t=this.symbolizer.symbolize(r);return Promise.resolve(t!=null?t.toJSON():null)}async updateSymbolizer(r){var t;this.symbolizer=g.fromJSON(r.symbolizerJSON),r.histograms&&((t=this.symbolizer)==null?void 0:t.rendererJSON.type)==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=r.histograms)}async updateRasterFunction(r){this.rasterFunction=w(r.rasterFunctionJSON)}async process(r){var o;const t=this.rasterFunction.process({extent:l.fromJSON(r.extent),primaryPixelBlocks:r.primaryPixelBlocks.map(s=>s!=null?i.fromJSON(s):null),primaryPixelSizes:(o=r.primaryPixelSizes)==null?void 0:o.map(s=>s!=null?d.fromJSON(s):null),primaryRasterIds:r.primaryRasterIds});return t!=null?t.toJSON():null}stretch(r){const t=this.symbolizer.simpleStretch(i.fromJSON(r.srcPixelBlock),r.stretchParams);return Promise.resolve(t==null?void 0:t.toJSON())}estimateStatisticsHistograms(r){const t=b(i.fromJSON(r.srcPixelBlock));return Promise.resolve(t)}split(r){const t=x(i.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel??0,r.useBilinear===!1);return t&&t.forEach((o,s)=>{t.set(s,o==null?void 0:o.toJSON())}),Promise.resolve(t)}clipTile(r){const t=i.fromJSON(r.pixelBlock),o=h({...r,pixelBlock:t});return Promise.resolve(o==null?void 0:o.toJSON())}async mosaicAndTransform(r){const t=r.srcPixelBlocks.map(a=>a?new i(a):null),o=O(t,r.srcMosaicSize,{blockWidths:r.blockWidths,alignmentInfo:r.alignmentInfo,clipOffset:r.clipOffset,clipSize:r.clipSize});let s,e=o;return r.coefs&&(e=N(o,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation)),r.projectDirections&&r.gcsGrid&&(s=J(r.destDimension,r.gcsGrid),e=v(e,r.isUV?"vector-uv":"vector-magdir",s)),{pixelBlock:e==null?void 0:e.toJSON(),localNorthDirections:s}}async createFlowMesh(r,t){const o={data:new Float32Array(r.flowData.buffer),mask:new Uint8Array(r.flowData.maskBuffer),width:r.flowData.width,height:r.flowData.height},{vertexData:s,indexData:e}=await k(r.meshType,r.simulationSettings,o,t.signal);return{result:{vertexBuffer:s.buffer,indexBuffer:e.buffer},transferList:[s.buffer,e.buffer]}}async getProjectionOffsetGrid(r){var a;const t=l.fromJSON(r.projectedExtent),o=l.fromJSON(r.srcBufferExtent);let s=null;(a=r.datumTransformationSteps)!=null&&a.length&&(s=new y({steps:r.datumTransformationSteps})),await z();const e=r.rasterTransform?j(r.rasterTransform):null;return D({...r,projectedExtent:t,srcBufferExtent:o,datumTransformation:s,rasterTransform:e})}}export{rr as default};
