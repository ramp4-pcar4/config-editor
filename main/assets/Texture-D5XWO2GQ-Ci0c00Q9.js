import{an as Z,h as T,ao as J,u as X,aM as Q,a6 as L}from"./index-JysQxb7m.js";import{M as f,F as E,Y as B,G as d,U as ee,V as F,c as W,u as g,B as te,H as n,E as O,n as H,s as D,X as re,I as ie}from"./enums-wEDHPbCF-Cf76M5_x.js";import{a as se}from"./getDataTypeBytes-DYbftOSj-BNZIboqJ.js";const ae=()=>L.getLogger("esri.views.webgl.checkWebGLError");function oe(r){switch(r){case D.INVALID_ENUM:return"Invalid Enum. An unacceptable value has been specified for an enumerated argument.";case D.INVALID_VALUE:return"Invalid Value. A numeric argument is out of range.";case D.INVALID_OPERATION:return"Invalid Operation. The specified command is not allowed for the current state.";case D.INVALID_FRAMEBUFFER_OPERATION:return"Invalid Framebuffer operation. The currently bound framebuffer is not framebuffer complete when trying to render to or to read from it.";case D.OUT_OF_MEMORY:return"Out of memory. Not enough memory is left to execute the command.";case D.CONTEXT_LOST_WEBGL:return"WebGL context has been lost";default:return"Unknown error"}}const z=!!Z("enable-feature:webgl-debug");function $(){return z}function Re(){return z}function b(r,e=$()){if(e){const t=r.getError();if(t){const i=oe(t),s=new Error().stack;ae().error(new T("webgl-error","WebGL error occurred",{message:i,stack:s}))}}}var C;(function(r){r[r.TextureDescriptor=0]="TextureDescriptor",r[r.Texture=1]="Texture",r[r.Renderbuffer=2]="Renderbuffer"})(C||(C={}));function ne(r){const e=r.gl;switch(e.getError()){case e.NO_ERROR:return null;case e.INVALID_ENUM:return"An unacceptable value has been specified for an enumerated argument";case e.INVALID_VALUE:return"An unacceptable value has been specified for an argument";case e.INVALID_OPERATION:return"The specified command is not allowed for the current state";case e.INVALID_FRAMEBUFFER_OPERATION:return"The currently bound framebuffer is not framebuffer complete";case e.OUT_OF_MEMORY:return"Not enough memory is left to execute the command";case e.CONTEXT_LOST_WEBGL:return"WebGL context is lost"}return"Unknown error"}function ge(r,e,t,i,s=0){var l;const c=r.gl;r.bindBuffer(t);for(const o of i){const a=e.get(o.name);if(a==null){console.warn(`There is no location for vertex attribute '${o.name}' defined.`);continue}const p=s*o.stride;if(o.count<=4)c.vertexAttribPointer(a,o.count,o.type,o.normalized,o.stride,o.offset+p),c.enableVertexAttribArray(a),o.divisor>0&&r.gl.vertexAttribDivisor(a,o.divisor);else if(o.count===9)for(let h=0;h<3;h++)c.vertexAttribPointer(a+h,3,o.type,o.normalized,o.stride,o.offset+12*h+p),c.enableVertexAttribArray(a+h),o.divisor>0&&r.gl.vertexAttribDivisor(a+h,o.divisor);else if(o.count===16)for(let h=0;h<4;h++)c.vertexAttribPointer(a+h,4,o.type,o.normalized,o.stride,o.offset+16*h+p),c.enableVertexAttribArray(a+h),o.divisor>0&&((l=r.gl)==null||l.vertexAttribDivisor(a+h,o.divisor));else console.error("Unsupported vertex attribute element count: "+o.count);if($()){const h=ne(r),u=se(o.type),m=o.offset,R=Math.round(u/m)!==u/m?`. Offset not a multiple of stride. DataType requires ${u} bytes, but descriptor has an offset of ${m}`:"";h&&console.error(`Unable to bind vertex attribute "${o.name}" with baseInstanceOffset ${p}${R}:`,h,o)}}}function Ae(r,e,t,i){var c,l,o;const s=r.gl;r.bindBuffer(t);for(const a of i){const p=e.get(a.name);if(a.count<=4)s.disableVertexAttribArray(p),a.divisor&&a.divisor>0&&((c=r.gl)==null||c.vertexAttribDivisor(p,0));else if(a.count===9)for(let h=0;h<3;h++)s.disableVertexAttribArray(p+h),a.divisor&&a.divisor>0&&((l=r.gl)==null||l.vertexAttribDivisor(p+h,0));else if(a.count===16)for(let h=0;h<4;h++)s.disableVertexAttribArray(p+h),a.divisor&&a.divisor>0&&((o=r.gl)==null||o.vertexAttribDivisor(p+h,0));else console.error("Unsupported vertex attribute element count: "+a.count)}r.unbindBuffer(ie.ARRAY_BUFFER)}function ce(r){switch(r){case E.ALPHA:case E.LUMINANCE:case E.RED:case E.RED_INTEGER:case n.R8:case n.R8I:case n.R8UI:case n.R8_SNORM:case re.STENCIL_INDEX8:return 1;case E.LUMINANCE_ALPHA:case E.RG:case E.RG_INTEGER:case n.RGBA4:case n.R16F:case n.R16I:case n.R16UI:case n.RG8:case n.RG8I:case n.RG8UI:case n.RG8_SNORM:case n.RGB565:case n.RGB5_A1:case F.DEPTH_COMPONENT16:return 2;case E.RGB:case E.RGB_INTEGER:case n.RGB8:case n.RGB8I:case n.RGB8UI:case n.RGB8_SNORM:case n.SRGB8:case F.DEPTH_COMPONENT24:return 3;case E.RGBA:case E.RGBA_INTEGER:case n.RGBA8:case n.R32F:case n.R11F_G11F_B10F:case n.RG16F:case n.R32I:case n.R32UI:case n.RG16I:case n.RG16UI:case n.RGBA8I:case n.RGBA8UI:case n.RGBA8_SNORM:case n.SRGB8_ALPHA8:case n.RGB9_E5:case n.RGB10_A2UI:case n.RGB10_A2:case F.DEPTH_COMPONENT32F:case O.DEPTH24_STENCIL8:return 4;case O.DEPTH32F_STENCIL8:return 5;case n.RGB16F:case n.RGB16I:case n.RGB16UI:return 6;case n.RG32F:case n.RG32I:case n.RG32UI:case n.RGBA16F:case n.RGBA16I:case n.RGBA16UI:return 8;case n.RGB32F:case n.RGB32I:case n.RGB32UI:return 12;case n.RGBA32F:case n.RGBA32I:case n.RGBA32UI:return 16;case g.COMPRESSED_RGB_S3TC_DXT1_EXT:case g.COMPRESSED_RGBA_S3TC_DXT1_EXT:return .5;case g.COMPRESSED_RGBA_S3TC_DXT3_EXT:case g.COMPRESSED_RGBA_S3TC_DXT5_EXT:return 1;case g.COMPRESSED_R11_EAC:case g.COMPRESSED_SIGNED_R11_EAC:case g.COMPRESSED_RGB8_ETC2:case g.COMPRESSED_SRGB8_ETC2:case g.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case g.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:return .5;case g.COMPRESSED_RG11_EAC:case g.COMPRESSED_SIGNED_RG11_EAC:case g.COMPRESSED_RGBA8_ETC2_EAC:case g.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return 1}return 0}let le=class{constructor(r=0,e=r){this.width=r,this.height=e,this.type=C.TextureDescriptor,this.target=f.TEXTURE_2D,this.pixelFormat=E.RGBA,this.dataType=B.UNSIGNED_BYTE,this.samplingMode=d.LINEAR,this.wrapMode=ee.REPEAT,this.maxAnisotropy=1,this.flipped=!1,this.hasMipmap=!1,this.isOpaque=!1,this.unpackAlignment=4,this.preMultiplyAlpha=!1,this.compareEnabled=!1,this.linearFilterDepth=!1,this.depth=1,this.isImmutable=!1}};function he(r){return r.width<=0||r.height<=0||r.depth<=0?0:Math.round(r.width*r.height*r.depth*(r.hasMipmap?4/3:1)*(r.internalFormat==null?4:ce(r.internalFormat))*(r.target===f.TEXTURE_CUBE_MAP?6:1))}const P=()=>L.getLogger("esri/views/webgl/textureUtils");function U(r){const{width:e,height:t,depth:i}=r;(e!=null&&e<0||t!=null&&t<0||i!=null&&i<0)&&P().error("Negative dimension parameters are not allowed!");const{internalFormat:s}=r;if(s&&(Y(s)||K(s))){const{linearFilterDepth:c,compareEnabled:l,samplingMode:o,hasMipmap:a}=r;a&&P().error("Depth textures cannot have mipmaps"),c?o!==d.LINEAR&&o!==d.NEAREST&&P().error("Depth textures cannot sample mipmaps"):(o!==d.NEAREST&&P().error("Depth textures without filtering must use NEAREST filtering"),l&&P().error("Depth textures without filtering cannot use compare function"))}}function pe(r){return r in n}function Y(r){return r in F}function K(r){return r in O}function ue(r){return r!=null&&r in g}function w(r){return r!=null&&"type"in r&&r.type==="compressed"}function de(r){return r!=null&&"byteLength"in r}function V(r){return r!=null&&!w(r)&&!de(r)}function S(r){return r===f.TEXTURE_3D||r===f.TEXTURE_2D_ARRAY}function k(r,e,t,i=1){let s=Math.max(e,t);return r===f.TEXTURE_3D&&(s=Math.max(s,i)),Math.floor(Math.log2(s))+1}function G(r){if(r.internalFormat!=null)return r.internalFormat;switch(r.dataType){case B.FLOAT:switch(r.pixelFormat){case E.RGBA:return n.RGBA32F;case E.RGB:return n.RGB32F;default:throw new T("texture:unknown-format","Unable to derive format")}case B.UNSIGNED_BYTE:switch(r.pixelFormat){case E.RGBA:return n.RGBA8;case E.RGB:return n.RGB8}}const{pixelFormat:e}=r;return r.internalFormat=e===H.DEPTH_STENCIL?O.DEPTH24_STENCIL8:e===H.DEPTH_COMPONENT?F.DEPTH_COMPONENT24:e,r.internalFormat}function me(r){let e="width"in r?r.width:r.codedWidth,t="height"in r?r.height:r.codedHeight;return r instanceof HTMLVideoElement&&(e=r.videoWidth,t=r.videoHeight),{width:e,height:t,depth:1}}class v extends le{constructor(e,t){switch(super(),this.context=e,Object.assign(this,t),this.internalFormat){case n.R16F:case n.R32F:case n.R8_SNORM:case n.R8:this.pixelFormat=E.RED;break;case n.R8I:case n.R8UI:case n.R16I:case n.R16UI:case n.R32I:case n.R32UI:this.pixelFormat=E.RED_INTEGER}}static validate(e,t){return new v(e,t)}}const M=()=>L.getLogger("esri/views/webgl/Texture");var _;let xe=(_=class{constructor(e,t=null,i=null){if(this.type=C.Texture,this._glName=null,this._samplingModeDirty=!1,this._wrapModeDirty=!1,this._shadowFilterDirty=!1,this._wasImmutablyAllocated=!1,"context"in e)this._descriptor=e,i=t;else{const s=v.validate(e,t);if(!s)throw new T("texture:invalid-descriptor","Texture descriptor invalid");this._descriptor=s}this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(i):this.setData(i)}get glName(){return this._glName}get descriptor(){return this._descriptor}get usedMemory(){return he(this._descriptor)}get cachedMemory(){return this.usedMemory}get isDirty(){return this._samplingModeDirty||this._wrapModeDirty||this._shadowFilterDirty}get hasWebGLTextureObject(){return!!this._glName}dispose(){this.abortCompression(),this._descriptor.context.gl&&this.hasWebGLTextureObject&&(this._descriptor.context.instanceCounter.decrement(W.Texture,this),this._descriptor.context.unbindTexture(this),this._descriptor.context.gl.deleteTexture(this._glName),this._glName=null)}release(){this.dispose()}resize(e,t){const i=this._descriptor;if(i.width!==e||i.height!==t){if(this._wasImmutablyAllocated)throw new T("texture:immutable-resize","Immutable textures can't be resized!");i.width=e,i.height=t,this._descriptor.target===f.TEXTURE_CUBE_MAP?this._setDataCubeMap(null):this.setData(null)}}enableCompression(e){this._descriptor.compress=e}disableCompression(){this._descriptor.compress=void 0}setData(e){this.abortCompression(),!w(e)&&this._descriptor.internalFormat&&this._descriptor.internalFormat in g&&(this._descriptor.internalFormat=void 0),this._setData(e),!w(e)&&this._descriptor.compress&&this._compressOnWorker(e)}updateData(e,t,i,s,c,l,o=0){l||M().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||M().error("An attempt to update uninitialized texture!");const a=this._descriptor;a.internalFormat=G(a);const{context:p,pixelFormat:h,dataType:u,target:m,isImmutable:R}=a;if(R&&!this._wasImmutablyAllocated)throw new T("texture:uninitialized","Cannot update immutable texture before allocation!");const x=p.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES,!0);(t<0||i<0||t+s>a.width||i+c>a.height)&&M().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:A}=p;o&&(s&&c||M().warn("Must pass width and height if `UNPACK_SKIP_ROWS` is used"),A.pixelStorei(A.UNPACK_SKIP_ROWS,o)),V(l)?A.texSubImage2D(m,e,t,i,s,c,h,u,l):w(l)?A.compressedTexSubImage2D(m,e,t,i,s,c,a.internalFormat,l.levels[e]):A.texSubImage2D(m,e,t,i,s,c,h,u,l),o&&A.pixelStorei(A.UNPACK_SKIP_ROWS,0),p.bindTexture(x,_.TEXTURE_UNIT_FOR_UPDATES)}updateData3D(e,t,i,s,c,l,o,a){a||M().error("An attempt to use uninitialized data!"),this.hasWebGLTextureObject||M().error("An attempt to update an uninitialized texture!");const p=this._descriptor;p.internalFormat=G(p);const{context:h,pixelFormat:u,dataType:m,isImmutable:R,target:x}=p;if(R&&!this._wasImmutablyAllocated)throw new T("texture:uninitialized","Cannot update immutable texture before allocation!");S(x)||M().warn("Attempting to set 3D texture data on a non-3D texture");const A=h.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);h.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),(t<0||i<0||s<0||t+c>p.width||i+l>p.height||s+o>p.depth)&&M().error("An attempt to update out of bounds of the texture!"),this._configurePixelStorage();const{gl:N}=h;if(w(a))a=a.levels[e],N.compressedTexSubImage3D(x,e,t,i,s,c,l,o,p.internalFormat,a);else{const I=a;N.texSubImage3D(x,e,t,i,s,c,l,o,u,m,I)}h.bindTexture(A,_.TEXTURE_UNIT_FOR_UPDATES)}generateMipmap(){const e=this._descriptor;if(e.width===0||e.height===0)return;if(!e.hasMipmap){if(this._wasImmutablyAllocated)throw new T("texture:immutable-change","Cannot add mipmaps to immutable texture after allocation");e.hasMipmap=!0,this._samplingModeDirty=!0,U(e)}e.samplingMode===d.LINEAR?(this._samplingModeDirty=!0,e.samplingMode=d.LINEAR_MIPMAP_NEAREST):e.samplingMode===d.NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=d.NEAREST_MIPMAP_NEAREST);const t=this._descriptor.context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);this._descriptor.context.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),this._descriptor.context.gl.generateMipmap(e.target),this._descriptor.context.bindTexture(t,_.TEXTURE_UNIT_FOR_UPDATES)}clearMipmap(){const e=this._descriptor;if(e.hasMipmap){if(this._wasImmutablyAllocated)throw new T("texture:immutable-change","Cannot delete mipmaps to immutable texture after allocation");e.hasMipmap=!1,this._samplingModeDirty=!0,U(e)}e.samplingMode===d.LINEAR_MIPMAP_NEAREST?(this._samplingModeDirty=!0,e.samplingMode=d.LINEAR):e.samplingMode===d.NEAREST_MIPMAP_NEAREST&&(this._samplingModeDirty=!0,e.samplingMode=d.NEAREST)}setSamplingMode(e){e!==this._descriptor.samplingMode&&(this._descriptor.samplingMode=e,this._samplingModeDirty=!0)}setWrapMode(e){e!==this._descriptor.wrapMode&&(this._descriptor.wrapMode=e,U(this._descriptor),this._wrapModeDirty=!0)}setShadowFiltering(e){e!==this._descriptor.linearFilterDepth&&(this._descriptor.linearFilterDepth=this._descriptor.compareEnabled=e,this.setSamplingMode(e?d.LINEAR:d.NEAREST),U(this._descriptor),this._shadowFilterDirty=!0)}applyChanges(){this._samplingModeDirty&&(this._applySamplingMode(),this._samplingModeDirty=!1),this._wrapModeDirty&&(this._applyWrapMode(),this._wrapModeDirty=!1),this._shadowFilterDirty&&(this._applyShadowMode(),this._shadowFilterDirty=!1)}abortCompression(){this._compressionAbortController=J(this._compressionAbortController)}_setData(e,t){var a;const i=this._descriptor,s=(a=i.context)==null?void 0:a.gl;if(!s)return;b(s),this.hasWebGLTextureObject||(this._glName=s.createTexture(),i.context.instanceCounter.increment(W.Texture,this)),U(i);const c=i.context.bindTexture(this,_.TEXTURE_UNIT_FOR_UPDATES);i.context.setActiveTexture(_.TEXTURE_UNIT_FOR_UPDATES),this._configurePixelStorage(),b(s);const l=t??i.target,o=S(l);if(V(e))this._setDataFromTexImageSource(e,l);else{const{width:p,height:h,depth:u}=i;if(p==null||h==null)throw new T("texture:missing-size","Width and height must be specified!");if(o&&u==null)throw new T("texture:missing-depth","Depth must be specified!");if(i.internalFormat=G(i),i.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(l,i.internalFormat,i.hasMipmap,p,h,u),w(e)){if(!ue(i.internalFormat))throw new T("texture:format-mismatch","Attempting to use compressed data with an uncompressed format!");this._setDataFromCompressedSource(e,i.internalFormat,l)}else this._texImage(l,0,i.internalFormat,p,h,u,e),b(s),i.hasMipmap&&this.generateMipmap()}this._applySamplingMode(),this._applyWrapMode(),this._applyAnisotropicFilteringParameters(),this._applyShadowMode(),b(s),i.context.bindTexture(c,_.TEXTURE_UNIT_FOR_UPDATES)}_setDataCubeMap(e=null){for(let t=f.TEXTURE_CUBE_MAP_POSITIVE_X;t<=f.TEXTURE_CUBE_MAP_NEGATIVE_Z;t++)this._setData(e,t)}_configurePixelStorage(){const e=this._descriptor.context.gl,{unpackAlignment:t,flipped:i,preMultiplyAlpha:s}=this._descriptor;e.pixelStorei(e.UNPACK_ALIGNMENT,t),e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL,i?1:0),e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,s?1:0)}_setDataFromTexImageSource(e,t){const{gl:i}=this._descriptor.context,s=this._descriptor;s.internalFormat=G(s);const c=S(t),{width:l,height:o,depth:a}=me(e);s.width&&s.height,s.width||(s.width=l),s.height||(s.height=o),c&&s.depth,c&&(s.depth=a),s.isImmutable&&!this._wasImmutablyAllocated&&this._texStorage(t,s.internalFormat,s.hasMipmap,l,o,a),this._texImage(t,0,s.internalFormat,l,o,a,e),b(i),s.hasMipmap&&(this.generateMipmap(),b(i))}_setDataFromCompressedSource(e,t,i){const s=this._descriptor,{width:c,height:l,depth:o}=s,a=e.levels,p=k(i,c,l,o),h=Math.min(p,a.length)-1;this._descriptor.context.gl.texParameteri(s.target,te.MAX_LEVEL,h),this._forEachMipmapLevel((u,m,R,x)=>{const A=a[Math.min(u,a.length-1)];this._compressedTexImage(i,u,t,m,R,x,A)},h)}_texStorage(e,t,i,s,c,l){const{gl:o}=this._descriptor.context;if(!pe(t)&&!Y(t)&&!K(t))throw new T("texture:missing-format","Immutable textures must have a sized internal format");if(!this._descriptor.isImmutable)return;const a=i?k(e,s,c,l):1;if(S(e)){if(l==null)throw new T("texture:missing-depth","Missing depth dimension for 3D texture upload");o.texStorage3D(e,a,t,s,c,l)}else o.texStorage2D(e,a,t,s,c);this._wasImmutablyAllocated=!0}_texImage(e,t,i,s,c,l,o){const a=this._descriptor.context.gl,p=S(e),{isImmutable:h,pixelFormat:u,dataType:m}=this._descriptor;if(h){if(o!=null){const R=o;if(p){if(l==null)throw new T("texture:missing-depth","Missing depth dimension for 3D texture upload");a.texSubImage3D(e,t,0,0,0,s,c,l,u,m,R)}else a.texSubImage2D(e,t,0,0,s,c,u,m,R)}}else{const R=o;if(p){if(l==null)throw new T("texture:missing-depth","Missing depth dimension for 3D texture upload");a.texImage3D(e,t,i,s,c,l,0,u,m,R)}else a.texImage2D(e,t,i,s,c,0,u,m,R)}}_compressedTexImage(e,t,i,s,c,l,o){const a=this._descriptor.context.gl,p=S(e);if(this._descriptor.isImmutable){if(o!=null)if(p){if(l==null)throw new T("texture:missing-depth","Missing depth dimension for 3D texture upload");a.compressedTexSubImage3D(e,t,0,0,0,s,c,l,i,o)}else a.compressedTexSubImage2D(e,t,0,0,s,c,i,o)}else if(p){if(l==null)throw new T("texture:missing-depth","Missing depth dimension for 3D texture upload");a.compressedTexImage3D(e,t,i,s,c,l,0,o)}else a.compressedTexImage2D(e,t,i,s,c,0,o)}async _compressOnWorker(e){var R,x,A,N;const{width:t,height:i,context:s,flipped:c,preMultiplyAlpha:l,hasMipmap:o}=this._descriptor,a=(R=this._descriptor.compress)==null?void 0:R.compressionTracker,p=(x=this._descriptor.compress)==null?void 0:x.compressionCallback,{compressedTextureETC:h,compressedTextureS3TC:u}=s.capabilities;if(!((A=_.compressionWorkerHandle)!=null&&A.isCompressible(e,this._descriptor))||!h&&!u)return;this.abortCompression();const m=new AbortController;this._compressionAbortController=m,a==null||a.increment();try{let I;e instanceof Uint8Array?I=e.buffer:(I=await createImageBitmap(e,{imageOrientation:c?"flipY":"none"}),X(m));const j={data:I,width:t,height:i,needsFlip:e instanceof Uint8Array&&this.descriptor.flipped,components:this._descriptor.pixelFormat===E.RGBA?4:3,preMultiplyAlpha:l,hasMipmap:o,hasETC:!!h,hasS3TC:!!u},y=await _.compressionWorkerHandle.invoke(j,m.signal,"low");if(X(m),y.compressedTexture&&this.hasWebGLTextureObject){const q=this.usedMemory;this._descriptor.internalFormat=y.internalFormat,this._setData(y.compressedTexture),p==null||p(q-this.usedMemory)}}catch(I){Q(I)||M().error("Texture compression failed!")}finally{a==null||a.decrement(),(N=this._compressionAbortController)!=null&&N.signal.aborted&&(this._compressionAbortController=null)}}_forEachMipmapLevel(e,t=1/0){let{width:i,height:s,depth:c,hasMipmap:l,target:o}=this._descriptor;const a=o===f.TEXTURE_3D;if(i==null||s==null||a&&c==null)throw new T("texture:missing-size","Missing texture dimensions for mipmap calculation");for(let p=0;e(p,i,s,c),l&&(i!==1||s!==1||a&&c!==1)&&!(p>=t);++p)i=Math.max(1,i>>1),s=Math.max(1,s>>1),a&&(c=Math.max(1,c>>1))}_applySamplingMode(){var c;const e=this._descriptor,t=(c=e.context)==null?void 0:c.gl;let i=e.samplingMode,s=e.samplingMode;i===d.LINEAR_MIPMAP_NEAREST||i===d.LINEAR_MIPMAP_LINEAR?(i=d.LINEAR,e.hasMipmap||(s=d.LINEAR)):i!==d.NEAREST_MIPMAP_NEAREST&&i!==d.NEAREST_MIPMAP_LINEAR||(i=d.NEAREST,e.hasMipmap||(s=d.NEAREST)),t.texParameteri(e.target,t.TEXTURE_MAG_FILTER,i),t.texParameteri(e.target,t.TEXTURE_MIN_FILTER,s)}_applyWrapMode(){var i;const e=this._descriptor,t=(i=e.context)==null?void 0:i.gl;typeof e.wrapMode=="number"?(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode)):(t.texParameteri(e.target,t.TEXTURE_WRAP_S,e.wrapMode.s),t.texParameteri(e.target,t.TEXTURE_WRAP_T,e.wrapMode.t))}_applyShadowMode(){var s;const e=this._descriptor,t=(s=e.context)==null?void 0:s.gl,i=e.compareEnabled?t.COMPARE_REF_TO_TEXTURE:t.NONE;t.texParameteri(e.target,t.TEXTURE_COMPARE_MODE,i),e.compareEnabled&&t.texParameteri(e.target,t.TEXTURE_COMPARE_FUNC,t.GREATER),b(t)}_applyAnisotropicFilteringParameters(){const e=this._descriptor,t=e.context.capabilities.textureFilterAnisotropic;t&&e.context.gl.texParameterf(e.target,t.TEXTURE_MAX_ANISOTROPY,e.maxAnisotropy??1)}},_.TEXTURE_UNIT_FOR_UPDATES=0,_.compressionWorkerHandle=null,_);export{v as C,b as I,$ as L,C as N,le as Y,xe as _,ge as c,ne as k,Ae as l,Re as n,Y as v,ce as z};
