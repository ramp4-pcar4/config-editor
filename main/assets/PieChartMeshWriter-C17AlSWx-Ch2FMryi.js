const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-DUmg2EKv-0SLd_4VN.js","./geometryEngineBase-BcMV6k0z-DS0IsP1z.js","./_commonjsHelpers-BITg13Vk-KnjfkSck.js","./json-BI97KiBB-Ce5cWfI2.js"])))=>i.map(i=>d[i]);
import{f8 as y,an as Pe,ad as jt,h as be,a6 as Jt,J as Yt,jq as we,ay as Te,_ as Me,jc as Ee}from"./index-DRDU_nTl.js";import{K as st,n as P,t as lt,J as ut,d as Ae,$ as ze,_ as De,r as Ie,c as Fe}from"./definitions-MCCItX4r-o3EUznKY.js";import{H as yt,N as gt,O as A,E as Bt,f as G}from"./UpdateTracking2D-GEad80KZ-Bv69YlIw.js";import{D as u}from"./enums-wEDHPbCF-Cf76M5_x.js";import{F as Le,D as Kt,d as te}from"./GeometryUtils-B8e3Iwyx-Dtp5Za2L.js";import{g as ee,D as Ne,B as ht,C as Ct,m as Oe,G as se,k as Ye,q as Be,u as Ce,f as Ge}from"./constants-oLcGh8d3-CJuD0gcX.js";import{M as pt,P as X,o as ie,i as _t,h as kt,t as St}from"./enums-a_LDTPYU-CBIcy3mM.js";import{D as Re,X as Ue,z as I,t as We,S as He,B as Xe,a as Gt,b as Rt,T as Ut}from"./CIMSymbolHelper-34UsTwam-DkYGvg0X.js";import{U as Ve,B as qe,D as Ze}from"./libtess-C6mGekL8-DyIeq9bg.js";import{j as re,W as $e,K as Qe,V as je}from"./Utils-Co3xiu1z-BxeuuqeG.js";import{d as ne}from"./utils-BfXZnjCE-SvVDBGfQ.js";import"./earcut-C6NeZYSh-Da0ULCQ5.js";import{c as Je}from"./OptimizedGeometry-pzfNw1AT-ML0atVKH.js";import{x as Ke,q as ts,_ as es}from"./mat2d-BQA-1WB--Pnyy0dhf.js";import{u as ss}from"./mat2df32-fg3OHsAI-BF2V2zqo.js";import{L as rt}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{$ as nt}from"./rasterizingUtils-1wASRzSP-a77rXvQA.js";let oe=class{static getPlacement(e,t,s,r,i,n){const o=Xe(s);return o?(t===-1&&e.invertY(),o.execute(e,s,r,i,n)):null}};const is=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),rs=0,ns=100;function Z(e,t){return[!!(e!=null&&e.minScale)&&t.scaleToZoom(e.minScale)||rs,!!(e!=null&&e.maxScale)&&t.scaleToZoom(e.maxScale)||ns]}function w(e){return 1<<e}function $(e){let t=0;for(const[s,r]of e)r&&(t|=1<<s);return t}function _(e){let t;if(!e)return[0,0,0,0];if(typeof e=="string"){const o=jt.fromString(e);if(!o)return is().errorOnce(new be("mapview:mesh-processing","Unable to parse string into color",{color:e})),[0,0,0,0];t=o.toArray()}else t=e;const[s,r,i,n]=t;return[s*(n/255),r*(n/255),i*(n/255),n]}function os(e){switch(e){case"butt":case X.Butt:return _t.BUTT;case"round":case X.Round:return _t.ROUND;case"square":case X.Square:return _t.SQUARE}}function as(e){switch(e){case"bevel":case kt.Bevel:return St.BEVEL;case"miter":case kt.Miter:return St.MITER;case"round":case kt.Round:return St.ROUND}}function vt(e,t){return Math.round(Math.min(Math.sqrt(e*t),255))}function ot(e,t){return Math.round(e*t)/t}const cs=96/72;let ls=class{static executeEffects(e,t,s,r,i){const n=cs,o=Gt(e);let a=new Ut(t);for(const c of e){const l=Rt(c);l&&(a=l.execute(a,c,n,s,r,o,i))}return a}static applyEffects(e,t,s){if(!e)return t;const r=Gt(e);let i,n=new Ut(I.fromJSONCIM(t));for(const c of e){const l=Rt(c);l&&(n=l.execute(n,c,1,null,s,r,!1))}const o=[];let a=null;for(;i=n.next();)o.push(...we(i)),a=i.geometryType;return o.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:o}:{paths:o}}},ae=null;function Dt(){return ae}async function us(){ae=await Me(()=>import("./geometryEngineJSON-DUmg2EKv-0SLd_4VN.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then(e=>e.g)}function ce(e){switch(e){case u.BYTE:case u.UNSIGNED_BYTE:return 1;case u.SHORT:case u.UNSIGNED_SHORT:case u.HALF_FLOAT:return 2;case u.FLOAT:case u.INT:case u.UNSIGNED_INT:return 4}}function hs(e){const t=[],s=[],r=[];for(const i of e){const n=ce(i.type)*i.count;switch(n%2||n%4||4){case 4:t.push(i);continue;case 2:s.push(i);continue;case 1:r.push(i);continue;default:throw new Error("Found unexpected dataType byte count")}}return t.push(...s),t.push(...r),t}let ps=class le{static fromVertexSpec(t,s){const{attributes:r,optionalAttributes:i}=t;let n,o,a;const c=[];for(const x in r){if(r[x].otherSource)continue;const g=r[x];g.pack==="position"?n={...g,name:x,offset:0}:g.pack==="id"?o={...g,name:x,offset:4}:x==="bitset"?a={...g,name:x,offset:7}:c.push({...g,name:x})}for(const x in i)if(s[x]===!0){const g=i[x];c.push({...g,name:x})}const l=hs(c),h=[];let p=8,m=1;for(const x of l)h.push({...x,offset:p}),p+=ce(x.type)*x.count,x.packAlternating&&(m=Math.max(x.packAlternating.count,m));const f=Uint32Array.BYTES_PER_ELEMENT,d=p%f;return new le(n,o,a,h,p+(d?f-d:0),m)}constructor(t,s,r,i,n,o){this.position=t,this.id=s,this.bitset=r,this.standardAttributes=i,this.stride=n,this.packVertexCount=o,i.push(r),this._attributes=[t,s,r,...i]}get attributeLayout(){if(!this._attributeLayout){const t=Qe(this._attributes),s=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:s,hash:t,stride:this.stride}}return this._attributeLayout}},fs=class ue{static fromVertexSpec(t,s){const r=ps.fromVertexSpec(t,s);return new ue(r)}constructor(t){this._spec=t,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(t,s,r,i,n,o){var a;for(let c=0;c<this._spec.packVertexCount;c++){const l=c*this._spec.stride;this._packPosition(r,i,l),this._packId(s,l);const h=this._spec.bitset;if(o){if(h.packTessellation){const p=h.packTessellation(o,n,r,i);this._pack(p,h,l)}for(const p of this._spec.standardAttributes)if(p.packTessellation!=null){const m=p.packTessellation(o,n,r,i);this._pack(m,p,l)}else if((a=p.packAlternating)!=null&&a.packTessellation){const m=p.packAlternating.packTessellation(o,n,r,i);for(let f=0;f<this._spec.packVertexCount;f++){const d=m[f];this._pack(d,p,f*this._spec.stride)}}}}t.vertexWriteRegion(this._packedU32View)}pack(t,s){var r;for(const i of this._spec.standardAttributes)if(i.pack&&typeof i.pack!="string"){const n=i.pack(t,s);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(n,i,o*this._spec.stride)}else if((r=i.packAlternating)!=null&&r.pack){const n=i.packAlternating.pack(t,s);for(let o=0;o<this._spec.packVertexCount;o++){const a=n[o];this._pack(a,i,o*this._spec.stride)}}}_packPosition(t,s,r){const{offset:i}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=je(t*n,s*n);this._dataView.setUint32(r+i,o,!0)}_packId(t,s){const r=t*(this._spec.id.packPrecisionFactor??1),i=4278190080&this._dataView.getUint32(s+this._spec.id.offset,!0);this._dataView.setUint32(s+this._spec.id.offset,r|i,!0)}_pack(t,s,r){$e(this._dataView,t,s,r)}};function ds(e){if(!e)return!1;for(const t of e)switch(t.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectDonut":case"CIMGeometricEffectOffset":case"CIMGeometricEffectTaperedPolygon":case"CIMGeometricEffectEnclosingPolygon":return!0}return!1}let U=class{constructor(e,t,s,r){this._instanceId=e,this._evaluator=t,this._enabledOptionalAttributes=s,this._viewParams=r,this._evaluator.evaluator=i=>this.vertexSpec.createComputedParams(i)}get _vertexPack(){if(!this._cachedVertexPack){const e=fs.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||e.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=e}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get effectInfos(){var e;return(e=this._evaluator.inputMeshParams.effects)==null?void 0:e.effectInfos}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(e){this._references=e}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){ds(this.effectInfos)&&await us()}enqueueRequest(e,t,s){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(e,t,s)}write(e,t,s,r,i){this.ensurePacked(t,s,r);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(e,s,void 0,i);const o=this.getEffectCursor(e,s,n);if(!o)return;let a;for(;a=o.next();)a.invertY(),this._write(e,s,a,i)}ensurePacked(e,t,s){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(e,t,s);this._vertexPack.pack(r,this._viewParams)}hasArcadeDependency(e){return this._evaluator.hasArcadeDependency(e)}_writeVertex(e,t,s,r,i){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(e,t,s,r,n,i)}getEffectCursor(e,t,s){var a;const r=(a=t.readGeometryForDisplay())==null?void 0:a.clone();if(!r)return;const i=I.fromOptimizedCIM(r,t.geometryType),n=Dt();i.invertY();const o=e.id||"";return ls.executeEffects(s,i,o,n,this._preventEffectClipping)}},$i=class extends U{};function ms(e){const{sprite:t,isMapAligned:s,colorLocked:r,scaleSymbolsProportionally:i,isStroke:n}=e;let o=0;return s&&(o|=w(A.bitset.isMapAligned)),r&&(o|=w(A.bitset.colorLocked)),t.sdf&&(o|=w(A.bitset.isSDF)),i&&(o|=w(A.bitset.scaleSymbolsProportionally)),n&&(o|=w(A.bitset.isStroke)),o}function he(e,t){let s;if(typeof e=="string")s=Ee(e+`-seed(${t})`);else{let r=12;s=e^t;do s=107*(s>>8^s)+r|0;while(--r!==0)}return(1+s/(1<<31))/2}function xs(e){return Math.floor(he(e,ys)*gs)}const ys=53290320,gs=10;function xt(e){return e instanceof it?e:typeof e=="object"&&"type"in e?vs[e.type].hydrate(e):new V(e)}let it=class{constructor(e){this.inputs=e}encode(){const e=[];for(const t of this.inputs)e.push(...t.encode());return e.push(...this.instructions),e}},V=class extends it{constructor(e){super([]),this.value=e}simplify(){return this}get instructions(){if(Array.isArray(this.value)){const[e,t,s,r]=this.value;return r!=null?G.vector4.encode([e,t||0,s||0,r]):G.vector3.encode([e,t||0,s||0])}return G.scalar.encode(this.value)}},_s=class Pt extends it{constructor(t,s){super([s]),this._config=t,this._parent=s}static hydrate(t){return new Pt(t,xt(t.parent))}simplify(){if(this._config.relativeTranslation||this._config.absoluteScale)return this;const t=this._parent.simplify();if(!(t instanceof V))return this;const[s,r,i,n]=t.value,o=this._config.translation.from[0],a=this._config.translation.from[1],c=this._config.rotation.from,l=this._config.scale.from;if(o===this._config.translation.to[0]&&a===this._config.translation.to[1]&&c===this._config.rotation.to&&l===this._config.scale.to){const h=i+c,p=n*l,m=Math.sin(i),f=Math.cos(i);return new V([f*n*o-m*n*a+s,m*n*o+f*n*a+r,h,p])}return new Pt(this._config,t)}get instructions(){return G.animatedTransform.encode(this._config)}},ks=class bt extends it{constructor(t,s){super([s]),this._config=t,this._parent=s}static hydrate(t){return new bt(t,xt(t.parent))}simplify(){const t=this._parent.simplify();if(!(t instanceof V))return this;const[s,r,i,n]=t.value,o=this._config.color.from[0],a=this._config.color.from[1],c=this._config.color.from[2];let l=this._config.color.from[3];const h=this._config.opacity.from;return o===this._config.color.to[0]&&a===this._config.color.to[1]&&c===this._config.color.to[2]&&l===this._config.color.to[3]&&h===this._config.opacity.to?(l*=h,new V([s*o,r*a,i*c,n*l])):new bt(this._config,t)}get instructions(){return G.animatedColor.encode(this._config)}},Ss=class wt extends it{constructor(t,s){super([s]),this._config=t,this._parent=s}static hydrate(t){return new wt(t,xt(t.parent))}simplify(){const t=this._parent.simplify();return t instanceof V?new wt(this._config,t):this}get instructions(){return G.animatedShift.encode(this._config)}};const vs={AnimatedTransform:_s,AnimatedColor:ks,AnimatedShift:Ss};function Qi(e){return Ps(e.map(t=>v(t)).map(t=>xt(t).simplify()))}function ji(e){const t=[];return t.push(e.transform),t.push(e.fromColor),t.push(e.toColor),t.push(e.colorMix),t.push(e.toOpacity),t.push(e.opacityMix),e!=null&&e.shift?t.push(e==null?void 0:e.shift):t.push([1,1,1,1]),t}function Ps(e){const t=[],s=[];let r=0;for(const i of e){const n=[...i.encode(),...G.ret.encode()];t.push([r+e.length,0,0,0]),s.push(...n),r+=n.length}return[...t,...s]}async function Wt(e,t){const s=e;let r;if(typeof s=="number"||typeof s=="string"||typeof s=="boolean")r=s;else if(Array.isArray(s))r=await Promise.all(s.map(i=>Wt(i,t)));else if(typeof s=="object")if("valueExpressionInfo"in s){const{valueExpressionInfo:i}=s,{expression:n}=i;r={...s,computed:await t.createComputedField({expression:n})}}else{r={};for(const i in s)r[i]=await Wt(s[i],t)}return r}function v(e,t,s){function r(o){if(!("computed"in o))return o;let a=o.computed.readWithDefault(t,s,[255*o.defaultValue[0],255*o.defaultValue[1],255*o.defaultValue[2],o.defaultValue[3]]);if(typeof a=="string"){const c=jt.fromString(a);c&&(a=[c.r,c.g,c.b,c.a])}return a}const i=e;let n;if(typeof i=="number"||typeof i=="string"||typeof i=="boolean")n=i;else if(Array.isArray(i))n=i.map(o=>v(o,t,s));else if(typeof i=="object")if("type"in i&&i.type!=null&&i.type==="Process")switch(i.op){case"ArcadeColor":{const o=v(i.value,t,s);Q(Array.isArray(o)&&o.length===4),n=[o[0]/255,o[1]/255,o[2]/255,o[3]]}break;case"Transparency":{const o=v(i.value,t,s);Q(typeof o=="number"),n=1-o/100}break;case"Divide":case"Multiply":case"Add":{const o=v(i.left,t,s);Q(typeof o=="number");const a=v(i.right,t,s);switch(Q(typeof a=="number"),i.op){case"Divide":n=o/a;break;case"Multiply":n=o*a;break;case"Add":n=o+a}}break;case"Random":{const o=v(i.seed,t,s),a=v(i.min,t,s),c=v(i.max,t,s),l=t.getObjectId(),h=xs(l||0);n=a+he(h,o)*(c-a)}break;case"Cond":{const o=v(i.condition,t,s),a=v(i.ifTrue,t,s),c=v(i.ifFalse,t,s);n=o?a:c}break;case"MatchWinding":{const o=v(i.sign,t,s);let a=v(i.angle,t,s);if(o>0)for(;a<0;)a+=2*Math.PI;else for(;a>0;)a-=2*Math.PI;n=a}}else if("computed"in i)n=r(i);else{n={};for(const o in i)n[o]=v(i[o],t,s)}return n}function*b(e){const t=e;if(Array.isArray(t))for(const s of t)yield*b(s);else if(typeof t=="object")if("type"in t&&t.type!=null&&t.type==="Process")switch(t.op){case"ArcadeColor":case"Transparency":yield*b(t.value);break;case"Divide":case"Multiply":case"Add":yield*b(t.left),yield*b(t.right);break;case"Random":yield*b(t.seed),yield*b(t.min),yield*b(t.max);break;case"Cond":yield*b(t.condition),yield*b(t.ifTrue),yield*b(t.ifFalse);break;case"MatchWinding":yield*b(t.sign),yield*b(t.angle)}else if("computed"in t)yield t.computed;else for(const s in t)yield*b(t[s])}function Q(e){if(!e)throw new Error("Assertion failed.")}const Ji={type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:e},{tileInfo:t})=>Z(e,t)},Ki={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:({value1Position2Value2:e})=>(Q(e),e)},tr={type:u.FLOAT,count:4,packPrecisionFactor:1,packTessellation:()=>[0,0,0,1]},er={type:u.FLOAT,count:1,packPrecisionFactor:1,pack:()=>0},sr={type:u.FLOAT,count:1,packPrecisionFactor:1,packTessellation:({lineLength:e})=>e},ir={type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},rr={type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},nr={type:u.FLOAT,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[e,t]},or={type:u.UNSIGNED_BYTE,count:3,pack:"id"},ar={type:u.UNSIGNED_BYTE,count:1,pack:ms},cr={type:u.SHORT,count:2,pack:"position",packPrecisionFactor:1},lr={marker:{type:u.FLOAT,count:2,packAlternating:{count:4,pack:({texelDimensions:e})=>[[-.5*e[0],-.5*e[1]],[.5*e[0],-.5*e[1]],[-.5*e[0],.5*e[1]],[.5*e[0],.5*e[1]]]}},line:{type:u.FLOAT,count:2,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t},{baseSize:s})=>[e*s/2,t*s/2]},fill:{type:u.FLOAT,count:2,packTessellation:()=>[0,0]}},ur={marker:{type:u.SHORT,count:2,packPrecisionFactor:1,packAlternating:{count:4,packTessellation:({texXmax:e,texXmin:t,texYmax:s,texYmin:r})=>[[t,r],[e,r],[t,s],[e,s]]}}},hr={type:u.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:r}=e,i=t.x+P,n=t.y+P;return[i+1,n+1,i+s-1,n+r-1]}},pr={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:4,pack:({animations:e,baseSize:t,referenceSize:s})=>[e.dataColumn,e.dataRow,t,s]},fr={type:u.UNSIGNED_SHORT,count:4,packPrecisionFactor:8,pack:({strokeWidth:e,pixelDimensions:t,baseSize:s,sprite:r,sizeRatio:i})=>{const n=Math.max(s*r.width/r.height,s),o=r.sdfDecodeCoeff*n*i;return[t[0],t[1],e,o]}},dr={type:u.BYTE,count:1,packTessellation:({angle:e})=>e};function bs(e,t,s,r,i,n,o){Et=0;const a=(r-s)*n,c=i&&i.length,l=c?(i[0]-s)*n:a;let h,p,m,f,d,x=pe(t,s,r,0,l,n,!0);if(x&&x.next!==x.prev){if(c&&(x=Es(t,s,r,i,x,n)),a>80*n){h=m=t[0+s*n],p=f=t[1+s*n];for(let g=n;g<l;g+=n){const S=t[g+s*n],M=t[g+1+s*n];h=Math.min(h,S),p=Math.min(p,M),m=Math.max(m,S),f=Math.max(f,M)}d=Math.max(m-h,f-p),d=d!==0?1/d:0}J(x,e,n,h,p,d,o,0)}}function pe(e,t,s,r,i,n,o){let a;if(o===Fs(e,t,s,r,i,n)>0)for(let c=r;c<i;c+=n)a=Ht(c+t*n,e[c+t*n],e[c+1+t*n],a);else for(let c=i-n;c>=r;c-=n)a=Ht(c+t*n,e[c+t*n],e[c+1+t*n],a);return a&&C(a,a.next)&&(K(a),a=a.next),a}function j(e,t=e){if(!e)return e;let s,r=e;do if(s=!1,r.steiner||!C(r,r.next)&&k(r.prev,r,r.next)!==0)r=r.next;else{if(K(r),r=t=r.prev,r===r.next)break;s=!0}while(s||r!==t);return t}function J(e,t,s,r,i,n,o,a){if(!e)return;!a&&n&&(e=fe(e,r,i,n));let c=e;for(;e.prev!==e.next;){const l=e.prev,h=e.next;if(n?Ts(e,r,i,n):ws(e))t.push(l.index/s+o),t.push(e.index/s+o),t.push(h.index/s+o),K(e),e=h.next,c=h.next;else if((e=h)===c){a?a===1?J(e=Ns(e,t,s,o),t,s,r,i,n,o,2):a===2&&Os(e,t,s,r,i,n,o):J(j(e),t,s,r,i,n,o,1);break}}}function ws(e){const t=e.prev,s=e,r=e.next;if(k(t,s,r)>=0)return!1;let i=e.next.next;const n=i;let o=0;for(;i!==e.prev&&(o===0||i!==n);){if(o++,H(t.x,t.y,s.x,s.y,r.x,r.y,i.x,i.y)&&k(i.prev,i,i.next)>=0)return!1;i=i.next}return!0}function Ts(e,t,s,r){const i=e.prev,n=e,o=e.next;if(k(i,n,o)>=0)return!1;const a=i.x<n.x?i.x<o.x?i.x:o.x:n.x<o.x?n.x:o.x,c=i.y<n.y?i.y<o.y?i.y:o.y:n.y<o.y?n.y:o.y,l=i.x>n.x?i.x>o.x?i.x:o.x:n.x>o.x?n.x:o.x,h=i.y>n.y?i.y>o.y?i.y:o.y:n.y>o.y?n.y:o.y,p=Tt(a,c,t,s,r),m=Tt(l,h,t,s,r);let f=e.prevZ,d=e.nextZ;for(;f&&f.z>=p&&d&&d.z<=m;){if(f!==e.prev&&f!==e.next&&H(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0||(f=f.prevZ,d!==e.prev&&d!==e.next&&H(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0))return!1;d=d.nextZ}for(;f&&f.z>=p;){if(f!==e.prev&&f!==e.next&&H(i.x,i.y,n.x,n.y,o.x,o.y,f.x,f.y)&&k(f.prev,f,f.next)>=0)return!1;f=f.prevZ}for(;d&&d.z<=m;){if(d!==e.prev&&d!==e.next&&H(i.x,i.y,n.x,n.y,o.x,o.y,d.x,d.y)&&k(d.prev,d,d.next)>=0)return!1;d=d.nextZ}return!0}function Ht(e,t,s,r){const i=q.create(e,t,s);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function K(e){e.next.prev=e.prev,e.prev.next=e.next,e.prevZ&&(e.prevZ.nextZ=e.nextZ),e.nextZ&&(e.nextZ.prevZ=e.prevZ)}function Ms(e){let t=e,s=e;do(t.x<s.x||t.x===s.x&&t.y<s.y)&&(s=t),t=t.next;while(t!==e);return s}function Es(e,t,s,r,i,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const l=pe(e,t,s,r[a]*n,a<c-1?r[a+1]*n:s*n,n,!1);l===l.next&&(l.steiner=!0),o.push(Ms(l))}o.sort(Ls);for(const a of o)i=As(a,i);return i}function As(e,t){const s=zs(e,t);if(!s)return t;const r=me(s,e);return j(r,r.next),j(s,s.next)}function zs(e,t){let s=t;const r=e.x,i=e.y;let n,o=-1/0;do{if(i<=s.y&&i>=s.next.y&&s.next.y!==s.y){const m=s.x+(i-s.y)*(s.next.x-s.x)/(s.next.y-s.y);if(m<=r&&m>o){if(o=m,m===r){if(i===s.y)return s;if(i===s.next.y)return s.next}n=s.x<s.next.x?s:s.next}}s=s.next}while(s!==t);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,l=n.y;let h,p=1/0;for(s=n.next;s!==a;)r>=s.x&&s.x>=c&&r!==s.x&&H(i<l?r:o,i,c,l,i<l?o:r,i,s.x,s.y)&&(h=Math.abs(i-s.y)/(r-s.x),(h<p||h===p&&s.x>n.x)&&tt(s,e)&&(n=s,p=h)),s=s.next;return n}function fe(e,t,s,r){let i;for(;i!==e;i=i.next){if(i=i||e,i.z===null&&(i.z=Tt(i.x,i.y,t,s,r)),i.prev.next!==i||i.next.prev!==i)return i.prev.next=i,i.next.prev=i,fe(e,t,s,r);i.prevZ=i.prev,i.nextZ=i.next}return e.prevZ.nextZ=null,e.prevZ=null,Ds(e)}function Ds(e){let t,s=1;for(;;){let r,i=e;e=null,t=null;let n=0;for(;i;){n++,r=i;let o=0;for(;o<s&&r;o++)r=r.nextZ;let a=s;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?i.z<=r.z?(c=i,i=i.nextZ,o--):(c=r,r=r.nextZ,a--):(c=i,i=i.nextZ,o--),t?t.nextZ=c:e=c,c.prevZ=t,t=c}i=r}if(t.nextZ=null,s*=2,n<2)return e}}function k(e,t,s){return(t.y-e.y)*(s.x-t.x)-(t.x-e.x)*(s.y-t.y)}function de(e,t,s,r){return!!(C(e,t)&&C(s,r)||C(e,r)&&C(s,t))||k(e,t,s)>0!=k(e,t,r)>0&&k(s,r,e)>0!=k(s,r,t)>0}function Is(e,t){let s=e;do{if(s.index!==e.index&&s.next.index!==e.index&&s.index!==t.index&&s.next.index!==t.index&&de(s,s.next,e,t))return!0;s=s.next}while(s!==e);return!1}function Fs(e,t,s,r,i,n){let o=0;for(let a=r,c=i-n;a<i;a+=n)o+=(e[c+t*n]-e[a+t*n])*(e[a+1+t*n]+e[c+1+t*n]),c=a;return o}function H(e,t,s,r,i,n,o,a){return(i-o)*(t-a)-(e-o)*(n-a)>=0&&(e-o)*(r-a)-(s-o)*(t-a)>=0&&(s-o)*(n-a)-(i-o)*(r-a)>=0}function tt(e,t){return k(e.prev,e,e.next)<0?k(e,t,e.next)>=0&&k(e,e.prev,t)>=0:k(e,t,e.prev)<0||k(e,e.next,t)<0}function Tt(e,t,s,r,i){return(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-s)*i)|e<<8))|e<<4))|e<<2))|e<<1))|(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-r)*i)|t<<8))|t<<4))|t<<2))|t<<1))<<1}function C(e,t){return e.x===t.x&&e.y===t.y}function Ls(e,t){return e.x-t.x}function Ns(e,t,s,r){let i=e;do{const n=i.prev,o=i.next.next;!C(n,o)&&de(n,i,i.next,o)&&tt(n,o)&&tt(o,n)&&(t.push(n.index/s+r),t.push(i.index/s+r),t.push(o.index/s+r),K(i),K(i.next),i=e=o),i=i.next}while(i!==e);return i}function Os(e,t,s,r,i,n,o){let a=e;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&Ys(a,c)){let l=me(a,c);return a=j(a,a.next),l=j(l,l.next),J(a,t,s,r,i,n,o,0),void J(l,t,s,r,i,n,o,0)}c=c.next}a=a.next}while(a!==e)}function Ys(e,t){return e.next.index!==t.index&&e.prev.index!==t.index&&!Is(e,t)&&tt(e,t)&&tt(t,e)&&Bs(e,t)}function Bs(e,t){let s=e,r=!1;const i=(e.x+t.x)/2,n=(e.y+t.y)/2;do s.y>n!=s.next.y>n&&s.next.y!==s.y&&i<(s.next.x-s.x)*(n-s.y)/(s.next.y-s.y)+s.x&&(r=!r),s=s.next;while(s!==e);return r}function me(e,t){const s=q.create(e.index,e.x,e.y),r=q.create(t.index,t.x,t.y),i=e.next,n=t.prev;return e.next=t,t.prev=e,s.next=i,i.prev=s,r.next=s,s.prev=r,n.next=r,r.prev=n,r}class q{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(t,s,r){const i=Et<Mt.length?Mt[Et++]:new q;return i.index=t,i.x=s,i.y=r,i.prev=null,i.next=null,i.z=null,i.prevZ=null,i.nextZ=null,i.steiner=!1,i}}const Mt=[],Cs=8096;let Et=0;for(let e=0;e<Cs;e++)Mt.push(new q);const Gs=1e-5,B=new Kt(0,0,0,1,0),At=new Kt(0,0,0,1,0);function Xt(e,t,s){let r=0;for(let i=1;i<s;i++){const n=e[2*(t+i-1)],o=e[2*(t+i-1)+1];r+=(e[2*(t+i)]-n)*(e[2*(t+i)+1]+o)}return r}function Rs(e,t,s,r,i){let n=0;const o=2;for(let a=s;a<r;a+=3){const c=(e[a]-i)*o,l=(e[a+1]-i)*o,h=(e[a+2]-i)*o;n+=Math.abs((t[c]-t[h])*(t[l+1]-t[c+1])-(t[c]-t[l])*(t[h+1]-t[c+1]))}return n}function Us(e,t){const{coords:s,lengths:r}=t,i=0,n=e;let o=0;for(let a=0;a<r.length;){let c=a,l=r[a],h=Xt(s,o,l);const p=[];for(;++c<r.length;){const x=r[c],g=Xt(s,o+l,x);if(!(g>0))break;h+=g,p.push(o+l),l+=x}const m=n.length;bs(n,s,o,o+l,p,2,i);const f=Rs(n,s,m,n.length,i),d=Math.abs(h);if(Math.abs((f-d)/Math.max(1e-7,d))>Gs)return n.length=0,!1;a=c,o+=l}return!0}function Ws(e){const{coords:t,lengths:s}=e,{buffer:r}=Ze(t,s);return r}function Hs(e,t,s){let r=0;for(let i=0;i<e.lengths.length;i++){const n=e.lengths[i];for(let o=0;o<n;o++){const a=e.coords[2*(o+r)],c=e.coords[2*(o+r)+1];if(a<t||a>s||c<t||c>s)return!0}r+=n}return!1}function xe(e,t){if(e==null)return null;if(!Hs(e,-128,lt+128))return e;B.setPixelMargin(t),B.reset(te.Polygon);let s=0;for(let o=0;o<e.lengths.length;o++){const a=e.lengths[o];let c=e.coords[2*(0+s)],l=e.coords[2*(0+s)+1];B.moveTo(c,l);for(let h=1;h<a;h++)c=e.coords[2*(h+s)],l=e.coords[2*(h+s)+1],B.lineTo(c,l);B.close(),s+=a}const r=B.result(!1);if(!r)return null;const i=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;i.push(a)}return new Je(i,n)}function Xs(e,t){At.setPixelMargin(t);const s=At,r=-t,i=lt+t;let n=[],o=!1;if(!e.nextPath())return null;let a=e.pathLength(),c=!0;for(;c;){e.seekPathStart();const l=[];if(!e.pathSize)return null;s.reset(te.LineString),e.nextPoint();let h=e.x,p=e.y;if(o)s.moveTo(h,p);else{if(h<r||h>i||p<r||p>i){o=!0;continue}l.push({x:h,y:p})}let m=!1;for(;e.nextPoint();)if(h=e.x,p=e.y,o)s.lineTo(h,p);else{if(h<r||h>i||p<r||p>i){m=!0;break}l.push({x:h,y:p})}if(m)o=!0;else{if(o){const f=s.resultWithStarts();if(f)for(const d of f)n.push({...d,pathLength:a})}else n.push({line:l,start:0,pathLength:a});c=e.nextPath(),a=c?e.pathLength():0,o=!1}}return n=n.filter(l=>l.line.length>1),n.length===0?null:n}B.setExtent(lt),At.setExtent(lt);let Vs=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0,this.distanceOffset=0,this.lineLength=0}};const F={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:e},{tileInfo:t})=>Z(e,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:u.UNSIGNED_BYTE,count:1},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>_(e)},offset:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[ot(e,16),ot(t,16)]},normal:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:e,normalY:t})=>[ot(e,16),ot(t,16)]},halfWidth:{type:u.HALF_FLOAT,count:1,pack:({width:e})=>y(.5*e)},referenceHalfWidth:{type:u.HALF_FLOAT,count:1,pack:({referenceWidth:e})=>y(.5*e)}}};let qs=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0,this.distanceOffset=0}};const at=65535;let It=class extends U{constructor(e,t,s,r){super(e,t,s,r),this.vertexSpec=F,this._currentWrite=new qs,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:at,textured:!1},this._tessParams=new Vs,this._initializeTessellator()}writeLineVertices(e,t,s){const r=this._getLines(t);r!=null&&this._writeVertices(e,s,r)}_initializeTessellator(){this._lineTessellator=new Ve(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(e,t,s){const r=s??I.fromFeatureSetReaderCIM(t);r&&this._writeGeometry(e,t,r)}_writeGeometry(e,t,s,r){e.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(e,s,t),e.recordEnd()}_getLines(e){return Xs(e,re(this.evaluatedMeshParams))}_writeVertices(e,t,s){const{_currentWrite:r,_tessellationOptions:i,evaluatedMeshParams:n}=this,{width:o,capType:a,joinType:c,miterLimit:l,hasSizeVV:h}=n,p=y(.5*o);i.halfWidth=p,i.capType=os(a),i.joinType=as(c),i.miterLimit=l;const m=!h;r.out=e,r.id=t.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=e.vertexCount(),r.vertexBounds=m&&p<Ae?0:1;for(const{line:f,start:d,pathLength:x}of s)i.initialDistance=d%at,r.pathLength=x,r.distanceOffset=Math.floor(d/at)*at,this._lineTessellator.tessellate(f,i,m)}_writeTesselatedVertex(e,t,s,r,i,n,o,a,c,l,h){const{out:p,id:m,vertexBounds:f,pathLength:d,distanceOffset:x}=this._currentWrite;return this.hasEffects&&p.recordBounds(e,t,f,f),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=l,this._tessParams.directionX=i,this._tessParams.directionY=n,this._tessParams.distance=h,this._tessParams.pathLength=d,this._tessParams.distanceOffset=x,this._writeVertex(p,m,e,t,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,t,s){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(t),r.indexWrite(s),this._currentWrite.indexCount+=3}};const Zs=100,$s=Pe("featurelayer-fast-triangulation-enabled");let Ft=class extends U{async loadDependencies(){await Promise.all([super.loadDependencies(),qe()])}_write(e,t,s){const r=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),i=this._clip(r);i&&(e.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(e,t,i),e.recordEnd())}_clip(e){if(!e)return null;const t=this.hasEffects;return xe(e,t?256:8)}_writeGeometry(e,t,s){const r=s.maxLength>Zs,i=[],n=this.createTesselationParams(t);if(!r&&$s&&Us(i,s))return void(i.length&&this._writeVertices(e,t,s.coords,n,i));const o=Ws(s);this._writeVertices(e,t,o,n)}_writeVertices(e,t,s,r,i){const n=t.getDisplayId(),o=e.vertexCount(),a=this.hasEffects;let c=0;if(i)for(const l of i){const h=s[2*l],p=s[2*l+1];a&&e.recordBounds(h,p,0,0),this._writeVertex(e,n,h,p,r),c++}else for(let l=0;l<s.length;l+=2){const h=Math.round(s[l]),p=Math.round(s[l+1]);a&&e.recordBounds(h,p,0,0),this._writeVertex(e,n,h,p,r),c++}e.indexEnsureSize(c);for(let l=0;l<c;l++)e.indexWrite(l+o)}};const Qs={createComputedParams:e=>e,optionalAttributes:{},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:u.FLOAT,count:1,packTessellation:({inverseArea:e})=>e}}};let mr=class extends Ft{constructor(){super(...arguments),this.vertexSpec=Qs}createTesselationParams(e){return{inverseArea:1/e.readGeometryArea()}}};const et={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:e},{tileInfo:t})=>Z(e,t)}},attributes:{id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>_(e)}}};let ye=class extends Ft{constructor(){super(...arguments),this.vertexSpec=et}createTesselationParams(e){return null}};const R={createComputedParams:e=>e,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:s,height:r}=e,i=t.x+P,n=t.y+P;return[i,n,i+s,n+r]}},inverseRasterizationScale:{count:1,type:u.BYTE,packPrecisionFactor:16,pack:({sprite:e})=>1/e.rasterizationScale}}};let js=class extends ye{constructor(){super(...arguments),this.vertexSpec=R}_write(e,t,s){var o;const r=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay(),i=this._clip(r);if(!i)return;const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(e,t,i),e.recordEnd()}};function ft(e){const{sprite:t,aspectRatio:s,scaleProportionally:r}=e,i=y(e.height),n=i>0?i:t.height;let o=i*s;return o<=0?o=t.width:r&&(o*=t.width/t.height),{width:o,height:n}}function ge(e){const{applyRandomOffset:t,sampleAlphaOnly:s}=e;return $([[Oe,t],[se,s]])}const _e={createComputedParams:e=>e,optionalAttributes:R.optionalAttributes,attributes:{...R.attributes,bitset:{count:1,type:u.UNSIGNED_BYTE,pack:ge},width:{count:1,type:u.HALF_FLOAT,pack:e=>ft(e).width},height:{count:1,type:u.HALF_FLOAT,pack:e=>ft(e).height},offset:{count:2,type:u.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),-y(t)]},scale:{count:2,type:u.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:e,scaleY:t})=>[e,t]},angle:{count:1,type:u.UNSIGNED_BYTE,pack:({angle:e})=>Le(e)}}};let xr=class extends js{constructor(){super(...arguments),this.vertexSpec=_e}};const ke={createComputedParams:e=>e,optionalAttributes:F.optionalAttributes,attributes:{...F.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:e=>0},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>_(e)}}},Lt={createComputedParams:e=>e,optionalAttributes:F.optionalAttributes,attributes:{...F.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:e=>$([[ee,!0],[Ne,e.outlineUsesColorVV]])},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>_(e)}}};let Nt=class extends It{constructor(){super(...arguments),this.vertexSpec=Lt}},Se=class extends ye{constructor(t,s,r,i){super(t,s,r,i),this.vertexSpec=ke,this._lineMeshWriter=this._createOutlineWriter(t,s,r,i)}_createOutlineWriter(t,s,r,i){return new Nt(t,s,r,i)}_write(t,s){const r=this.evaluatedMeshParams.effects,i=this.evaluatedMeshParams.outlineEffects;if(r!=null&&r.length||i!=null&&i.length){if(r!=null&&r.length){const n=this.getEffectCursor(t,s,r);if(n){let o;for(;o=n==null?void 0:n.next();)o.invertY(),this._writeFill(t,s,o)}}else this._writeFill(t,s);if(i!=null&&i.length){const n=this.getEffectCursor(t,s,i);if(n){let o;for(;o=n==null?void 0:n.next();)o.invertY(),this._writeOutline(t,s,o)}}else this._writeOutline(t,s)}else this._writeSimpleOutlineFill(t,s)}_writeSimpleOutlineFill(t,s){const r=s.readGeometryForDisplay(),i=this._clip(r);i&&(this._writeGeometry(t,s,i),this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(i,"esriGeometryPolyline"),s))}_writeFill(t,s,r){const i=(r==null?void 0:r.asOptimized())??s.readGeometryForDisplay(),n=this._clip(i);n&&this._writeGeometry(t,s,n)}_writeOutline(t,s,r){const i=(r==null?void 0:r.asOptimized())??s.readGeometryForDisplay(),n=this._clip(i);n&&this._lineMeshWriter.writeLineVertices(t,I.fromOptimizedCIM(n,"esriGeometryPolyline"),s)}_clip(t){return t?xe(t,re(this.evaluatedMeshParams)):null}get effectInfos(){var t,s;return[...((t=this._evaluator.inputMeshParams.effects)==null?void 0:t.effectInfos)??[],...((s=this._evaluator.inputMeshParams.outlineEffects)==null?void 0:s.effectInfos)??[]]}write(t,s,r,i,n){this.ensurePacked(s,r,i),t.recordStart(this.instanceId,this.attributeLayout),this._write(t,r),t.recordEnd()}ensurePacked(t,s,r){super.ensurePacked(t,s,r),this._lineMeshWriter.ensurePacked(t,s,r)}enqueueRequest(t,s,r){super.enqueueRequest(t,s,r),this._lineMeshWriter.enqueueRequest(t,s,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}get hasEffects(){return!!this.evaluatedMeshParams.outlineEffects}};const dt=_e,Js=Lt,Ks={createComputedParams:e=>e,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:e=>ge(e)},aux1:{count:1,type:u.HALF_FLOAT,pack:e=>ft(e).width},aux2:{count:1,type:u.HALF_FLOAT,pack:e=>ft(e).height},aux3:{count:2,type:u.HALF_FLOAT,pack:({offsetX:e,offsetY:t})=>[y(e),y(t)]},aux4:{count:2,type:u.UNSIGNED_BYTE,pack:({scaleX:e,scaleY:t})=>[e*ht,t*ht]}}},ti={createComputedParams:e=>e,optionalAttributes:dt.optionalAttributes,attributes:{...dt.attributes,color:Js.attributes.color,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:e=>$([[ee,!0]])},aux1:{count:1,type:u.HALF_FLOAT,pack:e=>y(.5*e.width)},aux2:{count:1,type:u.HALF_FLOAT,pack:e=>y(.5*e.referenceWidth)},aux3:{count:2,type:u.HALF_FLOAT,packTessellation:({extrusionOffsetX:e,extrusionOffsetY:t})=>[e,t]},aux4:{count:2,type:u.UNSIGNED_BYTE,packTessellation:({normalX:e,normalY:t})=>[e*ht+Ct,t*ht+Ct]}}};let ei=class extends Nt{constructor(){super(...arguments),this.vertexSpec=ti}};class gr extends Se{constructor(){super(...arguments),this.vertexSpec=Ks}_createOutlineWriter(t,s,r,i){return new ei(t,s,r,i)}write(t,s,r,i,n){var a;this.ensurePacked(s,r,i);const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,o),this._write(t,r),t.recordEnd()}ensurePacked(t,s,r){super.ensurePacked(t,s,r),this._lineMeshWriter.ensurePacked(t,s,r)}enqueueRequest(t,s,r){super.enqueueRequest(t,s,r),this._lineMeshWriter.enqueueRequest(t,s,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const si=()=>Jt.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let ii=class{constructor(e,t){this._size=e,this._sizeUnits=t,this._relativeSize=null}get relativeSize(){return this._relativeSize??(this._relativeSize=this.calculateRelativeSize()),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===pt.Relative){const e=Math.min(this._size/100,1);return[e,e]}return this.calculateRelativeSizeFromAbsolute()}},Ot=class extends ii{constructor(e,t,s,r){super(t,s),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:i,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this;e.forEachVertex((l,h)=>{const p=l*n+h*o,m=l*a+h*c;i.xmin=Math.min(i.xmin,p),i.ymin=Math.min(i.ymin,m),i.xmax=Math.max(i.xmax,p),i.ymax=Math.max(i.ymax,m)}),this.center=[(i.xmin+i.xmax)/2,(i.ymin+i.ymax)/2]}},ri=class extends Ot{constructor(e,t,s,r){super(e,t,s,r),this.method="linear"}getRelativePosition(e,t){const{rotationMatrix00:s,rotationMatrix01:r,bounds:i}=this,{xmin:n,xmax:o}=i;return[(e*s+t*r-n)/(o-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:e,bounds:t}=this,{xmin:s,xmax:r}=t;return[y(e)/(r-s),0]}};class ni extends Ot{constructor(t,s,r,i){super(t,s,r,i),this.method="rectangular"}getRelativePosition(t,s){const{bounds:r,center:i,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this,l=t*a+s*c,h=t*n+s*o-i[0],p=l-i[1];return[h*(2/(r.xmax-r.xmin)),-p*(2/(r.ymax-r.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:s}=this,{xmin:r,ymin:i,xmax:n,ymax:o}=s;return[y(2*t)/(n-r),y(2*t)/(o-i)]}}class oi extends Ot{constructor(t,s,r){super(t,s,r,0),this.method="circular";const{xmin:i,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-i,l=a-o;this.radius=Math.sqrt(c*c+l*l)/2}getRelativePosition(t,s){const{center:r,radius:i}=this;return[(t-r[0])/i,-((s-r[1])/i)]}calculateRelativeSizeFromAbsolute(){const{_size:t}=this;return[y(t)/this.radius,0]}}function ai(e,t){if(e==null)return null;const s=Te(t.angle),r=t.gradientSize,i=t.gradientSizeUnits;switch(t.gradientMethod.toLowerCase()){case"linear":return new ri(e,r,i,s);case"rectangular":return new ni(e,r,i,s);case"circular":return new oi(e,r,i);default:return si().errorOnce(`Gradient fill method "${t.gradientMethod}" currently unsupported.`),null}}const ci={createComputedParams:e=>e,optionalAttributes:et.optionalAttributes,attributes:{...et.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:e,gradientType:t})=>{let s=0;return e===pt.Absolute&&(s|=w(Bt.isAbsolute)),t.toLowerCase()==="discrete"&&(s|=w(Bt.isDiscrete)),s}},tlbr:{count:4,type:u.UNSIGNED_SHORT,pack:({sprite:e})=>{const{rect:t,width:s,height:r}=e,i=t.x+P+ut,n=t.y+P;return[i,n,i+s-2*ut,n+r]}},relativePosition:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:e},t,s,r)=>(e==null?void 0:e.getRelativePosition(s,r))??[0,0]},relativeGradientSize:{count:2,type:u.HALF_FLOAT,packTessellation:({gradientStats:e})=>(e==null?void 0:e.relativeSize)??[1,1]},gradientMethod:{count:1,type:u.UNSIGNED_BYTE,pack:({gradientMethod:e})=>{switch(e.toLowerCase()){case"rectangular":return yt.rectangular;case"circular":return yt.circular;default:return yt.linear}}}}};let _r=class extends Ft{constructor(){super(...arguments),this.vertexSpec=ci}get _preventEffectClipping(){return!0}createTesselationParams(e){return{gradientStats:ai(this._unclippedGeometry,this.evaluatedMeshParams)}}_write(e,t,s){var o;const r=(s==null?void 0:s.asOptimized())??t.readGeometryForDisplay();this._unclippedGeometry=r;const i=this._clip(r);if(!i)return void(this._unclippedGeometry=null);const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(e,t,i),this._unclippedGeometry=null,e.recordEnd()}};const li={optionalAttributes:R.optionalAttributes,createComputedParams:e=>e,attributes:{...R.attributes,...ke.attributes}},ui={optionalAttributes:R.optionalAttributes,createComputedParams:e=>e,attributes:{...R.attributes,...Lt.attributes}};class hi extends Nt{constructor(){super(...arguments),this.vertexSpec=ui}}let kr=class extends Se{constructor(){super(...arguments),this.vertexSpec=li}_createOutlineWriter(e,t,s,r){return new hi(e,t,s,r)}write(e,t,s,r,i){var o;this.ensurePacked(t,s,r);const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,n),this._write(e,s),e.recordEnd()}ensurePacked(e,t,s){super.ensurePacked(e,t,s),this._lineMeshWriter.ensurePacked(e,t,s)}enqueueRequest(e,t,s){super.enqueueRequest(e,t,s),this._lineMeshWriter.enqueueRequest(e,t,s)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const pi={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1},offset:{type:u.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let Sr=class extends U{constructor(){super(...arguments),this.vertexSpec=pi}_write(e,t){var r;e.recordStart(this.instanceId,this.attributeLayout);const s=t.getDisplayId();if(t.geometryType==="esriGeometryPoint"){const i=t.readXForDisplay(),n=t.readYForDisplay();this._writeQuad(e,s,i,n)}else t.geometryType==="esriGeometryMultipoint"&&((r=t.readGeometryForDisplay())==null||r.forEachVertex((i,n)=>{i>=0&&i<=512&&n>=0&&n<=512&&this._writeQuad(e,s,i,n)}));e.recordEnd()}_writeQuad(e,t,s,r){const i=e.vertexCount();this._writeVertex(e,t,s,r),e.indexWrite(i+0),e.indexWrite(i+1),e.indexWrite(i+2),e.indexWrite(i+1),e.indexWrite(i+3),e.indexWrite(i+2)}};const Vt=96;class fi{constructor(t){const{offsetX:s,offsetY:r,postAngle:i,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:l}=t;if(this.offsetX=s,this.offsetY=r,this.postAngle=i,this.fontSize=Math.min(n,Vt),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=l,l&&l.infos.length>1){const h=ne(n,i,!1,s,r,l,!1);this.fontSize=Math.min(h.size,Vt);const p=h.size/n;this.haloSize*=p,this.outlineSize*=p,this.postAngle=h.rotation,this.offsetX=h.offsetX,this.offsetY=h.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const di=28,N=[4,4],ct=[16,4],mi={topLeft:ct,topRight:ct,bottomLeft:ct,bottomRight:ct},mt=[4,2],T=[4,6],qt={topLeft:mt,topRight:mt,bottomLeft:T,bottomRight:T},Zt={topLeft:mt,topRight:T,bottomLeft:mt,bottomRight:T},xi={topLeft:T,topRight:T,bottomLeft:N,bottomRight:N},yi={topLeft:N,topRight:N,bottomLeft:T,bottomRight:T},gi={topLeft:T,topRight:N,bottomLeft:T,bottomRight:N},_i={topLeft:N,topRight:T,bottomLeft:N,bottomRight:T},ki={createComputedParams:e=>e,optionalAttributes:{zoomRange:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:st,packTessellation:({minZoom:e,maxZoom:t})=>[e||0,t||di]},clipAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:e})=>Si(e||0)},referenceSymbol:{type:u.BYTE,count:4,packPrecisionFactor:1,packTessellation:(e,t)=>{const s=e.isLineLabel||!e.referenceBounds,r=Re(s?"center":t.horizontalAlignment),i=Ue(s?"middle":t.verticalAlignment),{offsetX:n,offsetY:o,size:a}=s?{offsetX:0,offsetY:0,size:0}:e.referenceBounds;return[y(n),-y(o),Math.round(y(a)),r+1<<2|i+1]}},visibility:{type:u.FLOAT,count:1,otherSource:!0}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:e,mapAligned:t})=>$([[Ye,e],[Be,!!t]])},offset:{type:u.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:r,topRight:i}=e;return[r,i,t,s]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:e})=>{const{bottomLeft:t,bottomRight:s,topLeft:r,topRight:i}=e;return[r,i,t,s]}}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:e})=>e},fontAndReferenceSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({fontSize:e},{referenceSize:t})=>[Math.round(y(e)),Math.round(y(t??e))]},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>_(e)},haloColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:e})=>_(e)},outlineAndHaloSize:{type:u.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:e,haloSize:t})=>[Math.round(y(e)),Math.round(y(t))]}}};class vr extends U{constructor(){super(...arguments),this.vertexSpec=ki,this._textMeshParamsPropsInitialized=!1}ensurePacked(t,s,r){super.ensurePacked(t,s,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new fi(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(t,s,r){var c;const i=this._getShaping();if(!i)return;const n=s.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(t,s,i,r);if(r!=null&&r.nextPath())return r.nextPoint(),this._writeGlyphs(t,n,r.x,r.y,i,0);if(s.geometryType==="esriGeometryPolygon"){const l=s.readCentroidForDisplay();if(!l)return;const[h,p]=l.coords;return this._writeGlyphs(t,n,h,p,i,0)}if(s.geometryType==="esriGeometryMultipoint")return void((c=s.readGeometryForDisplay())==null?void 0:c.forEachVertex((l,h)=>this._writeGlyphs(t,n,l,h,i,0)));const o=s.readXForDisplay(),a=s.readYForDisplay();return this._writeGlyphs(t,n,o,a,i,0)}_writePlacedTextMarkers(t,s,r,i){const n=i??I.fromFeatureSetReaderCIM(s);if(!n)return;const o=-1,a=oe.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),t.id,Dt());if(!a)return;const c=s.getDisplayId();let l=a.next();for(;l!=null;){const h=l.tx,p=-l.ty,m=-l.getAngle();this._writeGlyphs(t,c,h,p,r,m),l=a.next()}}_getShaping(t){var l;const s=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!((l=r.glyphs)!=null&&l.glyphs.length))return null;const i=y(s.fontSize),n=y(s.offsetX),o=y(s.offsetY),a=Yt(y(r.lineWidth),De,ze),c=Ie*Yt(r.lineHeightRatio,.25,4);return We(r.glyphs,{scale:i/Fe,angle:s.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:t||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:y(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(t,s,r,i,n,o,a,c,l=!0){const h=this.evaluatedMeshParams,p=this._textMeshTransformProps,m=y(p.fontSize),f=p.haloSize,d=p.outlineSize,x=y(p.offsetX),g=y(p.offsetY),[S,M]=Z(h.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const z=n.bounds,D=r+z.x+x,O=i+z.y-g,L=2*(h.minPixelBuffer?h.minPixelBuffer/m:1),E=Math.max(z.width,z.height)*L;n.textBox&&(t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),l&&t.recordBounds(D,O,E,E),this._writeTextBox(t,s,r,i,n.textBox,a,c),t.recordEnd());for(const Y of n.glyphs){t.recordStart(this.instanceId,this.attributeLayout,Y.textureBinding),l&&t.recordBounds(D,O,E,E);const{texcoords:W,offsets:ve}=Y;this._writeQuad(t,s,r,i,{texcoords:W,offsets:ve,fontSize:m,haloSize:f,outlineSize:d,color:_(h.color),isBackground:!1,referenceBounds:a,minZoom:S,maxZoom:M,...c}),t.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(t,s,r,i,n,o,a){const c=this.evaluatedMeshParams,{fontSize:l,haloSize:h,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:m,boxBorderLineColor:f}=c,d={isBackground:!0,fontSize:l,haloSize:h,outlineSize:p,referenceBounds:o,...a};m&&(this._writeQuad(t,s,r,i,{texcoords:mi,offsets:n.main,color:_(m),...d}),f||(this._writeQuad(t,s,r,i,{texcoords:xi,offsets:n.top,color:_(m),...d}),this._writeQuad(t,s,r,i,{texcoords:yi,offsets:n.bot,color:_(m),...d}),this._writeQuad(t,s,r,i,{texcoords:gi,offsets:n.left,color:_(m),...d}),this._writeQuad(t,s,r,i,{texcoords:_i,offsets:n.right,color:_(m),...d}))),f&&(this._writeQuad(t,s,r,i,{texcoords:qt,offsets:n.top,color:_(f),...d}),this._writeQuad(t,s,r,i,{texcoords:qt,offsets:n.bot,color:_(f),...d}),this._writeQuad(t,s,r,i,{texcoords:Zt,offsets:n.left,color:_(f),...d}),this._writeQuad(t,s,r,i,{texcoords:Zt,offsets:n.right,color:_(f),...d}))}_writeQuad(t,s,r,i,n){const o=t.vertexCount();this._writeVertex(t,s,r,i,n),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Si=e=>Math.round(e*(254/360)),vi={createComputedParams:e=>e,optionalAttributes:F.optionalAttributes,attributes:{...F.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({gradientMethod:e,gradientSizeUnits:t,gradientType:s})=>$([[gt.isAlongLine,e.toLowerCase()==="alongline"],[gt.isAbsoluteSize,t===pt.Absolute],[gt.isDiscrete,s.toLowerCase()==="discrete"]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:r}=e,i=t.x+P+ut,n=t.y+P;return[i,n,i+s-2*ut,n+r]}},accumulatedDistance:{type:u.HALF_FLOAT,count:1,packTessellation:({distance:e,pathLength:t,distanceOffset:s})=>(s+e)/t},gradientSize:{type:u.HALF_FLOAT,count:1,pack:({gradientSize:e,gradientSizeUnits:t})=>t===pt.Relative?e/100:y(e)},totalLength:{type:u.HALF_FLOAT,count:1,packTessellation:({pathLength:e})=>e},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]}}};let Pr=class extends It{get _preventEffectClipping(){return!0}constructor(e,t,s,r){super(e,t,s,r),this.vertexSpec=vi,this._tessellationOptions.textured=!0}_write(e,t,s){const r=s??I.fromFeatureSetReaderCIM(t);if(!r)return;const{sprite:i}=this.evaluatedMeshParams;this._writeGeometry(e,t,r,i==null?void 0:i.textureBinding)}};const Pi={createComputedParams:e=>e,optionalAttributes:F.optionalAttributes,attributes:{...F.attributes,bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:e,shouldScaleDash:t,isSDF:s})=>$([[se,e],[Ce,t],[Ge,s]])},tlbr:{type:u.UNSIGNED_SHORT,count:4,pack:({sprite:e})=>{const{rect:t,width:s,height:r}=e,i=t.x+P,n=t.y+P;return[i,n,i+s,n+r]}},accumulatedDistance:{type:u.UNSIGNED_SHORT,count:1,packTessellation:({distance:e})=>e},segmentDirection:{type:u.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:e,directionY:t})=>[e,t]},offsetAlongLine:{type:u.HALF_FLOAT,count:1,pack:({offsetAlongLine:e})=>y(e)},capType:{type:u.UNSIGNED_BYTE,count:1,pack:({capType:e})=>{switch(e){case X.Butt:case"butt":return 0;case X.Square:case"square":return 1;case X.Round:case"round":return 2;default:return 0}}}}};class br extends It{constructor(t,s,r,i){super(t,s,r,i),this.vertexSpec=Pi,this._tessellationOptions.textured=!0}_write(t,s,r){const i=r??I.fromFeatureSetReaderCIM(s);if(!i)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(t,s,i,n==null?void 0:n.textureBinding)}}let bi=class zt{static from(t){return"width"in t?this.fromSimpleMeshParams(t):this.fromComplexMeshParams(t)}static fromSimpleMeshParams(t){const s=new zt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects),{type:r,width:i,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:l,sprite:h,overrideOutlineColor:p}=t;return s.rawWidth=y(i),s.rawHeight=y(n),s.angle=o,s.alignment=a,s.outlineSize=y(c),s.referenceSize=y(l),s.overrideOutlineColor=p,s.offsetX=y(t.offsetX),s.offsetY=y(t.offsetY),r!=="simple"||h.sdf||(s.rawWidth=h.width,s.rawHeight=h.height),s._computeSize(t,!1),s}static fromComplexMeshParams(t){const s=new zt(t.sprite,t.color,t.outlineColor,t.minPixelBuffer,t.placement,t.scaleInfo,t.effects);let{alignment:r,transforms:i,size:n,scaleX:o,anchorX:a,anchorY:c,angle:l,colorLocked:h,frameHeight:p,widthRatio:m,offsetX:f,offsetY:d,outlineSize:x,referenceSize:g,scaleFactor:S,sizeRatio:M,isAbsoluteAnchorPoint:z,rotateClockwise:D,scaleSymbolsProportionally:O,sprite:L}=t;if(i&&i.infos.length>0){const W=ne(n,l,D,f,d,i);n=W.size,l=W.rotation,f=W.offsetX,d=W.offsetY,D=!1}S&&(n*=S,f*=S,d*=S);const E=o*(L.width/L.height);s.alignment=r,s.rawHeight=y(n),s.rawWidth=s.rawHeight*E,s.referenceSize=y(g),s.sizeRatio=M,s.sdfDecodeCoeff=(L.sdfDecodeCoeff??1)*M,s.angle=l,s.rotateClockwise=D,s.anchorX=a,s.anchorY=c,s.offsetX=y(f),s.offsetY=y(d),z&&n&&(L.sdf?s.anchorX=a/(n*m):s.anchorX=a/(n*E),s.anchorY=c/n);const Y=O&&p?n/p:1;return s.outlineSize=x===0||isNaN(x)?0:y(x)*Y,s.scaleSymbolsProportionally=O,s.colorLocked=h,s._computeSize(t,!0),s}constructor(t,s,r,i,n,o,a){this.sprite=t,this.color=s,this.outlineColor=r,this.minPixelBuffer=i,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=ie.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(t,s){const{sprite:r,hasSizeVV:i}=t,n=!!r.sdf,o=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:l,outlineSize:h}=this,p=r.rect;let m=a*l,f=c*l,d=0,x=0;if(n){const D=1/(1-o);if(m*=D,f*=D,i)this.computedWidth=m,this.computedHeight=f;else{const O=s&&a>c?m:a,L=c,E=h+2;this.computedWidth=Math.min(O+E,m),this.computedHeight=Math.min(L+E,f);const Y=Math.max(r.width,r.height)/Math.max(m,f);d=(this.computedWidth-m)*Y,x=(this.computedHeight-f)*Y}}else this.computedWidth=m*(p.width/r.width),this.computedHeight=f*(p.height/r.height),d=2*P,x=2*P;const g=p.x+P-d/2,S=p.y+P-x/2,M=g+r.width+d,z=S+r.height+x;this.texXmin=$t(g),this.texYmin=$t(S),this.texXmax=Qt(M),this.texYmax=Qt(z),this.computedWidth*=(this.texXmax-this.texXmin)/(M-g),this.computedHeight*=(this.texYmax-this.texYmin)/(z-S),this.anchorX*=m/this.computedWidth,this.anchorY*=f/this.computedHeight}};function $t(e,t=1e-7){const s=Math.ceil(e);return s-e<t?s:Math.floor(e)}function Qt(e,t=1e-7){const s=Math.floor(e);return e-s<t?s:Math.ceil(e)}const wi=3.14159265359/180,Ti=128/Math.PI;function Mi(e,t){return e%=t,Math.abs(e>=0?e:e+t)}function Ei(e){return Mi(e*Ti,256)}function Ai(e,t,s,r,i=!1){const n=ss(),o=i?1:-1;return Ke(n),(t||s)&&ts(n,n,[t,-s]),r&&es(n,n,o*wi*-r),n}const zi={createComputedParams:e=>bi.from(e),optionalAttributes:{zoomRange:{type:u.SHORT,count:2,packPrecisionFactor:st,pack:({scaleInfo:e},{tileInfo:t})=>Z(e,t)}},attributes:{pos:{type:u.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:({sprite:e,alignment:t,scaleSymbolsProportionally:s,overrideOutlineColor:r,colorLocked:i})=>{let n=0;return e.sdf&&(n|=w(A.bitset.isSDF)),t===ie.MAP&&(n|=w(A.bitset.isMapAligned)),s&&(n|=w(A.bitset.scaleSymbolsProportionally)),r&&(n|=w(A.bitset.overrideOutlineColor)),i&&(n|=w(A.bitset.colorLocked)),n}},offset:{type:u.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:e,computedWidth:t,computedHeight:s,anchorX:r,anchorY:i,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=Ai(0,n,o,-e,a),l=-(.5+r)*t,h=-(.5-i)*s,p=[l,h],m=[l+t,h],f=[l,h+s],d=[l+t,h+s];return rt(p,p,c),rt(m,m,c),rt(f,f,c),rt(d,d,c),[p,m,f,d]}}},textureUV:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:e,texXmin:t,texYmax:s,texYmin:r})=>[[t,r],[e,r],[t,s],[e,s]]}},color:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:e})=>_(e)},outlineColor:{type:u.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:e})=>_(e)},sizing:{type:u.UNSIGNED_BYTE,count:4,pack:({rawWidth:e,rawHeight:t,outlineSize:s,referenceSize:r})=>{const i=Math.max(e,t);return[vt(i,128),vt(s,128),vt(r,128),0]}},placementAngle:{type:u.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:e})=>Ei(e)},sdfDecodeCoeff:{type:u.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:e})=>e}}};class wr extends U{constructor(){super(...arguments),this.vertexSpec=zi}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(t,s,r){var f,d;const i=(f=this.evaluatedMeshParams.sprite)==null?void 0:f.textureBinding,n=s.getDisplayId();t.recordStart(this.instanceId,this.attributeLayout,i);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),l=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,h=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,p=this.evaluatedMeshParams.offsetX+l,m=-this.evaluatedMeshParams.offsetY+h;if(this.evaluatedMeshParams.placement!=null){let x=null;if(r!=null){const g=Math.max(this.evaluatedMeshParams.computedWidth,this.evaluatedMeshParams.computedHeight);if(x=He(r,2*g,!1),x===null)return}this._writePlacedMarkers(t,s,x,a,c)}else if(r!=null&&r.nextPath()){r.nextPoint();const x=r.x,g=r.y;t.recordBounds(x+p,g+m,a,c),this._writeQuad(t,n,x,g)}else if(s.geometryType==="esriGeometryPolygon"){const x=s.readCentroidForDisplay();if(!x)return;const[g,S]=x.coords;t.recordBounds(g+p,S+m,a,c),this._writeQuad(t,n,g,S)}else if(s.geometryType==="esriGeometryPoint"){const x=s.readXForDisplay(),g=s.readYForDisplay();t.recordBounds(x+p,g+m,a,c),this._writeQuad(t,n,x,g)}else(d=s.readGeometryForDisplay())==null||d.forEachVertex((x,g)=>{t.recordBounds(x+p,g+m,a,c),Math.abs(x)>nt||Math.abs(g)>nt||this._writeQuad(t,n,x,g)});t.recordEnd()}_writePlacedMarkers(t,s,r,i,n){const o=r??I.fromFeatureSetReaderCIM(s);if(!o)return;const a=-1,c=oe.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),t.id,Dt());if(!c)return;const l=s.getDisplayId();let h=c.next();const p=this.evaluatedMeshParams.offsetX,m=-this.evaluatedMeshParams.offsetY;for(;h!=null;){const f=h.tx,d=-h.ty;if(Math.abs(f)>nt||Math.abs(d)>nt){h=c.next();continue}const x=-h.getAngle();t.recordBounds(f+p,d+m,i,n),this._writeQuad(t,l,f,d,x),h=c.next()}}_writeQuad(t,s,r,i,n){const o=t.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(t,s,r,i,a),t.indexWrite(o+0),t.indexWrite(o+1),t.indexWrite(o+2),t.indexWrite(o+1),t.indexWrite(o+3),t.indexWrite(o+2)}}const Di={createComputedParams:e=>e,optionalAttributes:{},attributes:{pos:{type:u.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:u.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:u.UNSIGNED_BYTE,count:1,pack:e=>0},offset:{type:u.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:e})=>{const t=y(e),s=-t/2,r=-t/2;return[[s,r],[s+t,r],[s,r+t],[s+t,r+t]]}}},texCoords:{type:u.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:u.UNSIGNED_BYTE,count:2,pack:({size:e})=>[e,e]},referenceSize:{type:u.UNSIGNED_BYTE,count:1,pack:({size:e})=>y(e)},zoomRange:{type:u.UNSIGNED_BYTE,count:2,pack:({scaleInfo:e},{tileInfo:t})=>Z(e,t)}}};class Tr extends U{constructor(){super(...arguments),this.vertexSpec=Di}_write(t,s){const r=s.getDisplayId(),i=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),i);let o,a;if(s.geometryType==="esriGeometryPoint")o=s.readXForDisplay(),a=s.readYForDisplay();else{const l=s.readCentroidForDisplay();if(!l)return;o=l==null?void 0:l.coords[0],a=l==null?void 0:l.coords[1]}t.recordStart(this.instanceId,this.attributeLayout),t.recordBounds(o,a,n,n);const c=t.vertexCount();this._writeVertex(t,r,o,a),t.indexWrite(c+0),t.indexWrite(c+1),t.indexWrite(c+2),t.indexWrite(c+1),t.indexWrite(c+3),t.indexWrite(c+2),t.recordEnd()}}export{br as $,Qi as A,Sr as B,or as C,ye as D,Dt as E,er as F,cr as G,hr as H,Ji as I,ls as J,_r as L,Wt as M,sr as N,kr as O,b as P,Pr as Q,ar as R,v as S,he as T,ur as U,vr as V,lr as W,pr as X,rr as Y,dr as Z,xr as _,Tr as a,Se as b,fr as c,It as d,tr as e,ir as f,mr as g,nr as h,Vs as i,Xs as j,js as k,Z as l,_ as m,wr as n,xs as o,xt as p,Ps as q,as as r,os as s,$i as t,Ki as u,gr as v,di as w,Us as x,oe as y,ji as z};
