const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./densifyOperator-vIKWtKQ2-EpeBoYma.js","./index-JysQxb7m.js","./index-BQSptJp9.css","./Point2D-CaHJVGk1-JqvJXjLr.js","./ProjectionTransformation-DQ4GElxa-Ca2aDxt1.js","./Envelope2D-DlBzXkgv-eKRxGysX.js","./Transformation2D-CXWnDKXs-bixc63yn.js","./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js","./OperatorDefinitions-DJdq_wrt-DP7_WWTp.js","./jsonConverter-tsQ40CV0-KXut-8kD.js","./apiConverter-CSuukuP9-D8wHo0F-.js","./differenceOperator-Dvly1JND-DdJ4F2Z8.js","./lengthOperator-C4ac9v9--CE9I01pZ.js"])))=>i.map(i=>d[i]);
import{v as g,S as R,n as ae,X as Fe,cW as ge,a6 as ie,aF as ne,l as B,o as j,h as N,N as Ie,ar as Re,p as Pe,_ as Z,Z as De,bh as Be,bf as Je,w as Ce,at as He}from"./index-JysQxb7m.js";import{i as be}from"./OperationalLayer-CbXUnTH0-Bn7-Pvcl.js";import{j as V,h as we,p as Me,u as Ne,o as ze,b as Se,f as Oe,O as ce,w as Ee,v as We,I as Le}from"./datasetUtils-DYlC2Qty-9TClXlFF.js";import{V as qe,g as ue,S as Ae,T as Ge,a as $e,N as Ve,i as he,D as je,b as Ue,K as Qe,O as Xe,r as Ze,F as Ye,W as me,n as Ke,L as fe}from"./RasterJobHandlerMixin-DESVihMQ-L4u4Uoqj.js";import{d as et,Q as tt,B as it,q as nt,k as rt}from"./RasterSymbolizer-BN6RVtx9-atUXo-OI.js";import{a as Y,n as st}from"./TileInfo-U28GysF5-BNo6Mbun.js";import{QueueProcessor as ot}from"./QueueProcessor-BSpvDXZs-D-ecaFKQ.js";import{P as at,Z as lt,O as ct,U as ut,Y as ht}from"./RawBlockCache-B-F6OWAv-AOYcTDHA.js";import{W as mt}from"./pixelRangeUtils-DcEknavd-CueOHV1N.js";import{T as ee,u as ve,f as ft,d as dt,w as pt}from"./dataUtils-CfR0oe2x-2onKl-NV.js";import{E as Q,W as re,i as de,V as pe,U as yt,X as te,r as X,D as xt,$ as gt,I as It,J as se}from"./rasterProjectionHelper-DGqzGF1m-DAJ9Y5v-.js";import{F as oe,$ as Rt}from"./clipUtils-fw7VCGXU-ClGWvh2j.js";import{c as bt}from"./FeatureSet-BVGGhhH9-CR-T7cae.js";import{q as wt}from"./rasterFunctionHelper-ABMN-R6n-CuePlxPD.js";const ye=8,St=256;let vt=0,v=class extends Fe{constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:Y.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=Q(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var i,s;this._set("rasterJobHandler",t),V(this)&&((s=(i=this.primaryRasters)==null?void 0:i.rasters)==null||s.forEach(e=>e.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+vt++}set url(t){this._set("url",ge(t,ie.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=re().then(()=>this._open(t))),this._openPromise}async fetchTile(t,i,s,e={}){const n=e.tileInfo||this.rasterInfo.storageInfo.tileInfo,o=this.getTileExtentFromTileInfo(t,i,s,n);return e={noClip:!0,...e},this.fetchPixels(o,n.size[0],n.size[1],e)}async identify(t,i={}){var H;t=ne(B,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:e}=i,{rasterInfo:n}=this,{hasMultidimensionalTranspose:o,multidimensionalInfo:r}=n;let{transposedVariableName:a}=i;const c=r!=null&&o&&(e!=null||we(s));c&&!a&&(a=s!=null&&s.length>0?s[0].variableName??void 0:r.variables[0].name,i={...i,transposedVariableName:a}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:l,extent:u}=n,{datumTransformation:h}=i;let f=de(t,l,h);if(!u.intersects(f))return{location:f,value:null};if(n.transform!=null){const J=n.transform.inverseTransform(f);if(!n.nativeExtent.intersects(J))return{location:J,value:null};f=J}let p=0;const y=a!=null&&r!=null&&n.hasMultidimensionalTranspose;if(V(this)){const J=this.primaryRasters.rasters[0];if(y)return J.identify(f,i);const{pixelSize:M}=n,_=3,E=M.x*_/2,W=M.y*_/2,L=new j({xmin:f.x-E,xmax:f.x+E,ymin:f.y-W,ymax:f.y+W,spatialReference:l}),F={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId},{pixelBlock:T}=await J.fetchPixels(L,_,_,F),{pixelBlock:k}=await this.fetchPixels(L,_,_,F);if(T==null)return{location:f,value:null};const P=Math.floor(_*_*.5),q=!T.mask||T.mask[P]?T.pixels.map(D=>D[P]):null;let C;return k!=null&&(C=!k.mask||k.mask[P]?k.pixels.map(D=>D[P]):void 0),{location:f,value:q,processedValue:C,pyramidLevel:0}}if(!y){if(i.srcResolution)p=pe(i.srcResolution,n,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(t,i),p==null)return{location:f,value:null}}const x=this.identifyPixelLocation(f,p,null,y);if(x===null)return{location:f,value:null};const{row:d,col:m,rowOffset:I,colOffset:b,blockWidth:S}=x,w=await this._tileFetchQueue.push({pyramidLevel:p,row:d,col:m,options:i},{signal:i.signal});if(!((H=w==null?void 0:w.pixels)!=null&&H.length))return{location:f,value:null};const z=I*S+b;return this._processIdentifyResult(w,{srcLocation:f,position:z,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:c,identifyOptions:i})}async fetchPixels(t,i,s,e={}){t=yt(t),e=this._getRequestOptionsWithSliceId(e);const{_hasNoneOrGCSShiftTransform:n}=this;if(e.requestRawData&&n)return this._fetchPixels(t,i,s,e);const o=Q(t.spatialReference),r=te(t);if(o==null||r===0||r===1&&this._isGlobalWrappableSource&&n)return this._fetchPixels(t,i,s,e);if(r>=3)return{extent:t,pixelBlock:null};const a=[],{xmin:c,xmax:l}=t,u=Math.round(o/(l-c)*i),h=u-Math.round((o/2-c)/(l-c)*i);let f=0;const p=[];for(let m=0;m<=r;m++){const I=new j({xmin:m===0?c:-o/2,xmax:m===r?l-o*m:o/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),b=m===0?u-h:m===r?i-f:u;f+=b,p.push(b);const S=e.disableWrapAround&&m>0?null:this._fetchPixels(I,b,s,e);a.push(S)}const y=(await Promise.all(a)).map(m=>m==null?void 0:m.pixelBlock);let x=null;const d={width:i,height:s};return this.rasterJobHandler?x=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:d,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},e)).pixelBlock:x=ee(y,d,{blockWidths:p}),{extent:t,srcExtent:X(t,this.rasterInfo.spatialReference,e.datumTransformation),pixelBlock:x}}async fetchRawPixels(t,i,s,e={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const n=await this._fetchRawTiles(t,i,s,e),{nativeExtent:o,nativePixelSize:r,storageInfo:a}=this.rasterInfo,c=2**t,l=r.x*c,u=r.y*c,h=new j({xmin:o.xmin+l*i.x,xmax:o.xmin+l*(i.x+s.width-1),ymin:o.ymax-u*(i.y+s.height-1),ymax:o.ymax-u*i.y,spatialReference:o.spatialReference});if(!n)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:f,mosaicSize:p}=n;if(f.length===1&&f[0]!=null&&f[0].width===s.width&&f[0].height===s.height)return{extent:h,srcExtent:h,pixelBlock:n.pixelBlocks[0]};const y=t>0?a.pyramidBlockWidth:a.blockWidth,x=t>0?a.pyramidBlockHeight:a.blockHeight,d={x:i.x%y,y:i.y%x};let m;return this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:f,srcMosaicSize:p,destDimension:s,clipOffset:d,clipSize:s,coefs:null,sampleSpacing:null,interpolation:e.interpolation,alignmentInfo:null,blockWidths:null},e)).pixelBlock:m=ee(f,p,{clipOffset:d,clipSize:s}),{extent:h,srcExtent:h,pixelBlock:m}}fetchRawTile(t,i,s,e){throw new N("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return X(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?et(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:e}=this.ioConfig,{range:n,query:o,headers:r}=i;s=s??i.retryCount??this.ioConfig.retryCount;const a=n?{Range:`bytes=${n.from}-${n.to}`}:null;try{return await Ie(t,{...i,query:{...o,...e},headers:{...r,...a}})}catch(c){if(s>0)return s--,this.request(t,i,s);throw c}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Me(t,i)}getTileExtentFromTileInfo(t,i,s,e){const n=e.lodAt(t);return this.getTileExtent({x:n.resolution,y:n.resolution},i,s,e.origin,e.spatialReference,e.size)}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:e}=this.rasterInfo,{pyramidResolutions:n}=t;if(!t.tileInfo){const o=[],r=t.maximumPyramidLevel||0;let a=(e.x+e.y)/2,c=1/.0254*96*a;for(let u=0;u<=r&&(o.unshift(new st({level:r-u,resolution:a,scale:c})),u!==r);u++)if(n){const h=(n[u].x+n[u].y)/2;c*=h/a,a=h}else a*=2,c*=2;const l=new B({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new Y({origin:l,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:o}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,e){const{width:n,height:o,nativeExtent:r,pixelSize:a,spatialReference:c}=t,l=new B({x:r.xmin,y:r.ymax,spatialReference:c});e==null&&(e=Math.max(0,Math.round(Math.log(Math.max(n,o))/Math.LN2-8)));const u=this.computeBlockBoundary(r,512,512,{x:r.xmin,y:r.ymax},[a],e);t.storageInfo=new tt({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:l,firstPyramidLevel:1,maximumPyramidLevel:e,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,e,n,o=0,r=2){if(n.length===1&&o>0){n=[...n];let{x:u,y:h}=n[0];for(let f=0;f<o;f++)u*=r,h*=r,n.push({x:u,y:h})}const a=[],{x:c,y:l}=e;for(let u=0;u<n.length;u++){const{x:h,y:f}=n[u];a.push({minCol:Math.floor((t.xmin-c+.1*h)/i/h),maxCol:Math.floor((t.xmax-c-.1*h)/i/h),minRow:Math.floor((l-t.ymax+.1*f)/s/f),maxRow:Math.floor((l-t.ymin-.1*f)/s/f)})}return a}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:e}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const n=e**t;return{x:i.x*n,y:i.y*n}}identifyPixelLocation(t,i,s,e){const{spatialReference:n,nativeExtent:o,storageInfo:r}=this.rasterInfo,{maximumPyramidLevel:a,origin:c,transposeInfo:l}=r,u=e&&l!=null?l.tileSize[0]:r.blockWidth,h=e&&l!=null?l.tileSize[1]:r.blockHeight,f=de(t,n,s);if(!o.intersects(f)||i<0||i>a)return null;const p=this.getPyramidPixelSize(i),{x:y,y:x}=p,d=(c.y-f.y)/x/h,m=(f.x-c.x)/y/u,I=Math.min(h-1,Math.floor((d-Math.floor(d))*h)),b=Math.min(u-1,Math.floor((m-Math.floor(m))*u));return{pyramidLevel:i,row:Math.floor(d),col:Math.floor(m),rowOffset:I,colOffset:b,blockWidth:u,srcLocation:f}}getTileExtent(t,i,s,e,n,o){const[r,a]=o,c=e.x+s*r*t.x,l=c+r*t.x,u=e.y-i*a*t.y,h=u-a*t.y;return new j({xmin:c,xmax:l,ymin:h,ymax:u,spatialReference:n})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const e=this.rasterInfo.storageInfo.blockBoundary[t];return!e||e.maxRow<i||e.maxCol<s||e.minRow>i||e.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:e}=t,n=Re.WebMercator;t.spatialReference=n,t.extent=t.nativeExtent=new j({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-e,spatialReference:n}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new B({x:1,y:1,spatialReference:n});const{extent:o,storageInfo:r}=t;if(r){r.origin=new B({x:o.xmin,y:o.ymax,spatialReference:n});const{pyramidResolutions:a,tileInfo:c}=r;if(a&&a.forEach(l=>{l.x/=i.x,l.y/=i.y}),c){c.origin=r.origin;const l=(t.nativePixelSize.x+t.nativePixelSize.y)/2;c.lods.forEach((u,h)=>{u.resolution=l*2**h,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,s,e={}){let n=te(t);if(n>=2)return{extent:t,pixelBlock:null};const o=this._getSourceDataInfo(t,i,s,e),{pyramidLevel:r,srcResolution:a,srcExtent:c,srcWidth:l,srcHeight:u,ul:h}=o;if(l===0||u===0)return{extent:t,srcExtent:c,pixelBlock:null};const{rasterInfo:f}=this,p=f.transform,y=(p==null?void 0:p.type)==="gcs-shift",x=Q(t.spatialReference)!=null;!y&&x||(n=te(o.srcExtent,y));const d=await this._fetchRawTiles(r,h,{width:l,height:u,wrapCount:n},e);if(!d)return{extent:t,srcExtent:c,pixelBlock:null};const m=f.storageInfo,I=r>0?m.pyramidBlockWidth:m.blockWidth,b=r>0?m.pyramidBlockHeight:m.blockHeight;let{x:S,y:w}=f.pixelSize;if(r>0){const{pyramidResolutions:O,pyramidScalingFactor:ke}=m;if(O!=null&&O[r-1])({x:S,y:w}=O[r-1]);else{const le=ke**r;S*=le,w*=le}}const z=f.spatialReference,H=new B({x:S,y:w,spatialReference:z}),J=I===l&&b===u&&h.x%I===0&&h.y%b===0,M=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),_=!t.spatialReference.equals(z),E=z.isGeographic?1e-9:1e-4,{datumTransformation:W}=e;if(!_&&J&&d.pixelBlocks.length===1&&I===i&&b===s&&_t(a,M,E))return{extent:t,srcExtent:c,srcTilePixelSize:H,pixelBlock:d.pixelBlocks[0]};const L=x&&Q(c.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,F=e.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");F&&!this.rasterJobHandler&&await re();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:M.toJSON(),datumTransformation:W,rasterTransform:p,hasWrapAround:n>0||L,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:F},e):xt({projectedExtent:t,srcBufferExtent:d.extent,pixelSize:M,datumTransformation:W,rasterTransform:p,hasWrapAround:n>0||L,isAdaptive:!1,includeGCSGrid:F});let k;const P=!e.requestRawData,q={rows:T.spacing[0],cols:T.spacing[1]},C=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(r,d.extent.xmin):void 0,{pixelBlocks:D,mosaicSize:A,isPartiallyFilled:U}=d;let G=null;if(this.rasterJobHandler)({pixelBlock:k,localNorthDirections:G}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:D,srcMosaicSize:A,destDimension:P?{width:i,height:s}:null,coefs:P?T.coefficients:null,sampleSpacing:P?q:null,projectDirections:F,gcsGrid:F?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:e.interpolation,alignmentInfo:C,blockWidths:null},e));else{const O=ee(D,A,{alignmentInfo:C});k=P?ve(O,{width:i,height:s},T.coefficients,q,e.interpolation):O,F&&T.gcsGrid&&(G=ft({width:i,height:s},T.gcsGrid),k=dt(k,this.rasterInfo.dataType,G))}return e.requestRawData||F?{extent:t,srcExtent:c,srcTilePixelSize:H,pixelBlock:k,transformGrid:T,localNorthDirections:G,isPartiallyFilled:U}:{extent:t,srcExtent:c,srcTilePixelSize:H,pixelBlock:k}}async _fetchRawTiles(t,i,s,e){const{origin:n,blockBoundary:o}=this.rasterInfo.storageInfo,{blockWidth:r,blockHeight:a}=this.getBlockWidthHeight(t);let{x:c,y:l}=i,{width:u,height:h,wrapCount:f}=s;const p=this._getRasterTileAlignmentInfo(t,0);e.buffer&&(c-=e.buffer.cols,l-=e.buffer.rows,u+=2*e.buffer.cols,h+=2*e.buffer.rows);let y=0,x=0,d=0;f&&p!=null&&({worldColumnCountFromOrigin:x,originColumnOffset:d,rightPadding:y}=p,x*p.blockWidth-y>=c+u&&(y=0));const m=Math.floor(c/r),I=Math.floor(l/a),b=Math.floor((c+u+y-1)/r),S=Math.floor((l+h+y-1)/a),w=o[t];if(!w)return null;const{minRow:z,minCol:H,maxCol:J,maxRow:M}=w;if(f===0&&(S<z||b<H||I>M||m>J))return null;const _=new Array;let E=!1;const W=this.ioConfig.allowPartialFill==null?e.allowPartialFill:this.ioConfig.allowPartialFill;for(let C=I;C<=S;C++)for(let D=m;D<=b;D++){let A=D;if(!e.disableWrapAround&&f&&p!=null&&x<=D&&(A=D-x-d),C>=z&&A>=H&&M>=C&&J>=A){const U=this._tileFetchQueue.push({pyramidLevel:t,row:C,col:A,options:e},{signal:e.signal});W?_.push(new Promise(G=>{U.then(O=>G(O)).catch(()=>{E=!0,G(null)})})):_.push(U)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const L=await Promise.all(_),F={height:(S-I+1)*a,width:(b-m+1)*r},{spatialReference:T}=this.rasterInfo,k=this.getPyramidPixelSize(t),{x:P,y:q}=k;return{extent:new j({xmin:n.x+m*r*P,xmax:n.x+(b+1)*r*P,ymin:n.y-(S+1)*a*q,ymax:n.y-I*a*q,spatialReference:T}),pixelBlocks:L,mosaicSize:F,isPartiallyFilled:E}}_fetchRawTile(t,i,s,e){const{storageInfo:n}=this.rasterInfo,o=n.transposeInfo!=null&&!!e.transposedVariableName;if(!o){const h=n.blockBoundary[t];if(!h)return Promise.resolve(null);const{minRow:f,minCol:p,maxCol:y,maxRow:x}=h;if(i<f||s<p||i>x||s>y)return Promise.resolve(null)}const r=o?e.transposeVariableName:e.sliceId,a=this.rasterInfo.storageInfo.isBsqTile?e.bandIds:null,c=at(this.rasterId,r,a),l=`${t}/${i}/${s}`;let u=lt(c,e.registryId,l);if(u==null){const h=new AbortController;u=this.fetchRawTile(t,i,s,{...e,signal:h.signal}),ct(c,e.registryId,l,u,h),u.catch(()=>ut(c,e.registryId,l))}return e.signal&&Pe(e,()=>{ht(c,e.registryId,l)}),u}_computeMagDirValues(t){var c;const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||(t==null?void 0:t.length)!==2||!((c=t[0])!=null&&c.length))return null;const e=t[0].length;if(s==="vector-magdir"){const l=t[1].map(u=>(u+360)%360);return[t[0],l]}const[n,o]=t,r=[],a=[];for(let l=0;l<e;l++){const[u,h]=pt([n[l],o[l]]);r.push(u),a.push(h)}return[r,a]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=gt(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,e={}){const n={datumTransformation:e.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};e.srcResolution&&(n.srcResolution=e.srcResolution,this._updateSourceDataInfo(t,n));const o=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:r,srcHeight:a,pyramidLevel:c}=n,l=r/i,u=a/s,h=c<o&&l*u>=16,f=c===o&&this._requireTooManySrcTiles(r,a,i,s);if(h||f||r===0||a===0){const p=new B({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let y=It(p,this.rasterInfo.spatialReference,t,n.datumTransformation);const x=!y||e.srcResolution&&y.x+y.y<e.srcResolution.x+e.srcResolution.y;if(h&&e.srcResolution&&x){const d=Math.round(Math.log(Math.max(l,u))/Math.LN2)-1;if(o-c+3>=d){const m=2**d;y={x:e.srcResolution.x*m,y:e.srcResolution.y*m}}}y&&(n.srcResolution=y,this._updateSourceDataInfo(t,n))}return this._requireTooManySrcTiles(n.srcWidth,n.srcHeight,i,s)&&(n.srcWidth=0,n.srcHeight=0),n}_requireTooManySrcTiles(t,i,s,e){const{tileInfo:n}=this.rasterInfo.storageInfo,o=Math.ceil(t/n.size[0])*Math.ceil(i/n.size[1]),r=t/s,a=i/e,c=Math.max(1,(s+e)/1024);return o>=St*c||r>ye||a>ye}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,e=s.spatialReference,{srcResolution:n,datumTransformation:o}=i,{pyramidLevel:r,pyramidResolution:a,excessiveReading:c}=pe(n,s,this.ioConfig.sampling);if(c)return;let l=i.srcExtent||X(t,e,o);if(l==null)return;const u=s.transform;u&&(l=u.inverseTransform(l)),i.srcExtent=l;const{x:h,y:f}=s.storageInfo.origin,p=Math.floor((l.xmin-h)/a.x+.1),y=Math.floor((f-l.ymax)/a.y+.1),x=Math.floor((l.xmax-h)/a.x-.1),d=Math.floor((f-l.ymin)/a.y-.1),m=l.width<.1*a.x?0:x-p+1,I=l.height<.1*a.y?0:d-y+1;i.pyramidLevel=r,i.pyramidResolution=a,i.srcWidth=m,i.srcHeight=I,i.ul={x:p,y}}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:e,pyramidLevel:n,useTransposedTile:o}=i,r=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[e]))return{location:s,value:null};const{multidimensionalInfo:a}=this.rasterInfo;if(a==null||!o){const d=t.pixels.map(b=>b[e]),m={location:s,value:d,pyramidLevel:n},I=this._computeMagDirValues(d.map(b=>[b]));return I!=null&&I.length&&(m.magdirValue=I.map(b=>b[0])),m}let c=t.pixels.map(d=>d.slice(e*r,e*r+r)),l=this._computeMagDirValues(c);const{requestSomeSlices:u,identifyOptions:h}=i;let f=Ne(a,h.transposedVariableName);if(u){const d=ze(f,h.multidimensionalDefinition,h.timeExtent);c=c.map(m=>d.map(I=>m[I])),l=l==null?void 0:l.map(m=>d.map(I=>m[I])),f=d.map(m=>f[m])}const p=t.noDataValues||this.rasterInfo.noDataValue,y={pixels:c,pixelType:t.pixelType};let x;return p!=null&&(mt(y,p),x=y.mask),{location:s,value:null,dataSeries:f.map((d,m)=>{const I={value:(x==null?void 0:x[m])===0?null:c.map(b=>b[m]),multidimensionalDefinition:d.multidimensionalDefinition.map(b=>new Se({...b,isSlice:!0}))};return l!=null&&l.length&&(I.magdirValue=[l[0][m],l[1][m]]),I}),pyramidLevel:n}}};function _t(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}g([R()],v.prototype,"_rasterTileAlignmentInfo",void 0),g([R()],v.prototype,"_tileFetchQueue",void 0),g([R({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),g([R({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),g([R()],v.prototype,"_openPromise",void 0),g([R()],v.prototype,"rasterJobHandler",null),g([R({readOnly:!0})],v.prototype,"rasterId",null),g([R(be)],v.prototype,"url",null),g([R({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),g([R({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),g([R()],v.prototype,"hasUniqueSourceStorageInfo",void 0),g([R()],v.prototype,"rasterInfo",void 0),g([R()],v.prototype,"ioConfig",void 0),g([R()],v.prototype,"sourceJSON",void 0),v=g([ae("esri.layers.support.rasterDatasets.BaseRaster")],v);const Tt=40;let $=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,e={}){var b,S;const{rasters:n,rasterIds:o}=this.primaryRasters;let r=!1;const{interpolation:a}=e,c=(b=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:b.hasFocalFunction;!e.requestRawData&&c&&(r=n.length===1&&!e.skipRasterFunction,e={...e,interpolation:"bilinear",requestRawData:r});const l=n.map(w=>w.fetchPixels(t,i,s,e)),u=await Promise.all(l),h=u.map(w=>w.pixelBlock),f=r||e.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(e.skipRasterFunction||h.every(w=>w==null))return u[0];const p=((S=u.find(w=>w.pixelBlock!=null))==null?void 0:S.extent)??t;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:h,primaryPixelSizes:f,primaryRasterIds:o}):this.rasterFunction.process({extent:p,primaryPixelBlocks:h,primaryPixelSizes:f,primaryRasterIds:o});const{transformGrid:x}=u[0];if(!r||y==null||x==null){const w=e.noClip?null:this.getClippingGeometry(p.spatialReference);return e.noClip||e.requestRawData||y==null||!w||(y=await oe(y,p,w)),{...u[0],pixelBlock:y}}const d={rows:x.spacing[0],cols:x.spacing[1]};let m;this.rasterJobHandler?m=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:i,height:s},coefs:x.coefficients,sampleSpacing:d,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:a,alignmentInfo:void 0,blockWidths:null},e)).pixelBlock:m=ve(y,{width:i,height:s},x.coefficients,d,a);const I=e.noClip?null:this.getClippingGeometry(t.spatialReference);return e.noClip||e.requestRawData||m==null||I==null||(m=await oe(m,t,I)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:m}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const s=Ft(t);let e=this._clippingGeometry.get(s);return e!=null||(e=t.equals(i.spatialReference)?i:se(i,t),this._clippingGeometry.set(s,e)),e}async _open(t){var l,u,h,f;const{rasterFunction:i}=this;i.isRoot=!0,(u=(l=this.primaryRasters)==null?void 0:l.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((h=this.primaryRasters.rasters)==null||h.forEach(p=>p.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:e}=this.primaryRasters,n=s.map(p=>p.rasterInfo?void 0:p.open(t));await Promise.all(n);const o=s.map(({rasterInfo:p})=>p),r=i.bind({rasterInfos:o,rasterIds:e});if(i.rawSourceRasterInfos=o,!r.success||o.length===0)throw new N("raster-function:open",`cannot bind the function: ${r.error??""}`);const a=i.functionName==="Table"?i:(f=i.functionArguments)==null?void 0:f.raster;(a==null?void 0:a.functionName)==="Table"&&(i.rasterInfo.attributeTable=bt.fromJSON(a.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const c=o[0];this.hasUniqueSourceStorageInfo=o.length===1||o.slice(1).every(p=>kt(p,c)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var t;return(t=this.rasterJobHandler)==null?void 0:t.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t==null?void 0:t.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:s}=this.rasterInfo,e=await Z(()=>import("./densifyOperator-vIKWtKQ2-EpeBoYma.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url).then(r=>r.d),n=await Z(()=>import("./differenceOperator-Dvly1JND-DdJ4F2Z8.js"),__vite__mapDeps([11,3,4,5,6,7,1,2,8,9,10]),import.meta.url).then(r=>r.d);let o=e.execute(De.fromExtent(s),2*(s.width+s.height)/Tt);o=se(o,i.spatialReference),i=n.execute(o,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function kt(t,i){const{storageInfo:s,pixelSize:e,spatialReference:n,extent:o}=t,{storageInfo:r,pixelSize:a,spatialReference:c,extent:l}=i;return e.x===a.x&&e.y===a.y&&n.equals(c)&&o.equals(l)&&s.blockHeight===r.blockHeight&&s.blockWidth===r.blockWidth&&s.maximumPyramidLevel===r.maximumPyramidLevel}function Ft(t){return String(t.wkid??t.wkt??t.wkt2)}g([R({type:String,json:{write:!0}})],$.prototype,"datasetFormat",void 0),g([R()],$.prototype,"tileType",void 0),g([R()],$.prototype,"rasterFunction",void 0),g([R()],$.prototype,"primaryRasters",void 0),$=g([ae("esri.layers.support.rasterDatasets.FunctionRaster")],$);const xe=1e3,Gt=t=>{let i=class extends t{constructor(...e){var n;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=V((n=e[0])==null?void 0:n.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",ge(e,ie.getLogger(this)))}get renderer(){var o;if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?(o=n==null?void 0:n.find(({name:r})=>r===e))==null?void 0:o.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,o){var a,c;const r=(c=(a=n==null?void 0:n.layerDefinition)==null?void 0:a.drawingInfo)==null?void 0:c.renderer;return $e(r,o)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=ne(Ve,e).clone();const{serviceRasterInfo:o}=this;if(o==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:r}=e;if(r==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let a=r;const{spatialReference:c}=o;if(!r.spatialReference.equals(c)){await re();const d=r.type==="extent"?X(r,c):se(r,c);if(d==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");a=d}const l=e.pixelSize??new B({x:o.pixelSize.x,y:o.pixelSize.y,spatialReference:c}),{extent:u,width:h,height:f}=Rt(o,a,l),p=await this.fetchPixels(u,h,f,{...n,interpolation:"nearest"});if(p.pixelBlock==null)throw new N("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const y=await oe(p.pixelBlock,u,a),x=this._rasterJobHandler;return x?x.computeStatisticsHistograms({pixelBlock:y},n):nt(y)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const o=Oe({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:o,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:o}=this;if(!e||!n||!o)return;const{rasterInfo:r}=this.raster,a=ce(r,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),c=a==null?void 0:a.name,l=he(r,c);return this._updateSymbolizer(n,o,c,l)}async applyRenderer(e,n,o){const r=e==null?void 0:e.pixelBlock;if(!(r!=null&&r.pixels&&r.pixels.length>0))return null;await this.updateRenderer();const a=this.bandIds??[],{pixelBlock:c}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:a,symbolizer:this.symbolizer},o);return c}getTileUrl(e,n,o){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${o}`:""}getCompatibleTileInfo(e,n,o=!1){if(!this.loaded||n==null)return null;if(o&&e.equals(this.spatialReference))return this.tileInfo;const r=He(e);return Y.create({size:256,spatialReference:e,origin:r?{x:r.origin[0],y:r.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,o,r={}){var c;if(s(this),r.requestAsImageElement){const l=this.getTileUrl(e,n,o);return Ie(l,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:r.signal}).then(u=>u.data)}const{serviceRasterInfo:a}=this;if(a.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null){const l=r.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,n,o,l),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((c=this.renderer)==null?void 0:c.type)==="raster-shaded-relief"&&(r={...r,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,o,r)}async fetchPixels(e,n,o,r={}){return this.serviceRasterInfo.multidimensionalInfo!=null&&(r=this.normalizeRasterFetchOptions(r)).multidimensionalDefinition==null?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),o=Math.round(o),this.raster.fetchPixels(e,n,o,r))}async getSamples(e,n){var l;if(await this.load(),(e=ne(je,e).clone()).interpolation&&e.interpolation!=="nearest")throw new N("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const o=(l=e.mosaicRule)==null?void 0:l.multidimensionalDefinition,r={...n,multidimensionalDefinition:o},a=(await this._getSampleLocations(e)).map(u=>this.identify(u,r).then(h=>(h.location=u,h))),c=(await Promise.all(a)).flatMap((u,h)=>this._convertRasterIdentifyResultToSample(u,h));return new Ue({samples:c})}async identify(e,n={}){var l,u,h;await this.load();const{raster:o,serviceRasterInfo:r}=this;if((r==null?void 0:r.multidimensionalInfo)!=null&&!(r.hasMultidimensionalTranspose&&!(!we(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const a=(l=this.multidimensionalSubset)==null?void 0:l.areaOfInterest;if(a&&!a.contains(e))throw new N("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");const c=(u=this.serviceRasterInfo)!=null&&u.storageInfo.isBsqTile&&((h=this.bandIds)!=null&&h.length)?this.bandIds:void 0;return o.identify(e,{...n,bandIds:c})}hasStandardTime(){var r,a,c;const e=(r=this.serviceRasterInfo)==null?void 0:r.multidimensionalInfo;if(e==null||((a=this.serviceRasterInfo)==null?void 0:a.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,o=(c=n==null?void 0:n[0])==null?void 0:c.variableName;return e.variables.some(l=>l.name===o&&(!(n!=null&&n[0].dimensionName)||l.dimensions.some(u=>u.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ee(e)).toISOString()}getMultidimensionalSubsetVariables(e){var o;const n=e??((o=this.serviceRasterInfo)==null?void 0:o.multidimensionalInfo);return We(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Le(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&V(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;s(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,V(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:o,type:r}=n;if(r==="multipoint")return n.points.map(d=>new B({x:d[0],y:d[1],spatialReference:o}));if(r==="polyline"){let d=n;if(e.sampleCount||e.sampleDistance){const m=await Z(()=>import("./densifyOperator-vIKWtKQ2-EpeBoYma.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url).then(w=>w.d),I=(await Z(()=>import("./lengthOperator-C4ac9v9--CE9I01pZ.js"),__vite__mapDeps([12,1,2,3,5,4,6,7,8,9,10]),import.meta.url).then(w=>w.l)).execute(n,{unit:"meters"}),b=Math.min(e.sampleCount||100,xe);let S=e.sampleDistance;S||(S=I/(b+(d.paths[0].length===2?1:0))),d=m.execute(n,S,{unit:"meters"})}return d.paths.flatMap(m=>m.map(I=>new B({x:I[0],y:I[1],spatialReference:o})))}const a=Math.min(e.sampleCount||100,xe),c=n.type==="extent",l=c?n:n.extent,u=Math.sqrt(l.width*l.height/a),h=l.height/u,f=l.width/u,{xmin:p,ymax:y}=l,x=[];for(let d=0;d<h;d++)for(let m=0;m<f;m++){const I=new B({x:p+(m+.5)*u,y:y-(d+.5)*u,spatialReference:o});(c||n.contains(I))&&x.push(I)}return x}_configDefaultInterpolation(){var e;if(this.interpolation==null){s(this);const{raster:n}=this,o=Qe(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",o)}}_configDefaultRenderer(e="no"){var h,f,p;s(this);const{rasterInfo:n}=this.raster,o=ce(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=o==null?void 0:o.name,a=Xe({variableName:r,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(a==null?void 0:a.bandIds)??Ze(n)),!this.renderer||e==="override"){const y=Ye(this.raster),x=(a==null?void 0:a.renderer)??me(n,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:y}),d=n.statistics,m=d&&d.length>0?d[0]:null,I=(m==null?void 0:m.max)??0,b=(m==null?void 0:m.min)??0;this.raster.datasetFormat==="WCSServer"&&x.type==="raster-stretch"&&(I>1e24||b<-1e24)&&(x.dynamicRangeAdjustment=!0,x.customStatistics=null,x.stretchType==="none"&&(x.stretchType="min-max")),this.renderer=x}const c=Ke({...this.renderer.toJSON(),variableName:r}),l=he(n,r);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=l):this.symbolizer=new rt({rendererJSON:c,rasterInfo:l});const u=this.symbolizer.bind();if(u.success){if(e==="auto"){const{colormap:y}=this.raster.rasterInfo,x=this.renderer;if(y!=null&&x.type==="raster-colormap"){const d=me(this.raster.rasterInfo);JSON.stringify(d)!==JSON.stringify(x)&&this._configDefaultRenderer("override")}else if(x.type==="raster-stretch"){const d=(f=this.bandIds)==null?void 0:f.length,m=(p=x.customStatistics)==null?void 0:p.length;!x.dynamicRangeAdjustment&&m&&d&&m!==d&&this._configDefaultRenderer("override")}}}else ie.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var u;if(this._isConstructedFromFunctionRaster&&V(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ue.fromJSON(h)))}let e,n=this.raster,o=!1;V(n)?(e=n.primaryRasters.rasters,n=e[0],o=!0):e=[n];const{rasterFunction:r}=this;if(r){const h={raster:n};e.length>1&&e.forEach(y=>h[y.url]=y);const f=wt(((u=r.functionDefinition)==null?void 0:u.toJSON())??r.toJSON(),h),p=new $({rasterFunction:f});p.rasterJobHandler=this._rasterJobHandler,await p.open(),this.raster=p}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!o&&!r)return;const{bandIds:a}=this,{bandCount:c}=this.raster.rasterInfo,l=a!=null&&a.length?a.some(h=>h>=c):c>=3;a&&(l||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){var l;const{rasterInfo:o}=this.raster,r=o.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),a=(o.pixelSize.x+o.pixelSize.y)/2*r;if(!((l=e.dataSeries)!=null&&l.length))return[new fe({location:e.location,pixelValue:e.value,locationId:n,resolution:a})];const c=[];return e.dataSeries.forEach(({value:u,multidimensionalDefinition:h},f)=>{const p={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:x})=>x).join(",")};for(const{dimensionName:x,values:d}of h){p[x]=Array.isArray(d[0])?d[0][0]:d[0];const m=d[d.length-1];p[`${x}_Max`]=Array.isArray(m)?m[m.length-1]:m}const y=new fe({location:e.location,pixelValue:u,rasterId:f,locationId:n,resolution:a,attributes:p});c.push(y)}),c}};function s(e){if(!e.raster||!e.serviceRasterInfo)throw new N("imagery-tile","no raster")}return g([R({clonable:!1})],i.prototype,"_cachedRasterFunctionJson",void 0),g([R({clonable:!1})],i.prototype,"_compatibleFullExtent",void 0),g([R({clonable:!1})],i.prototype,"_isConstructedFromFunctionRaster",void 0),g([R({clonable:!1})],i.prototype,"_rasterFunctionUpdatePromise",void 0),g([R({type:[Be],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],i.prototype,"bandIds",void 0),g([R({json:{origins:{service:{read:{source:"copyrightText"}}}}})],i.prototype,"copyright",void 0),g([R({json:{read:!1}})],i.prototype,"fullExtent",null),g([R({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Je(it)],i.prototype,"interpolation",void 0),g([R()],i.prototype,"ioConfig",void 0),g([R({type:[Se],json:{write:!0}})],i.prototype,"multidimensionalDefinition",null),g([R({type:qe,json:{write:!0}})],i.prototype,"multidimensionalSubset",void 0),g([R()],i.prototype,"raster",void 0),g([R({type:ue})],i.prototype,"rasterFunction",null),g([R()],i.prototype,"serviceRasterInfo",void 0),g([R()],i.prototype,"sourceJSON",void 0),g([R({readOnly:!0,type:Re,json:{read:!1}})],i.prototype,"spatialReference",void 0),g([R({type:Y})],i.prototype,"tileInfo",void 0),g([R(be)],i.prototype,"url",null),g([R()],i.prototype,"renderer",null),g([R({types:Ae,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ge,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"&&e.type!=="flow"})}}}}})],i.prototype,"internalRenderer",null),g([Ce("internalRenderer")],i.prototype,"readRenderer",null),g([R({clonable:!1})],i.prototype,"symbolizer",void 0),i=g([ae("esri.layers.mixins.ImageryTileMixin")],i),i};function K(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=[];if(i){const o=K(t,s);for(let r=0;r<o.length;r++)K(o[r],i).forEach(a=>e.push(a));return e}const n=t.getElementsByTagNameNS("*",s);if(!n||n.length===0)return[];for(let o=0;o<n.length;o++)e.push(n[o]||n.item(o));return e}function _e(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const e=K(t,s);return e.length>0?i?_e(e[0],i):e[0]:null}function Te(t,i=null){const s=i?_e(t,i):t;let e;return s?(e=s.textContent||s.nodeValue,e?e.trim():null):null}function Pt(t,i){const s=K(t,i),e=[];let n;for(let o=0;o<s.length;o++)n=s[o].textContent||s[o].nodeValue,n&&(n=n.trim(),n!==""&&e.push(n));return e}function $t(t,i=null){var s;return((s=Te(t,i))==null?void 0:s.split(" ").map(e=>Number(e)))??[]}function Vt(t,i){return Pt(t,i).map(s=>Number(s))}function jt(t,i){const s=Te(t,i);return Number(s)}function Ut(t,i){var n;const s=(n=t==null?void 0:t.nodeName)==null?void 0:n.toLowerCase(),e=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===e}function Qt(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{jt as B,Vt as C,$t as D,$ as E,Ut as J,Qt as M,Gt as P,Pt as T,K as U,_e as a,Te as l,v as w};
