import{k as se}from"./asyncUtils-Cu__bxqs-ecCTUaGV.js";import{l as d,a4 as E,k2 as oe,k3 as re,ao as $,aS as V,fb as G,f8 as W,be as ce,aM as ue,P as J,M as B,j as fe,bk as he,k4 as me,B as pe,m as p,n as k,E as g}from"./index-BeTPrQ6f.js";import{N as H,W as U}from"./projectionUtils-CsX1UTBu-DsZaU4xz.js";import{e as C}from"./TileKey-1TQKLvpf-ByD6Ad6n.js";import{f as R}from"./GeometryDescriptor-CGSMioST-BjTCNFpW.js";import"./projectBuffer-CMNsPBq1-CMpE7Jo3.js";import"./zscale-PLuFqpaL-BIEnWBsg.js";class X{constructor(t,i){this.layer=t,this.parameters=i}}let de=class extends X{constructor(e,t,i){super(e,i),this.outSpatialReference=t,this.type="geometry"}selectTilesAtLOD(e){if(e<0)this.geometry.coordinates.forEach(t=>t.tile=null);else{const{tileInfo:t,tilemapCache:i}=this.layer,a=w(t,i)[e].level;this.geometry.coordinates.forEach(n=>n.tile=t.tileAt(a,n.x,n.y))}}allElevationTilesFetched(){return!this.geometry.coordinates.some(e=>!e.elevationTile)}clearElevationTiles(){for(const e of this.geometry.coordinates)e.elevationTile!==this.outsideExtentTile&&(e.elevationTile=null)}populateElevationTiles(e){var t;for(const i of this.geometry.coordinates)!i.elevationTile&&((t=i.tile)!=null&&t.id)&&(i.elevationTile=e[i.tile.id])}remapTiles(e){var t;for(const i of this.geometry.coordinates){const a=(t=i.tile)==null?void 0:t.id;i.tile=a?e[a]:null}}getTilesToFetch(){return re(this.geometry.coordinates.filter(({tile:e,elevationTile:t})=>(e==null?void 0:e.id)&&!t),(e,t)=>{var i,a;return((i=e.tile)==null?void 0:i.id)===((a=t.tile)==null?void 0:a.id)}).map(({tile:e})=>e)}forEachTileToFetch(e){for(const t of this.geometry.coordinates)t.tile&&!t.elevationTile&&e(t.tile,()=>t.tile=null)}};class ye extends X{constructor(t,i,a,n){super(t,a),this.maskExtents=n,this.type="extent",this.elevationTiles=[],this._candidateTiles=[],this._fetchedCandidates=new Set,this.extent=i.clone().intersection(t.fullExtent)}selectTilesAtLOD(t,i){const a=this._maximumLodForRequests(i),n=Math.min(a,t);n<0?this._candidateTiles.length=0:this._selectCandidateTilesCoveringExtentAt(n)}_maximumLodForRequests(t){const{tileInfo:i,tilemapCache:a}=this.layer,n=w(i,a);if(!t)return n.length-1;const l=this.extent;if(l==null)return-1;for(let s=n.length-1;s>=0;s--){const o=n[s],r=o.resolution*i.size[0],c=o.resolution*i.size[1];if(Math.ceil(l.width/r)*Math.ceil(l.height/c)<=t)return s}return-1}allElevationTilesFetched(){return this._candidateTiles.length===this.elevationTiles.length}clearElevationTiles(){this.elevationTiles.length=0,this._fetchedCandidates.clear()}populateElevationTiles(t){for(const i of this._candidateTiles){const a=i.id&&t[i.id];a&&(this._fetchedCandidates.add(i),this.elevationTiles.push(a))}}remapTiles(t){this._candidateTiles=Z(this._candidateTiles.map(i=>t[i.id]))}getTilesToFetch(){return this._candidateTiles}forEachTileToFetch(t,i){const a=this._candidateTiles;this._candidateTiles=[],a.forEach(n=>{if(this._fetchedCandidates.has(n))return void(i==null?void 0:i(n));let l=!1;t(n,()=>l=!0),l?i==null||i(n):this._candidateTiles.push(n)}),this._candidateTiles=Z(this._candidateTiles,i)}_selectCandidateTilesCoveringExtentAt(t){this._candidateTiles.length=0;const i=this.extent;if(i==null)return;const{tileInfo:a,tilemapCache:n}=this.layer,l=w(a,n)[t],s=a.tileAt(l.level,i.xmin,i.ymin),o=s.extent,r=l.resolution*a.size[0],c=l.resolution*a.size[1],f=Math.ceil((i.xmax-o[0])/r),u=Math.ceil((i.ymax-o[1])/c);for(let h=0;h<u;h++)for(let y=0;y<f;y++){const v=new C(s.level,s.row-h,s.col+y);a.updateTileInfo(v),this._tileIsMasked(v)||this._candidateTiles.push(v)}}_tileIsMasked(t){var i;return((i=this.maskExtents)==null?void 0:i.some(a=>G(a,t.extent)))??!1}}function M(e){return(e==null?void 0:e.tileInfo)!=null}function w(e,t){const i=e.lods;if(M(t)){const{effectiveMinLOD:a,effectiveMaxLOD:n}=t;return i.filter(l=>l.level>=a&&l.level<=n)}return i}function Z(e,t){const i={},a=[];for(const l of e){const s=l.id;s&&!i[s]?(i[s]=l,a.push(l)):t==null||t(l)}const n=a.sort((l,s)=>l.level-s.level);return n.filter((l,s)=>{for(let o=0;o<s;o++){const r=n[o].extent;if(r&&G(r,l.extent))return t==null||t(l),!1}return!0})}let ve=class{constructor(e,t){this.data=e,this.safeWidth=.99999999*(e.width-1),this.dx=(e.width-1)/(t[2]-t[0]),this.dy=(e.width-1)/(t[3]-t[1]),this.x0=t[0],this.y1=t[3]}};class K{constructor(t,i=null){if(this.key=t,i!=null){const a=t.extent;this._samplerData=new ve(i,a)}}get zmin(){return this._samplerData!=null?this._samplerData.data.minValue:0}get zmax(){return this._samplerData!=null?this._samplerData.data.maxValue:0}get hasNoDataValues(){var t;return!!((t=this._samplerData)!=null&&t.data.hasNoDataValues)}sample(t,i){if(this._samplerData==null)return;const{safeWidth:a,data:n,dx:l,dy:s,y1:o,x0:r}=this._samplerData,{width:c,values:f,noDataValue:u}=n,h=N(s*(o-i),0,a),y=N(l*(t-r),0,a),v=Math.floor(h),F=Math.floor(y),A=v*c+F,L=A+c,_=f[A],q=f[L],z=f[A+1],O=f[L+1];if(_!==u&&q!==u&&z!==u&&O!==u){const j=y-F,P=_+(z-_)*j;return P+(q+(O-q)*j-P)*(h-v)}}}function N(e,t,i){return e<t?t:e>i?i:e}let I=class extends fe{queryElevation(e){const t=this.projectIfRequired(e,this.spatialReference);if(!t)return null;switch(e.type){case"point":return xe(e,t,this);case"polyline":return Te(e,t,this);case"multipoint":return ge(e,t,this);default:return null}}projectIfRequired(e,t){if(e==null)return null;const i=e.spatialReference;if(i.equals(t))return e;const a=he(e,t);return a||J.getLogger(this).error(`Cannot project geometry spatial reference (wkid:${i.wkid}) to elevation sampler spatial reference (wkid:${t.wkid})`),a}};function xe(e,t,i){return e.hasZ=!0,e.z=i.elevationAt(t.x,t.y),e}function Te(e,t,i){m.spatialReference=t.spatialReference;const a=e.hasM&&!e.hasZ;for(let n=0;n<e.paths.length;n++){const l=e.paths[n],s=t.paths[n];for(let o=0;o<l.length;o++){const r=l[o],c=s[o];m.x=c[0],m.y=c[1],a&&(r[3]=r[2]),r[2]=i.elevationAt(m.x,m.y)}}return e.hasZ=!0,e}function ge(e,t,i){m.spatialReference=t.spatialReference;const a=e.hasM&&!e.hasZ;for(let n=0;n<e.points.length;n++){const l=e.points[n],s=t.points[n];m.x=s[0],m.y=s[1],a&&(l[3]=l[2]),l[2]=i.elevationAt(m.x,m.y)}return e.hasZ=!0,e}I=p([k("esri.layers.support.ElevationSampler")],I);const m=new pe;let T=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(e){const t=e.noDataValue,i="tiles"in e?e.tiles.map(n=>new x({tile:n,tileInfo:e.tileInfo,noDataValue:t})):e.samplers;super({noDataValue:t,samplers:i});const a=i[0];if(a){this.extent=a.extent.clone();const{min:n,max:l}=a.demResolution;this.demResolution={min:n,max:l};for(let s=1;s<i.length;s++){const o=i[s];this.extent.union(o.extent),this.demResolution.min=Math.min(this.demResolution.min,o.demResolution.min),this.demResolution.max=Math.max(this.demResolution.max,o.demResolution.max)}}else{const n="tileInfo"in e?e.tileInfo:null;this.extent=W(ue(),(n==null?void 0:n.spatialReference)??ce.WGS84),this.demResolution={min:0,max:0}}}elevationAt(e,t){let i;for(const a of this.samplers)if(a.containsAt(e,t)&&(i=a.elevationAt(e,t),i!==a.noDataValue))return i;return i??(J.getLogger(this).warn("#elevationAt()",`Point used to sample elevation (${e}, ${t}) is outside of the sampler`),this.noDataValue)}};p([g({constructOnly:!0})],T.prototype,"noDataValue",void 0),p([g({constructOnly:!0})],T.prototype,"samplers",void 0),T=p([k("esri.layers.support.TileElevationSampler")],T);let x=class extends I{get spatialReference(){return this.extent.spatialReference}constructor(e){super(e);const t=e.tile.key.extent;this.extent=W(t,e.tileInfo.spatialReference),this.extent.zmin=e.tile.zmin,this.extent.zmax=e.tile.zmax;const i=E(e.tileInfo.spatialReference),a=e.tileInfo.lodAt(e.tile.key.level).resolution*i;this.demResolution={min:a,max:a}}contains(e){const t=this.projectIfRequired(e,this.spatialReference);return t!=null&&this.containsAt(t.x,t.y)}containsAt(e,t){return me(this.tile.key.extent,e,t)}elevationAt(e,t){return this.containsAt(e,t)?this.tile.sample(e,t)??this.noDataValue:this.noDataValue}};p([g({constructOnly:!0})],x.prototype,"tile",void 0),p([g({constructOnly:!0})],x.prototype,"noDataValue",void 0),p([g({constructOnly:!0})],x.prototype,"tileInfo",void 0),x=p([k("esri.layers.support.TileElevationSampler.SingleTileElevationSampler")],x);async function je(e,t,i){if(e=i!=null&&i.ignoreInvisibleLayers?e.filter(r=>r.visible):e.slice(),!e.length)throw new d(b,"Elevation queries require at least one elevation layer to fetch tiles from");const a=R.fromGeometry(t),n={...S,...i,returnSampleInfo:!0},l=e.pop(),s=await Q(l,a,n),o=await te(e,s,n);return o.geometry=o.geometry.export(),i!=null&&i.returnSampleInfo||delete o.sampleInfo,o}async function Q(e,t,i){if(!e)throw new d(b,"Elevation queries require an elevation layer to fetch tiles from");if(!t||!(t instanceof R)&&t.type!=="point"&&t.type!=="multipoint"&&t.type!=="polyline")throw new d("elevation-query:invalid-geometry","Only point, polyline and multipoint geometries can be used to query elevation");const a={...S,...i},n=new de(e,t.spatialReference,a),l=a.signal;return await e.load({signal:l}),await Ie(n,t,l),await ie(n,l),await D(n,l),Ve(n),ke(n,l)}async function Pe(e,t,i){if(e=Array.isArray(e)?e:[e],(e=i!=null&&i.ignoreInvisibleLayers?e.filter(l=>l.visible):e.slice()).length===0)throw new d(b,"Elevation queries require at least one elevation layer to fetch tiles from");if(!t||t.type!=="extent")throw new d("elevation-query:invalid-extent","Invalid or undefined extent");const a={...S,...i,returnSampleInfo:!0},n=Y(e[e.length-1],t,a);return e.length===1?n:ee(e,t,await n,a)}async function Y(e,t,i,a){const n=i.signal;await e.load({signal:n});const l=t.spatialReference,s=e.tileInfo.spatialReference;l.equals(s)||(await H([{source:l,dest:s}],{signal:n}),t=U(t,s));const o=new ye(e,t,i,a);await ie(o,n),await D(o,n);const r=o.elevationTiles,c=o.layer.tileInfo,f=o.parameters.noDataValue;return new T({noDataValue:f,tiles:r,tileInfo:c})}async function ee(e,t,i,a){if(e.pop(),!e.length)return i;const n=i.samplers.filter(r=>!r.tile.hasNoDataValues).map(r=>oe(r.extent)),l=await Y(e[e.length-1],t,a,n);if(l.samplers.length===0)return i;const s=i.samplers.concat(l.samplers),o=a.noDataValue;return ee(e,t,new T({samplers:s,noDataValue:o}),a)}async function te(e,t,i){const a=t.geometry.coordinates,n=t.sampleInfo;$(n);const l=new Array,s=new Array;for(let u=0;u<a.length;u++)n[u].demResolution<0&&e.length&&(l.push(a[u]),s.push(u));const o=e.pop();if(o==null||l.length===0)return t;const r=t.geometry.clone(l),c=await Q(o,r,i),f=c.sampleInfo;if(!f)throw new Error("no sampleInfo");return s.forEach((u,h)=>{a[u].z=c.geometry.coordinates[h].z,n[u].demResolution=f[h].demResolution,n[u].source=f[h].source}),te(e,t,i)}async function ie(e,t){e.type==="geometry"&&Ee(e);const i=e.parameters.demResolution;if(typeof i=="number")Ae(e,i);else if(i==="finest-contiguous")await we(e,t);else{if(i!=="auto")throw new d("elevation-query:invalid-dem-resolution",`Invalid dem resolution value '${i}', expected a number, "finest-contiguous" or "auto"`);await Re(e,t)}}async function we(e,t){const{tileInfo:i,tilemapCache:a}=e.layer,n=le(i,a,e.parameters.minDemResolution);await ae(e,n,t)}async function ae(e,t,i){const a=e.layer;if(e.selectTilesAtLOD(t),t<0)return;const n=a.tilemapCache,l=e.getTilesToFetch();try{if(n&&!M(n))await V(Promise.all(l.map(s=>n.fetchAvailability(s.level,s.row,s.col,{signal:i}))),i);else if(await D(e,i),!e.allElevationTilesFetched())throw e.clearElevationTiles(),new d("elevation-query:has-unavailable-tiles","Some elevation tiles are unavailable")}catch(s){B(s),await ae(e,t-1,i)}}async function Re(e,t){_e(e),qe(e);const i=e.layer.tilemapCache;if(!i||M(i))return ne(e,t);const a=e.getTilesToFetch(),n={},l=a.map(async s=>{const o=new C(0,0,0),r=await se(i.fetchAvailabilityUpsample(s.level,s.row,s.col,o,{signal:t}));r.ok!==!1?s.id!=null&&(n[s.id]=o):B(r.error)});await V(Promise.all(l),t),e.remapTiles(n)}async function ne(e,t){const i=e.layer.tileInfo;await D(e,t);let a=!1;e.forEachTileToFetch((n,l)=>{i.upsampleTile(n)?a=!0:l()}),a&&await ne(e,t)}function le(e,t,i=0){const a=w(e,t);let n=a.length-1;if(i>0){const l=i/E(e.spatialReference),s=a.findIndex(o=>o.resolution<l);s===0?n=0:s>0&&(n=s-1)}return n}const S={maximumAutoTileRequests:20,noDataValue:0,returnSampleInfo:!1,demResolution:"auto",minDemResolution:0,signal:null};async function Ie(e,t,i){let a;const n=e.layer.tileInfo.spatialReference;if(t instanceof R?a=await t.project(n,i):(await H([{source:t.spatialReference,dest:n}],{signal:i}),a=U(t,n)),!a)throw new d("elevation-query:spatial-reference-mismatch",`Cannot query elevation in '${t.spatialReference.wkid}' on an elevation service in '${n.wkid}'`);e.geometry=R.fromGeometry(a)}function Ee(e){if(e.layer.fullExtent==null)return;const t=new K(new C(-1,-1,-1));t.sample=()=>e.parameters.noDataValue,e.outsideExtentTile=t;const i=e.layer.fullExtent;e.geometry.coordinates.forEach(a=>{const n=a.x,l=a.y;(n<i.xmin||n>i.xmax||l<i.ymin||l>i.ymax)&&(a.elevationTile=t)})}function De(e,t){const{tileInfo:i,tilemapCache:a}=e.layer,n=t/E(i.spatialReference),l=w(i,a);let s=l[0],o=0;for(let r=1;r<l.length;r++){const c=l[r];Math.abs(c.resolution-n)<Math.abs(s.resolution-n)&&(s=c,o=r)}return o}function Ae(e,t){const i=De(e,t);e.selectTilesAtLOD(i)}function _e(e){const{tileInfo:t,tilemapCache:i}=e.layer,a=le(t,i,e.parameters.minDemResolution);e.selectTilesAtLOD(a,e.parameters.maximumAutoTileRequests)}async function D(e,t){const i=e.getTilesToFetch(),a={},n=e.parameters.cache,l=e.parameters.noDataValue,s={noDataValue:l,signal:t},o=i.map(async r=>{if(r.id==null)return;const c=`${e.layer.uid}:${r.id}:${l}`,f=n==null?void 0:n.get(c),u=f??await e.layer.fetchTile(r.level,r.row,r.col,s);n==null||n.put(c,u),a[r.id]=new K(r,u)});await V(Promise.allSettled(o),t),e.populateElevationTiles(a)}function qe(e){const t=e.layer.tileInfo;let i=0;const a={},n=o=>{o.id!=null&&(o.id in a?a[o.id]++:(a[o.id]=1,i++))},l=o=>{if(o.id==null)return;const r=a[o.id];r===1?(delete a[o.id],i--):a[o.id]=r-1};e.forEachTileToFetch(n,l);let s=!0;for(;s&&(s=!1,e.forEachTileToFetch(o=>{i<=e.parameters.maximumAutoTileRequests||(l(o),t.upsampleTile(o)&&(s=!0),n(o))},l),s););}function Ve(e){e.geometry.coordinates.forEach(t=>{const i=t.elevationTile;let a=e.parameters.noDataValue;if(i){const n=i.sample(t.x,t.y);n==null?t.elevationTile=null:a=n}t.z=a})}async function ke(e,t){const i=await e.geometry.project(e.outSpatialReference,t);$(i);const a={geometry:i.export(),noDataValue:e.parameters.noDataValue};return e.parameters.returnSampleInfo&&(a.sampleInfo=Ce(e)),e.geometry.coordinates.forEach(n=>{n.tile=null,n.elevationTile=null}),a}function Ce(e){const t=e.layer.tileInfo,i=E(t.spatialReference);return e.geometry.coordinates.map(a=>{let n=-1;return a.elevationTile&&a.elevationTile!==e.outsideExtentTile&&(n=t.lodAt(a.elevationTile.key.level).resolution*i),{demResolution:n,source:n===-1?void 0:e.layer}})}const b="elevation-query:invalid-layer";export{b as InvalidLayerError,Pe as createSampler,S as defaultOptions,le as getFinestLodIndex,Q as query,je as queryAll};
