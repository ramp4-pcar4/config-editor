import{v as N,I as q,a1 as Ct,t as Dt,c9 as Rt,Y as Lt,c as jt,z as Gt,a8 as Q,a5 as et,H as Et,fC as At,cT as Ot,s as Nt,d5 as $t}from"./index-C8m3jhgc.js";import{p as ft}from"./pixelRangeUtils-BteWOAF5-CWUmGYA-.js";let bt=class{constructor(t=null,e=null,n=null){this.minValue=t,this.maxValue=e,this.noDataValue=n}};var K;let O=K=class extends Lt{static createEmptyBand(t,e){return new(K.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,n=new Uint8Array(e).fill(255);for(let s=0;s<t.length;s++){const o=t[s];for(let i=0;i<e;i++)o[i]||(n[i]=0)}return n}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){var t;return(t=this.pixels)==null?void 0:t.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new jt("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new bt)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map(n=>qt(n,this.mask));const t=this.mask;let e=0;if(t!=null)for(let n=0;n<t.length;n++)t[n]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||t==="f64"||t==="f32"||!this.pixels)return;const[e,n]=ft(t),s=this.pixels,o=this.width*this.height,i=s.length;let l,f,h;const a=[];for(let r=0;r<i;r++){h=K.createEmptyBand(t,o),l=s[r];for(let c=0;c<o;c++)f=l[c],h[c]=f>n?n:f<e?e:f;a.push(h)}this.pixels=a,this.pixelType=t}extractBands(t){var c;const{pixels:e,statistics:n}=this;if(t==null||t.length===0||!e||e.length===0)return this;const s=e.length,o=t.some(p=>p>=e.length),i=s===t.length&&!t.some((p,u)=>p!==u);if(o||i)return this;const l=((c=this.bandMasks)==null?void 0:c.length)===s?t.map(p=>this.bandMasks[p]):void 0;let{mask:f,validPixelCount:h}=this;const{width:a,height:r}=this;return l!=null&&l.length&&(f=K.combineBandMasks(l),h=f.filter(p=>!!p).length),new K({pixelType:this.pixelType,width:a,height:r,mask:f,bandMasks:l,validPixelCount:h,maskIsAlpha:this.maskIsAlpha,pixels:t.map(p=>e[p]),statistics:n&&t.map(p=>n[p])})}clone(){const t=new K({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;this.mask!=null&&(t.mask=new Uint8Array(this.mask)),this.bandMasks&&(t.bandMasks=this.bandMasks.map(s=>new Uint8Array(s)));const n=K.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const s=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=s?this.pixels[e].slice():new n(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=Gt(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:n,premultiplyAlpha:s,pixels:o}=this;if(!t||!(o!=null&&o.length))return void Q.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let i,l,f,h;i=l=f=o[0],o.length>=3?(l=o[1],f=o[2]):o.length===2&&(l=o[1]);const a=new Uint32Array(t),r=this.width*this.height;if(i.length===r)if(e!=null&&e.length===r)if(n)for(h=0;h<r;h++){const c=e[h];if(c){const p=c/255;a[h]=s?c<<24|f[h]*p<<16|l[h]*p<<8|i[h]*p:c<<24|f[h]<<16|l[h]<<8|i[h]}}else for(h=0;h<r;h++)e[h]&&(a[h]=255<<24|f[h]<<16|l[h]<<8|i[h]);else for(h=0;h<r;h++)a[h]=255<<24|f[h]<<16|l[h]<<8|i[h];else Q.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:n,statistics:s}=this;if(!t||!(e!=null&&e.length))return void Q.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const o=this.pixelType;let i=1,l=0,f=1;if(s&&s.length>0){for(const d of s)if(d.minValue!=null&&(l=Math.min(l,d.minValue)),d.maxValue!=null&&d.minValue!=null){const x=d.maxValue-d.minValue;f=Math.max(f,x)}i=255/f}else{let d=255;o==="s8"?(l=-128,d=127):o==="u16"?d=65535:o==="s16"?(l=-32768,d=32767):o==="u32"?d=4294967295:o==="s32"?(l=-2147483648,d=2147483647):o==="f32"?(l=-34e38,d=34e38):o==="f64"&&(l=-Number.MAX_VALUE,d=Number.MAX_VALUE),i=255/(d-l)}const h=new Uint32Array(t),a=this.width*this.height;let r,c,p,u,m;if(r=c=p=e[0],r.length!==a)return Q.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(c=e[1],e.length>=3&&(p=e[2]),n!=null&&n.length===a)for(u=0;u<a;u++)n[u]&&(h[u]=255<<24|(p[u]-l)*i<<16|(c[u]-l)*i<<8|(r[u]-l)*i);else for(u=0;u<a;u++)h[u]=255<<24|(p[u]-l)*i<<16|(c[u]-l)*i<<8|(r[u]-l)*i;else if(n!=null&&n.length===a)for(u=0;u<a;u++)m=(r[u]-l)*i,n[u]&&(h[u]=255<<24|m<<16|m<<8|m);else for(u=0;u<a;u++)m=(r[u]-l)*i,h[u]=255<<24|m<<16|m<<8|m}_fillFrom32Bit(t){const{pixels:e,mask:n}=this;if(!t||!(e!=null&&e.length))return Q.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let s,o,i,l;s=o=i=e[0],e.length>=3?(o=e[1],i=e[2]):e.length===2&&(o=e[1]);const f=this.width*this.height;if(s.length!==f)return Q.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(n!=null&&n.length===f)for(l=0;l<f;l++)t[h++]=s[l],t[h++]=o[l],t[h++]=i[l],t[h++]=1&n[l];else for(l=0;l<f;l++)t[h++]=s[l],t[h++]=o[l],t[h++]=i[l],t[h++]=1}};function qt(t,e){let n=1/0,s=-1/0;const o=t.length;let i,l=0;if(e!=null)for(i=0;i<o;i++)e[i]&&(l=t[i],n=l<n?l:n,s=l>s?l:s);else for(i=0;i<o;i++)l=t[i],n=l<n?l:n,s=l>s?l:s;return new bt(n,s)}N([q({json:{write:!0}})],O.prototype,"width",void 0),N([q({json:{write:!0}})],O.prototype,"height",void 0),N([q({json:{write:!0}})],O.prototype,"pixelType",void 0),N([Ct("pixelType")],O.prototype,"castPixelType",null),N([q({json:{write:!0}})],O.prototype,"validPixelCount",void 0),N([q({json:{write:!0}})],O.prototype,"mask",void 0),N([q({json:{write:!0}})],O.prototype,"maskIsAlpha",void 0),N([q({json:{write:!0}})],O.prototype,"pixels",void 0),N([q()],O.prototype,"premultiplyAlpha",void 0),N([q({json:{write:!0}})],O.prototype,"statistics",void 0),N([q({json:{write:!0}})],O.prototype,"depthCount",void 0),N([q({json:{write:!0}})],O.prototype,"noDataValues",void 0),N([q({json:{write:!0}})],O.prototype,"bandMasks",void 0),O=K=N([Dt("esri.layers.support.PixelBlock")],O);const D=O;var dt,mt;(function(t){t[t.matchAny=0]="matchAny",t[t.matchAll=1]="matchAll"})(dt||(dt={})),function(t){t[t.bestMatch=0]="bestMatch",t[t.fail=1]="fail"}(mt||(mt={}));const de=6;function L(t){return t!=null&&t.declaredClass==="esri.layers.support.PixelBlock"&&t.pixels&&t.pixels.length>0}function me(t){var r;if(!(t!=null&&t.length)||t.some(c=>!L(c)))return null;if(t.length===1)return((r=t[0])==null?void 0:r.clone())??null;const e=t,{width:n,height:s,pixelType:o}=e[0];if(e.some(c=>c.width!==n||c.height!==s))return null;const i=e.map(({mask:c})=>c).filter(c=>c!=null);let l=null;i.length&&(l=new Uint8Array(n*s),l.set(i[0]),i.length>1&&Ut(i.slice(1),l));const f=[];e.forEach(({pixels:c})=>f.push(...c));const h=e.map(({statistics:c})=>c).filter(c=>c==null?void 0:c.length),a=[];return h.forEach(c=>a.push(...c)),new D({pixelType:o,width:n,height:s,mask:l,pixels:f,statistics:a.length?a:null})}function ge(t){if(!t)return;const e=t.colormap;if(!e||e.length===0)return;const n=e.sort((c,p)=>c[0]-p[0]);let s=0;n[0][0]<0&&(s=n[0][0]);const o=Math.max(256,n[n.length-1][0]-s+1),i=new Uint8Array(4*o),l=[];let f,h=0,a=0;const r=n[0].length===5;if(o>65536)return n.forEach(c=>{l[c[0]-s]=r?c.slice(1):c.slice(1).concat([255])}),{indexed2DColormap:l,offset:s,alphaSpecified:r};if(t.fillUnspecified)for(f=n[a],h=f[0]-s;h<o;h++)i[4*h]=f[1],i[4*h+1]=f[2],i[4*h+2]=f[3],i[4*h+3]=r?f[4]:255,h===f[0]-s&&(f=a===n.length-1?f:n[++a]);else for(h=0;h<n.length;h++)f=n[h],a=4*(f[0]-s),i[a]=f[1],i[a+1]=f[2],i[a+2]=f[3],i[a+3]=r?f[4]:255;return{indexedColormap:i,offset:s,alphaSpecified:r}}function xe(t,e){if(!L(t)||!e||!e.indexedColormap&&!e.indexed2DColormap)return t;const n=t.clone(),s=n.pixels;let o=n.mask;const i=n.width*n.height;if(s.length!==1)return t;const{indexedColormap:l,indexed2DColormap:f,offset:h,alphaSpecified:a}=e;let r=0;const c=s[0],p=new Uint8Array(c.length),u=new Uint8Array(c.length),m=new Uint8Array(c.length);let d,x=0;if(l){const w=l.length-1;if(o!=null)for(r=0;r<i;r++)o[r]&&(x=4*(c[r]-h),x<h||x>w?o[r]=0:(p[r]=l[x],u[r]=l[x+1],m[r]=l[x+2],o[r]=l[x+3]));else{for(o=new Uint8Array(i),r=0;r<i;r++)x=4*(c[r]-h),x<h||x>w?o[r]=0:(p[r]=l[x],u[r]=l[x+1],m[r]=l[x+2],o[r]=l[x+3]);n.mask=o}}else if(f)if(o!=null)for(r=0;r<i;r++)o[r]&&(d=f[c[r]],p[r]=d[0],u[r]=d[1],m[r]=d[2],o[r]=d[3]);else{for(o=new Uint8Array(i),r=0;r<i;r++)d=f[c[r]],p[r]=d[0],u[r]=d[1],m[r]=d[2],o[r]=d[3];n.mask=o}return n.pixels=[p,u,m],n.statistics=null,n.pixelType="u8",n.maskIsAlpha=a,n}function we(t,e){if(!L(t))return null;const{pixels:n,mask:s}=t,o=n.length;let i=e.lut;const{offset:l}=e;i&&i[0].length===1&&(i=n.map(()=>i));const f=[],h=e.outputPixelType||"u8";for(let r=0;r<o;r++){const c=vt(n[r],s,i[r],l||0,h);f.push(c)}const a=new D({width:t.width,height:t.height,pixels:f,mask:s,pixelType:h});return a.updateStatistics(),a}function vt(t,e,n,s,o){const i=t.length,l=D.createEmptyBand(o,i);if(e)for(let f=0;f<i;f++)e[f]&&(l[f]=n[t[f]-s]);else for(let f=0;f<i;f++)l[f]=n[t[f]-s];return l}function ye(t,e){if(!L(t))return null;const n=t.clone(),{pixels:s}=n,o=n.width*n.height,i=e.length,l=Math.floor(i/2),f=e[Math.floor(l)],h=s[0];let a,r,c,p,u,m,d=!1;const x=new Uint8Array(o),w=new Uint8Array(o),M=new Uint8Array(o);let k=n.mask;const y=e[0].mappedColor.length===4;for(k||(k=new Uint8Array(o),k.fill(y?255:1),n.mask=k),u=0;u<o;u++)if(k[u]){for(a=h[u],d=!1,m=l,r=f,c=0,p=i-1;p-c>1;){if(a===r.value){d=!0;break}a>r.value?c=m:p=m,m=Math.floor((c+p)/2),r=e[Math.floor(m)]}d||(a===e[c].value?(r=e[c],d=!0):a===e[p].value?(r=e[p],d=!0):a<e[c].value?(d=!1,r=null):a>e[c].value&&(a<e[p].value?(r=e[c],d=!0):p===i-1?(d=!1,r=null):(r=e[p],d=!0))),d?(x[u]=r.mappedColor[0],w[u]=r.mappedColor[1],M[u]=r.mappedColor[2],k[u]=r.mappedColor[3]):x[u]=w[u]=M[u]=k[u]=0}return n.pixels=[x,w,M],n.mask=k,n.pixelType="u8",n.maskIsAlpha=y,n}function ke(t,e){if(!L(t))return null;const{width:n,height:s}=t,{inputRanges:o,outputValues:i,outputPixelType:l,noDataRanges:f,allowUnmatched:h,isLastInputRangeInclusive:a}=e,r=t.pixels[0],c=D.createEmptyBand(l,r.length),p=t.mask,u=new Uint8Array(n*s);p?u.set(p):u.fill(255);const m=t.pixelType.startsWith("f")?1e-6:0,d=o.map(y=>y-m);d[0]=o[0],d[d.length-1]=o[o.length-1]+(a?1e-6:0);const x=o.length/2,[w,M]=ft(l);for(let y=0;y<s;y++)for(let g=0;g<n;g++){const A=y*n+g;if(u[A]){const U=r[A];let v=!1;for(let S=x-1;S>=0;S--)if(U===d[2*S]||U>d[2*S]&&U<d[2*S+1]){c[A]=i[S],v=!0;break}v||(h?c[A]=U>M?M:U<w?w:U:u[A]=0)}}const k=f==null?void 0:f.length;if(k)for(let y=0;y<s;y++)for(let g=0;g<n;g++){const A=y*n+g;if(!p||p[A]){const U=r[A];for(let v=0;v<k;v+=2)if(U>=f[v]&&U<=f[v+1]){c[A]=0,u[A]=0;break}}}return new D({width:n,height:s,pixelType:l,pixels:[c],mask:u})}function gt(t,e,n,s){const o=n!=null&&n.length>=2?new Set(n):null,i=(n==null?void 0:n.length)===1?n[0]:null,l=!!(e!=null&&e.length);for(let f=0;f<t.length;f++)if(s[f]){const h=t[f];if(l){let a=!1;for(let r=0;r<e.length;r+=2)if(h>=e[r]&&h<=e[r+1]){a=!0;break}a||(s[f]=0)}s[f]&&(h===i||o!=null&&o.has(h))&&(s[f]=0)}}function xt(t,e){const n=t[0].length;for(let s=0;s<n;s++)if(e[s]){let o=!1;for(let i=0;i<t.length;i++)if(t[i][s]){o=!0;break}o||(e[s]=0)}}function Ut(t,e){const n=t[0].length;for(let s=0;s<n;s++)if(e[s]){let o=!1;for(let i=0;i<t.length;i++)if(t[i][s]===0){o=!0;break}o&&(e[s]=0)}}function Me(t,e){if(!L(t))return null;const{width:n,height:s,pixels:o}=t,i=n*s,l=new Uint8Array(i);t.mask?l.set(t.mask):l.fill(255);const f=o.length,{includedRanges:h,noDataValues:a,outputPixelType:r,matchAll:c,lookups:p}=e;if(p){const u=[];for(let m=0;m<f;m++){const d=p[m],x=vt(o[m],l,d.lut,d.offset||0,"u8");u.push(x)}u.length===1?l.set(u[0]):c?xt(u,l):Ut(u,l)}else if(c){const u=[];for(let m=0;m<f;m++){const d=new Uint8Array(i);d.set(l),gt(o[m],h==null?void 0:h.slice(2*m,2*m+2),a==null?void 0:a[m],d),u.push(d)}u.length===1?l.set(u[0]):xt(u,l)}else for(let u=0;u<f;u++)gt(o[u],h==null?void 0:h.slice(2*u,2*u+2),a==null?void 0:a[u],l);return new D({width:n,height:s,pixelType:r,pixels:o,mask:l})}function Ae(t){const{srcPixelType:e,inputRanges:n,outputValues:s,allowUnmatched:o,noDataRanges:i,isLastInputRangeInclusive:l,outputPixelType:f}=t;if(e!=="u8"&&e!=="s8"&&e!=="u16"&&e!=="s16")return null;const h=e.includes("16")?65536:256,a=e.includes("s")?-h/2:0,r=D.createEmptyBand(f,h),c=new Uint8Array(h);o&&c.fill(255);const[p,u]=ft(f);if(n!=null&&n.length&&(s!=null&&s.length)){const m=n.map(d=>d-1e-6);m[0]=n[0],l&&(m[m.length-1]=n[n.length-1]);for(let d=0;d<m.length;d++){const x=s[d]>u?u:s[d]<p?p:s[d],w=Math.ceil(m[2*d]-a),M=Math.floor(m[2*d+1]-a);for(let k=w;k<=M;k++)r[k]=x,c[k]=255}}if(i!=null&&i.length)for(let m=0;m<i.length;m++){const d=Math.ceil(i[2*m]-a),x=Math.floor(i[2*m+1]-a);for(let w=d;w<=x;w++)c[w]=0}return{lut:r,offset:a,mask:c}}function be(t,e,n){if(t!=="u8"&&t!=="s8"&&t!=="u16"&&t!=="s16")return null;const s=t.includes("16")?65536:256,o=t.includes("s")?-s/2:0,i=new Uint8Array(s);if(e)for(let l=0;l<e.length;l++){const f=Math.ceil(e[2*l]-o),h=Math.floor(e[2*l+1]-o);for(let a=f;a<=h;a++)i[a]=255}else i.fill(255);if(n)for(let l=0;l<n.length;l++)i[n[l]-o]=0;return{lut:i,offset:o}}function Wt(t,e,n,s,o,i,l,f){return{xmin:o<=n*t?0:o<n*t+t?o-n*t:t,ymin:i<=s*e?0:i<s*e+e?i-s*e:e,xmax:o+l<=n*t?0:o+l<n*t+t?o+l-n*t:t,ymax:i+f<=s*e?0:i+f<s*e+e?i+f-s*e:e}}function ve(t,e){if(!t||t.length===0)return null;const n=t.find(m=>m.pixelBlock);if((n==null?void 0:n.pixelBlock)==null)return null;const s=(n.extent.xmax-n.extent.xmin)/n.pixelBlock.width,o=(n.extent.ymax-n.extent.ymin)/n.pixelBlock.height,i=.01*Math.min(s,o),l=t.sort((m,d)=>Math.abs(m.extent.ymax-d.extent.ymax)>i?d.extent.ymax-m.extent.ymax:Math.abs(m.extent.xmin-d.extent.xmin)>i?m.extent.xmin-d.extent.xmin:0),f=Math.min.apply(null,l.map(m=>m.extent.xmin)),h=Math.min.apply(null,l.map(m=>m.extent.ymin)),a=Math.max.apply(null,l.map(m=>m.extent.xmax)),r=Math.max.apply(null,l.map(m=>m.extent.ymax)),c={x:Math.round((e.xmin-f)/s),y:Math.round((r-e.ymax)/o)},p={width:Math.round((a-f)/s),height:Math.round((r-h)/o)},u={width:Math.round((e.xmax-e.xmin)/s),height:Math.round((e.ymax-e.ymin)/o)};return Math.round(p.width/n.pixelBlock.width)*Math.round(p.height/n.pixelBlock.height)!==l.length||c.x<0||c.y<0||p.width<u.width||p.height<u.height?null:{extent:e,pixelBlock:Xt(l.map(m=>m.pixelBlock),p,{clipOffset:c,clipSize:u})}}function at(t,e,n,s,o,i){const{width:l,height:f}=n.block,{x:h,y:a}=n.offset,{width:r,height:c}=n.mosaic,p=Wt(l,f,s,o,h,a,r,c);let u=0,m=0;if(i){const d=i.hasGCSSShiftTransform?360:i.halfWorldWidth??0,x=l*i.resolutionX,w=i.startX+s*x;w<d&&w+x>d?m=i.rightPadding:w>=d&&(u=i.leftMargin-i.rightPadding,m=0)}if(p.xmax-=m,typeof e!="number")for(let d=p.ymin;d<p.ymax;d++){const x=(o*f+d-a)*r+(s*l-h)+u,w=d*l;for(let M=p.xmin;M<p.xmax;M++)t[x+M]=e[w+M]}else for(let d=p.ymin;d<p.ymax;d++){const x=(o*f+d-a)*r+(s*l-h)+u;for(let w=p.xmin;w<p.xmax;w++)t[x+w]=e}}function Xt(t,e,n={}){var B;const{clipOffset:s,clipSize:o,alignmentInfo:i,blockWidths:l}=n;if(l)return zt(t,e,{blockWidths:l});const f=t.find(T=>L(T));if(f==null)return null;const h=o?o.width:e.width,a=o?o.height:e.height,r=f.width,c=f.height,p=e.width/r,u=e.height/c,m={offset:s||{x:0,y:0},mosaic:o||e,block:{width:r,height:c}},d=f.pixelType,x=D.getPixelArrayConstructor(d),w=f.pixels.length,M=[];let k,y;for(let T=0;T<w;T++){y=new x(h*a);for(let b=0;b<u;b++)for(let I=0;I<p;I++){const F=t[b*p+I];L(F)&&(k=F.pixels[T],at(y,k,m,I,b,i))}M.push(y)}const g=t.some(T=>T==null||T.mask!=null&&T.mask.length>0),A=t.some(T=>(T==null?void 0:T.bandMasks)&&T.bandMasks.length>1),U=g?new Uint8Array(h*a):void 0,v=A?[]:void 0;if(U){for(let T=0;T<u;T++)for(let b=0;b<p;b++){const I=t[T*p+b],F=I!=null?I.mask:null;at(U,F??(I?255:0),m,b,T,i)}if(v)for(let T=0;T<w;T++){const b=new Uint8Array(h*a);for(let I=0;I<u;I++)for(let F=0;F<p;F++){const P=t[I*p+F],V=((B=P==null?void 0:P.bandMasks)==null?void 0:B[T])??(P==null?void 0:P.mask);at(b,V??(P?255:0),m,F,I,i)}v.push(b)}}const S=new D({width:h,height:a,pixels:M,pixelType:d,bandMasks:v,mask:U});return S.updateStatistics(),S}function zt(t,e,n){var x;const s=t.find(w=>w!=null);if(s==null)return null;const o=t.some(w=>w==null||!!w.mask),{width:i,height:l}=e,f=o?new Uint8Array(i*l):null,{blockWidths:h}=n,a=[],r=s.getPlaneCount(),c=D.getPixelArrayConstructor(s.pixelType);if(o)for(let w=0,M=0;w<t.length;M+=h[w],w++){const k=t[w];if(!L(k))continue;const y=k.mask;for(let g=0;g<l;g++)for(let A=0;A<h[w];A++)f[g*i+A+M]=y==null?255:y[g*k.width+A]}const p=t.some(w=>(w==null?void 0:w.bandMasks)&&w.bandMasks.length>1),u=p?[]:void 0,m=i*l;for(let w=0;w<r;w++){const M=new c(m),k=p?new Uint8Array(m):void 0;for(let y=0,g=0;y<t.length;g+=h[y],y++){const A=t[y];if(!L(A))continue;const U=A.pixels[w];if(U!=null){for(let v=0;v<l;v++)for(let S=0;S<h[y];S++)M[v*i+S+g]=U[v*A.width+S];if(k){const v=((x=A.bandMasks)==null?void 0:x[w])??A.mask;for(let S=0;S<l;S++)for(let B=0;B<h[y];B++)k[S*i+B+g]=v?v[S*A.width+B]:255}}}a.push(M),u&&k&&u.push(k)}const d=new D({width:i,height:l,mask:f,bandMasks:u,pixels:a,pixelType:s.pixelType});return d.updateStatistics(),d}function Ue(t,e,n){if(!L(t))return null;const{width:s,height:o}=t,i=e.x,l=e.y,f=n.width+i,h=n.height+l;if(i<0||l<0||f>s||h>o||i===0&&l===0&&f===s&&h===o)return t;t.mask||(t.mask=new Uint8Array(s*o));const a=t.mask;for(let r=0;r<o;r++){const c=r*s;for(let p=0;p<s;p++)a[c+p]=r<l||r>=h||p<i||p>=f?0:1}return t.updateStatistics(),t}function Jt(t){if(!L(t))return null;const e=t.clone(),{width:n,height:s,pixels:o}=t,i=o[0],l=e.pixels[0],f=t.mask;for(let h=2;h<s-1;h++){const a=new Map;for(let c=h-2;c<h+2;c++)for(let p=0;p<4;p++){const u=c*n+p;lt(a,i[u],f?f[u]:1)}l[h*n]=wt(a),l[h*n+1]=l[h*n+2]=l[h*n];let r=3;for(;r<n-1;r++){let c=(h-2)*n+r+1;lt(a,i[c],f?f[c]:1),c=(h-1)*n+r+1,lt(a,i[c],f?f[c]:1),c=h*n+r+1,lt(a,i[c],f?f[c]:1),c=(h+1)*n+r+1,lt(a,i[c],f?f[c]:1),c=(h-2)*n+r-3,st(a,i[c],f?f[c]:1),c=(h-1)*n+r-3,st(a,i[c],f?f[c]:1),c=h*n+r-3,st(a,i[c],f?f[c]:1),c=(h+1)*n+r-3,st(a,i[c],f?f[c]:1),l[h*n+r]=wt(a)}l[h*n+r+1]=l[h*n+r]}for(let h=0;h<n;h++)l[h]=l[n+h]=l[2*n+h],l[(s-1)*n+h]=l[(s-2)*n+h];return e.updateStatistics(),e}function wt(t){if(t.size===0)return 0;let e=0,n=-1,s=0;const o=t.keys();let i=o.next();for(;!i.done;)s=t.get(i.value),s>e&&(n=i.value,e=s),i=o.next();return n}function st(t,e,n){if(n===0)return;const s=t.get(e);s===1?t.delete(e):t.set(e,s-1)}function lt(t,e,n){n!==0&&t.set(e,t.has(e)?t.get(e)+1:1)}function Tt(t,e,n){let{x:s,y:o}=e;const{width:i,height:l}=n;if(s===0&&o===0&&l===t.height&&i===t.width)return t;const{width:f,height:h}=t,a=Math.max(0,o),r=Math.max(0,s),c=Math.min(s+i,f),p=Math.min(o+l,h);if(c<0||p<0||!L(t))return null;s=Math.max(0,-s),o=Math.max(0,-o);const{pixels:u}=t,m=i*l,d=u.length,x=[];for(let y=0;y<d;y++){const g=u[y],A=D.createEmptyBand(t.pixelType,m);for(let U=a;U<p;U++){const v=U*f;let S=(U+o-a)*i+s;for(let B=r;B<c;B++)A[S++]=g[v+B]}x.push(A)}const w=new Uint8Array(m),M=t.mask;for(let y=a;y<p;y++){const g=y*f;let A=(y+o-a)*i+s;for(let U=r;U<c;U++)w[A++]=M?M[g+U]:1}const k=new D({width:n.width,height:n.height,pixelType:t.pixelType,pixels:x,mask:w});return k.updateStatistics(),k}function It(t,e=!0){if(!L(t))return null;const{pixels:n,width:s,height:o,mask:i,pixelType:l}=t,f=[],h=Math.round(s/2),a=Math.round(o/2),r=o-1,c=s-1;for(let u=0;u<n.length;u++){const m=n[u],d=D.createEmptyBand(l,h*a);let x=0;for(let w=0;w<o;w+=2)for(let M=0;M<s;M+=2){const k=m[w*s+M];if(e){const y=M===c?k:m[w*s+M+1],g=w===r?k:m[w*s+M+s],A=M===c?g:w===r?y:m[w*s+M+s+1];d[x++]=(k+y+g+A)/4}else d[x++]=k}f.push(d)}let p=null;if(i!=null){p=new Uint8Array(h*a);let u=0;for(let m=0;m<o;m+=2)for(let d=0;d<s;d+=2){const x=i[m*s+d];if(e){const w=d===c?x:i[m*s+d+1],M=m===r?x:i[m*s+d+s],k=d===c?M:m===r?w:i[m*s+d+s+1];p[u++]=x*w*M*k?1:0}else p[u++]=x}}return new D({width:h,height:a,pixelType:l,pixels:f,mask:p})}function Te(t,e,n=0,s=!0){if(!L(t))return null;const{width:o,height:i}=e;let{width:l,height:f}=t;const h=new Map,a={x:0,y:0},r=1+n;let c=t;for(let p=0;p<r;p++){const u=Math.ceil(l/o),m=Math.ceil(f/i);for(let d=0;d<m;d++){a.y=d*i;for(let x=0;x<u;x++){a.x=x*o;const w=Tt(c,a,e);h.set(`${p}/${d}/${x}`,w)}}p<r-1&&(c=It(c,s)),l=Math.round(l/2),f=Math.round(f/2)}return h}function Ie(t){const{pixelBlock:e,tileSize:n,level:s,row:o,col:i,useBilinear:l}=t;if(!L(e))return null;const{width:f,height:h}=n,a=2**s,r=a*f,c=a*h;let p=Tt(e,{y:o*c,x:i*r},{width:r,height:c});if(!p)return null;for(let u=s;u>0;u--)p=It(p,l);return p}function Bt(t,e,n,s,o=0){const{width:i,height:l}=t,{width:f,height:h}=e,a=s.cols,r=s.rows,c=Math.ceil(f/a-.1/a),p=Math.ceil(h/r-.1/r);let u,m,d,x,w,M,k;const y=c*a,g=y*p*r,A=new Float32Array(g),U=new Float32Array(g),v=new Uint32Array(g),S=new Uint32Array(g);let B,T,b=0;for(let I=0;I<p;I++)for(let F=0;F<c;F++){u=12*(I*c+F),m=n[u],d=n[u+1],x=n[u+2],w=n[u+3],M=n[u+4],k=n[u+5];for(let P=0;P<r;P++){b=(I*r+P)*y+F*a,T=(P+.5)/r;for(let V=0;V<P;V++)B=(V+.5)/a,A[b+V]=(m*B+d*T+x)*i+o,U[b+V]=(w*B+M*T+k)*l+o,v[b+V]=Math.floor(A[b+V]),S[b+V]=Math.floor(U[b+V])}u+=6,m=n[u],d=n[u+1],x=n[u+2],w=n[u+3],M=n[u+4],k=n[u+5];for(let P=0;P<r;P++){b=(I*r+P)*y+F*a,T=(P+.5)/r;for(let V=P;V<a;V++)B=(V+.5)/a,A[b+V]=(m*B+d*T+x)*i+o,U[b+V]=(w*B+M*T+k)*l+o,v[b+V]=Math.floor(A[b+V]),S[b+V]=Math.floor(U[b+V])}}return{offsets_x:A,offsets_y:U,offsets_xi:v,offsets_yi:S,gridWidth:y}}function Be(t,e){const{coefficients:n,spacing:s}=e,{offsets_x:o,offsets_y:i,gridWidth:l}=Bt(t,t,n,{rows:s[0],cols:s[1]}),{width:f,height:h}=t,a=new Float32Array(f*h),r=180/Math.PI;for(let c=0;c<h;c++)for(let p=0;p<f;p++){const u=c*l+p,m=c===0?u:u-l,d=c===h-1?u:u+l,x=o[m]-o[d],w=i[d]-i[m];if(isNaN(x)||isNaN(w))a[c*f+p]=90;else{let M=Math.atan2(w,x)*r;M=(360+M)%360,a[c*f+p]=M}}return a}function Pe(t,e,n,s,o="nearest"){if(!L(t))return null;o==="majority"&&(t=Jt(t));const{pixels:i,mask:l,bandMasks:f,pixelType:h}=t,a=t.width,r=t.height,c=D.getPixelArrayConstructor(h),p=i.length,{width:u,height:m}=e;let d=!1;for(let b=0;b<n.length;b+=3)n[b]===-1&&n[b+1]===-1&&n[b+2]===-1&&(d=!0);const{offsets_x:x,offsets_y:w,offsets_xi:M,offsets_yi:k,gridWidth:y}=Bt({width:a,height:r},e,n,s,o==="majority"?.5:0);let g;const A=(b,I,F,P)=>{const V=b instanceof Float32Array||b instanceof Float64Array?0:.5;for(let j=0;j<m;j++){g=j*y;for(let _=0;_<u;_++){if(x[g]<0||w[g]<0)b[j*u+_]=0;else if(P)b[j*u+_]=I[M[g]+k[g]*a];else{const E=Math.floor(x[g]),$=Math.floor(w[g]),W=Math.ceil(x[g]),J=Math.ceil(w[g]),z=x[g]-E,Y=w[g]-$;if(!F||F[E+$*a]&&F[W+$*a]&&F[E+J*a]&&F[W+J*a]){const tt=(1-z)*I[E+$*a]+z*I[W+$*a],C=(1-z)*I[E+J*a]+z*I[W+J*a];b[j*u+_]=(1-Y)*tt+Y*C+V}else b[j*u+_]=I[M[g]+k[g]*a]}g++}}},U=[];let v;const S=(f==null?void 0:f.length)===p,B=[];for(let b=0;b<p;b++){if(S){const I=new Uint8Array(u*m);A(I,f[b],f[b],!0),B.push(I)}v=new c(u*m),A(v,i[b],S?f[b]:l,o==="nearest"||o==="majority"),U.push(v)}const T=new D({width:u,height:m,pixelType:h,pixels:U,bandMasks:S?B:void 0});if(l!=null)T.mask=new Uint8Array(u*m),A(T.mask,l,l,!0);else if(d){T.mask=new Uint8Array(u*m);for(let b=0;b<u*m;b++)T.mask[b]=x[b]<0||w[b]<0?0:1}return T.updateStatistics(),T}const Z=new Map;Z.set("meter-per-second",1),Z.set("kilometer-per-hour",.277778),Z.set("knots",.514444),Z.set("feet-per-second",.3048),Z.set("mile-per-hour",.44704);const ct=180/Math.PI,ut=5,ot=new Rt({esriMetersPerSecond:"meter-per-second",esriKilometersPerHour:"kilometer-per-hour",esriKnots:"knots",esriFeetPerSecond:"feet-per-second",esriMilesPerHour:"mile-per-hour"});function pt(t,e){return Z.get(t)/Z.get(e)||1}function Pt(t){return(450-t)%360}function St(t,e="geographic"){const[n,s]=t,o=Math.sqrt(n*n+s*s);let i=Math.atan2(s,n)*ct;return i=(360+i)%360,e==="geographic"&&(i=Pt(i)),[o,i]}function Kt(t,e="geographic"){let n=t[1];e==="geographic"&&(n=Pt(n)),n%=360;const s=t[0];return[s*Math.cos(n/ct),s*Math.sin(n/ct)]}function Se(t,e,n,s="geographic"){if(!L(t)||n==null)return t;const o=e==="vector-magdir"?t.clone():yt(t,e),i=o.pixels[1];for(let l=0;l<i.length;l++)i[l]=s==="geographic"?(i[l]+n[l]+270)%360:(i[l]+360-n[l])%360;return e==="vector-magdir"?o:yt(o,"vector-magdir")}function yt(t,e,n="geographic",s=1){if(!L(t))return t;const{pixels:o,width:i,height:l}=t,f=i*l,h=o[0],a=o[1],r=t.pixelType.startsWith("f")?t.pixelType:"f32",c=D.createEmptyBand(r,f),p=D.createEmptyBand(r,f);let u=0;for(let d=0;d<l;d++)for(let x=0;x<i;x++)e==="vector-uv"?([c[u],p[u]]=St([h[u],a[u]],n),c[u]*=s):([c[u],p[u]]=Kt([h[u],a[u]],n),c[u]*=s,p[u]*=s),u++;const m=new D({pixelType:r,width:t.width,height:t.height,mask:t.mask,validPixelCount:t.validPixelCount,maskIsAlpha:t.maskIsAlpha,pixels:[c,p]});return m.updateStatistics(),m}function Fe(t,e,n=1){if(n===1||!L(t))return t;const s=t.clone(),{pixels:o,width:i,height:l}=s,f=o[0];o[1];let h=0;for(let a=0;a<l;a++)for(let r=0;r<i;r++)f[h]*=n,h++;return s.updateStatistics(),s}function Ve(t,e,n,s,o){if(o==null||!o.spatialReference.equals(t.spatialReference))return{extent:t,width:Math.round(e/s),height:Math.round(n/s),resolution:t.width/e};const i=o.xmin,l=o.ymax,f=(t.xmax-t.xmin)/e*s,h=(t.ymax-t.ymin)/n*s,a=(f+h)/2;return t.xmin=i+Math.floor((t.xmin-i)/f)*f,t.xmax=i+Math.ceil((t.xmax-i)/f)*f,t.ymin=l+Math.floor((t.ymin-l)/h)*h,t.ymax=l+Math.ceil((t.ymax-l)/h)*h,{extent:t,width:Math.round(t.width/f),height:Math.round(t.height/h),resolution:a}}const Yt=Ft(0,0,0);function Ft(t=0,e=0,n=Math.PI,s=!0){s&&(n=(2*Math.PI-n)%(2*Math.PI));const o=s?-1:1,i=13*o,l=-7*o,f=-2*o,h=-16*o,a=21.75,[r,c]=G(0,e+i,n,a),[p,u]=G(t-5.5,e+l,n,a),[m,d]=G(t+5.5,e+l,n,a),[x,w]=G(t-1.5,e+f,n,a),[M,k]=G(t+1.5,e+f,n,a),[y,g]=G(t-1.5,e+h,n,a),[A,U]=G(t+1.5,e+h,n,a);return[r,c,p,u,x,w,M,k,m,d,y,g,A,U]}function Ht(t=0,e=Math.PI,n=!0){n&&(e=(2*Math.PI-e)%(2*Math.PI));const s=10,o=n?-1:1,i=5*o,l=20*o,f=25*o,h=45,a=0,r=0,c=2,p=0,u=c*o,m=n?1:-1,d=s/2*m;let[x,w]=[a+d,r-l],[M,k]=[x+c*m,w],[y,g]=[M-p*m,k+u],[A,U]=[a-d,r-f],[v,S]=[A+p*m,U-u],B=Math.ceil(t/ut),T=Math.floor(B/10);B-=8*T;const b=[],I=[];for(let z=0;z<B/2;z++,T--){T<=0&&B%2==1&&z===(B-1)/2&&(A=a,v=A+p*m,U=(U+w)/2,S=U-u);const[Y,tt]=G(A,U,e,h);if(T>0){const[C,R]=G(M,U,e,h),[nt,it]=G(x,w,e,h);b.push(C),b.push(R),b.push(Y),b.push(tt),b.push(nt),b.push(it)}else{const[C,R]=G(M,k,e,h),[nt,it]=G(y,g,e,h),[Vt,_t]=G(v,S,e,h);I.push(Y),I.push(tt),I.push(Vt),I.push(_t),I.push(nt),I.push(it),I.push(C),I.push(R)}U+=i,w+=i,k+=i,g+=i,S+=i}const[F,P]=G(a+d,r+l,e,h),V=(s/2+c)*m,[j,_]=G(a+V,r+l,e,h),[E,$]=G(a+d,r-f,e,h),[W,J]=G(a+V,r-f,e,h);return{pennants:b,barbs:I,shaft:[F,P,j,_,E,$,W,J]}}function G(t,e,n,s=1){const o=Math.sqrt(t*t+e*e)/s,i=(2*Math.PI+Math.atan2(e,t))%(2*Math.PI);return[o,(2*Math.PI+i-n)%(2*Math.PI)]}const rt=[0,1,3,6,10,16,21,27,33,40,47,55,63],Qt=[0,.5,1,1.5,2],Zt=[0,.25,.5,1,1.5,2,2.5,3,3.5,4];function H(t,e,n,s){const o=pt(s||"knots",n);let i;for(i=1;i<e.length;i++)if(i===e.length-1){if(t<e[i]*o)break}else if(t<=e[i]*o)break;return Math.min(i-1,e.length-2)}function te(t,e,n,s,o){let i=0;switch(e){case"beaufort_kn":i=H(t,rt,"knots",n);break;case"beaufort_km":i=H(t,rt,"kilometer-per-hour",n);break;case"beaufort_ft":i=H(t,rt,"feet-per-second",n);break;case"beaufort_m":i=H(t,rt,"meter-per-second",n);break;case"classified_arrow":i=H(t,o??[],s,n);break;case"ocean_current_m":i=H(t,Qt,"meter-per-second",n);break;case"ocean_current_kn":i=H(t,Zt,"knots",n)}return i}function ee(t,e){const{style:n,inputUnit:s,outputUnit:o,breakValues:i}=e,l=ot.fromJSON(s),f=ot.fromJSON(o),h=7*6,a=15;let r=0,c=0;const{width:p,height:u,mask:m}=t,d=t.pixels[0],x=t.pixels[1],w=m!=null?m.filter(g=>g>0).length:p*u,M=new Float32Array(w*h),k=new Uint32Array(a*w),y=e.invertDirection?Ft(0,0,0,!1):Yt;for(let g=0;g<u;g++)for(let A=0;A<p;A++){const U=g*p+A;if(!m||m[g*p+A]){const v=(x[U]+360)%360/180*Math.PI,S=te(d[U],n,l,f,i);for(let T=0;T<y.length;T+=2)M[r++]=(A+.5)/p,M[r++]=(g+.5)/u,M[r++]=y[T],M[r++]=y[T+1]+v,M[r++]=S,M[r++]=d[U];const B=7*(r/h-1);k[c++]=B,k[c++]=B+1,k[c++]=B+2,k[c++]=B+0,k[c++]=B+4,k[c++]=B+3,k[c++]=B+0,k[c++]=B+2,k[c++]=B+3,k[c++]=B+2,k[c++]=B+5,k[c++]=B+3,k[c++]=B+5,k[c++]=B+6,k[c++]=B+3}}return{vertexData:M,indexData:k}}const ht=[];function ne(t,e){if(ht.length===0)for(let u=0;u<30;u++)ht.push(Ht(5*u,0,!e.invertDirection));const n=pt(ot.fromJSON(e.inputUnit),"knots"),{width:s,height:o,mask:i}=t,l=t.pixels[0],f=t.pixels[1],h=6,a=[],r=[];let c=0,p=0;for(let u=0;u<o;u++)for(let m=0;m<s;m++){const d=u*s+m,x=l[d]*n;if((!i||i[u*s+m])&&x>=ut){const w=(f[d]+360)%360/180*Math.PI,{pennants:M,barbs:k,shaft:y}=ht[Math.min(Math.floor(x/5),29)];if(M.length+k.length===0)continue;let g=a.length/h;const A=(m+.5)/s,U=(u+.5)/o;for(let v=0;v<M.length;v+=2)a[c++]=A,a[c++]=U,a[c++]=M[v],a[c++]=M[v+1]+w,a[c++]=0,a[c++]=x;for(let v=0;v<k.length;v+=2)a[c++]=A,a[c++]=U,a[c++]=k[v],a[c++]=k[v+1]+w,a[c++]=0,a[c++]=x;for(let v=0;v<y.length;v+=2)a[c++]=A,a[c++]=U,a[c++]=y[v],a[c++]=y[v+1]+w,a[c++]=0,a[c++]=x;for(let v=0;v<M.length/6;v++)r[p++]=g,r[p++]=g+1,r[p++]=g+2,g+=3;for(let v=0;v<k.length/8;v++)r[p++]=g,r[p++]=g+1,r[p++]=g+2,r[p++]=g+1,r[p++]=g+2,r[p++]=g+3,g+=4;r[p++]=g+0,r[p++]=g+1,r[p++]=g+2,r[p++]=g+1,r[p++]=g+3,r[p++]=g+2,g+=4}}return{vertexData:new Float32Array(a),indexData:new Uint32Array(r)}}function ie(t,e){let n=0,s=0;const{width:o,height:i,mask:l}=t,f=t.pixels[0],h=[],a=[],r=pt(ot.fromJSON(e.inputUnit),"knots"),c=e.style==="wind_speed"?ut:Number.MAX_VALUE;for(let p=0;p<i;p++)for(let u=0;u<o;u++){const m=f[p*o+u]*r;if((!l||l[p*o+u])&&m<c){for(let x=0;x<4;x++)h[n++]=(u+.5)/o,h[n++]=(p+.5)/i,h[n++]=x<2?-.5:.5,h[n++]=x%2==0?-.5:.5,h[n++]=0,h[n++]=m;const d=4*(n/24-1);a[s++]=d,a[s++]=d+1,a[s++]=d+2,a[s++]=d+1,a[s++]=d+2,a[s++]=d+3}}return{vertexData:new Float32Array(h),indexData:new Uint32Array(a)}}function _e(t,e){return e.style==="simple_scalar"?ie(t,e):e.style==="wind_speed"?ne(t,e):ee(t,e)}function Ce(t,e,n,s=[0,0],o=.5){const{width:i,height:l,mask:f}=t,[h,a]=t.pixels,[r,c]=s,p=Math.round((i-r)/n),u=Math.round((l-c)/n),m=p*u,d=new Float32Array(m),x=new Float32Array(m),w=new Uint8Array(m);for(let k=0;k<u;k++)for(let y=0;y<p;y++){let g=0;const A=k*p+y,U=Math.max(0,k*n+c),v=Math.max(0,y*n+r),S=Math.min(l,U+n),B=Math.min(i,v+n);for(let T=U;T<S;T++)for(let b=v;b<B;b++){const I=T*i+b;if(!f||f[I]){g++;const F=[h[I],a[I]],[P,V]=F;d[A]+=P,x[A]+=V}}if(g>=(S-U)*(B-v)*(1-o)){w[A]=1;const[T,b]=St([d[A]/g,x[A]/g]);d[A]=T,x[A]=b}else w[A]=0,d[A]=0,x[A]=0}const M=new D({width:p,height:u,pixels:[d,x],mask:w});return M.updateStatistics(),M}const X=()=>Q.getLogger("esri.views.2d.engine.flow.dataUtils"),le=10;async function De(t,e,n,s){const o=performance.now(),i=se(e,n),l=performance.now(),f=oe(e,i,n.width,n.height),h=performance.now(),a=he(f),r=performance.now(),c=t==="Streamlines"?ce(a,le):fe(a),p=performance.now();return et("esri-2d-profiler")&&(X().info("I.1","_createFlowFieldFromData (ms)",Math.round(l-o)),X().info("I.2","_getStreamlines (ms)",Math.round(h-l)),X().info("I.3","createAnimatedLinesData (ms)",Math.round(r-h)),X().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(p-r)),X().info("I.5","createFlowMesh (ms)",Math.round(p-o)),X().info("I.6","Mesh size (bytes)",c.vertexData.buffer.byteLength+c.indexData.buffer.byteLength)),await Promise.resolve(),Et(s),c}function se(t,e){const n=ae(e.data,e.width,e.height,t.smoothing);return t.interpolate?(s,o)=>{const i=Math.floor(s),l=Math.floor(o);if(i<0||i>=e.width)return[0,0];if(l<0||l>=e.height)return[0,0];const f=s-i,h=o-l,a=i,r=l,c=i<e.width-1?i+1:i,p=l<e.height-1?l+1:l,u=n[2*(r*e.width+a)],m=n[2*(r*e.width+c)],d=n[2*(p*e.width+a)],x=n[2*(p*e.width+c)],w=n[2*(r*e.width+a)+1],M=n[2*(r*e.width+c)+1];return[(u*(1-h)+d*h)*(1-f)+(m*(1-h)+x*h)*f,(w*(1-h)+n[2*(p*e.width+a)+1]*h)*(1-f)+(M*(1-h)+n[2*(p*e.width+c)+1]*h)*f]}:(s,o)=>{const i=Math.round(s),l=Math.round(o);return i<0||i>=e.width||l<0||l>=e.height?[0,0]:[n[2*(l*e.width+i)],n[2*(l*e.width+i)+1]]}}function re(t,e,n,s,o,i,l,f,h){const a=[];let r=n,c=s,p=0,[u,m]=e(r,c);u*=t.velocityScale,m*=t.velocityScale;const d=Math.sqrt(u*u+m*m);let x,w;a.push({x:r,y:c,t:p,speed:d});for(let M=0;M<t.verticesPerLine;M++){let[k,y]=e(r,c);k*=t.velocityScale,y*=t.velocityScale;const g=Math.sqrt(k*k+y*y);if(g<t.minSpeedThreshold)return a;const A=k/g,U=y/g;if(r+=A*t.segmentLength,c+=U*t.segmentLength,p+=t.segmentLength/g,Math.acos(A*x+U*w)>t.maxTurnAngle)return a;if(t.collisions){const v=Math.round(r*h),S=Math.round(c*h);if(v<0||v>l-1||S<0||S>f-1)return a;const B=i[S*l+v];if(B!==-1&&B!==o)return a;i[S*l+v]=o}a.push({x:r,y:c,t:p,speed:g}),x=A,w=U}return a}function oe(t,e,n,s){const o=[],i=new At,l=1/Math.max(t.lineCollisionWidth,1),f=Math.round(n*l),h=Math.round(s*l),a=new Int32Array(f*h);for(let c=0;c<a.length;c++)a[c]=-1;const r=[];for(let c=0;c<s;c+=t.lineSpacing)for(let p=0;p<n;p+=t.lineSpacing)r.push({x:p,y:c,sort:i.getFloat()});r.sort((c,p)=>c.sort-p.sort);for(const{x:c,y:p}of r)if(i.getFloat()<t.density){const u=re(t,e,c,p,o.length,a,f,h,l);if(u.length<2)continue;o.push(u)}return o}function ae(t,e,n,s){if(s===0)return t;const o=Math.round(3*s),i=new Array(2*o+1);let l=0;for(let a=-o;a<=o;a++){const r=Math.exp(-a*a/(s*s));i[a+o]=r,l+=r}for(let a=-o;a<=o;a++)i[a+o]/=l;const f=new Float32Array(t.length);for(let a=0;a<n;a++)for(let r=0;r<e;r++){let c=0,p=0;for(let u=-o;u<=o;u++){if(r+u<0||r+u>=e)continue;const m=i[u+o];c+=m*t[2*(a*e+(r+u))],p+=m*t[2*(a*e+(r+u))+1]}f[2*(a*e+r)]=c,f[2*(a*e+r)+1]=p}const h=new Float32Array(t.length);for(let a=0;a<e;a++)for(let r=0;r<n;r++){let c=0,p=0;for(let u=-o;u<=o;u++){if(r+u<0||r+u>=n)continue;const m=i[u+o];c+=m*f[2*((r+u)*e+a)],p+=m*f[2*((r+u)*e+a)+1]}h[2*(r*e+a)]=c,h[2*(r*e+a)+1]=p}return h}function he(t,e){const n=new At,s=t.reduce((h,a)=>h+a.length,0),o=new Float32Array(4*s),i=new Array(t.length);let l=0,f=0;for(const h of t){const a=l;for(const r of h)o[4*l]=r.x,o[4*l+1]=r.y,o[4*l+2]=r.t,o[4*l+3]=r.speed,l++;i[f++]={startVertex:a,numberOfVertices:h.length,totalTime:h[h.length-1].t,timeSeed:n.getFloat()}}return{lineVertices:o,lineDescriptors:i}}function ce(t,e){const{lineVertices:n,lineDescriptors:s}=t;let o=0,i=0;for(const p of s)o+=2*p.numberOfVertices,i+=6*(p.numberOfVertices-1);const l=new Float32Array(o*9),f=new Uint32Array(i);let h=0,a=0;function r(){f[a++]=h-2,f[a++]=h,f[a++]=h-1,f[a++]=h,f[a++]=h+1,f[a++]=h-1}function c(p,u,m,d,x,w,M,k){const y=h*9;let g=0;l[y+g++]=p,l[y+g++]=u,l[y+g++]=1,l[y+g++]=m,l[y+g++]=w,l[y+g++]=M,l[y+g++]=d/2,l[y+g++]=x/2,l[y+g++]=k,h++,l[y+g++]=p,l[y+g++]=u,l[y+g++]=-1,l[y+g++]=m,l[y+g++]=w,l[y+g++]=M,l[y+g++]=-d/2,l[y+g++]=-x/2,l[y+g++]=k,h++}for(const p of s){const{totalTime:u,timeSeed:m}=p;let d=null,x=null,w=null,M=null,k=null,y=null;for(let g=0;g<p.numberOfVertices;g++){const A=n[4*(p.startVertex+g)],U=n[4*(p.startVertex+g)+1],v=n[4*(p.startVertex+g)+2],S=n[4*(p.startVertex+g)+3];let B=null,T=null,b=null,I=null;if(g>0){B=A-d,T=U-x;const F=Math.sqrt(B*B+T*T);if(B/=F,T/=F,g>1){let P=B+k,V=T+y;const j=Math.sqrt(P*P+V*V);P/=j,V/=j;const _=Math.min(1/(P*B+V*T),e);P*=_,V*=_,b=-V,I=P}else b=-T,I=B;b!==null&&I!==null&&(c(d,x,w,b,I,u,m,S),r())}d=A,x=U,w=v,k=B,y=T,M=S}c(d,x,w,-y,k,u,m,M)}return{vertexData:l,indexData:f}}function fe(t){const{lineVertices:e,lineDescriptors:n}=t;let s=0,o=0;for(const b of n){const I=b.numberOfVertices-1;s+=4*I*2,o+=6*I*2}const i=new Float32Array(s*16),l=new Uint32Array(o);let f,h,a,r,c,p,u,m,d,x,w,M,k,y,g=0,A=0;function U(){l[A++]=g-8,l[A++]=g-7,l[A++]=g-6,l[A++]=g-7,l[A++]=g-5,l[A++]=g-6,l[A++]=g-4,l[A++]=g-3,l[A++]=g-2,l[A++]=g-3,l[A++]=g-1,l[A++]=g-2}function v(b,I,F,P,V,j,_,E,$,W,J,z,Y,tt){const C=g*16;let R=0;for(const nt of[1,2])for(const it of[1,2,3,4])i[C+R++]=b,i[C+R++]=I,i[C+R++]=F,i[C+R++]=P,i[C+R++]=_,i[C+R++]=E,i[C+R++]=$,i[C+R++]=W,i[C+R++]=nt,i[C+R++]=it,i[C+R++]=Y,i[C+R++]=tt,i[C+R++]=V/2,i[C+R++]=j/2,i[C+R++]=J/2,i[C+R++]=z/2,g++}function S(b,I){let F=d+w,P=x+M;const V=Math.sqrt(F*F+P*P);F/=V,P/=V;const j=d*F+x*P;F/=j,P/=j;let _=w+k,E=M+y;const $=Math.sqrt(_*_+E*E);_/=$,E/=$;const W=w*_+M*E;_/=W,E/=W,v(f,h,a,r,-P,F,c,p,u,m,-E,_,b,I),U()}function B(b,I,F,P,V,j){if(d=w,x=M,w=k,M=y,d==null&&x==null&&(d=w,x=M),c!=null&&p!=null){k=b-c,y=I-p;const _=Math.sqrt(k*k+y*y);k/=_,y/=_}d!=null&&x!=null&&S(V,j),f=c,h=p,a=u,r=m,c=b,p=I,u=F,m=P}function T(b,I){d=w,x=M,w=k,M=y,d==null&&x==null&&(d=w,x=M),d!=null&&x!=null&&S(b,I)}for(const b of n){f=null,h=null,a=null,r=null,c=null,p=null,u=null,m=null,d=null,x=null,w=null,M=null,k=null,y=null;const{totalTime:I,timeSeed:F}=b;for(let P=0;P<b.numberOfVertices;P++)B(e[4*(b.startVertex+P)],e[4*(b.startVertex+P)+1],e[4*(b.startVertex+P)+2],e[4*(b.startVertex+P)+3],I,F);T(I,F)}return{vertexData:i,indexData:l}}function kt(t,e){const n=e.pixels,{width:s,height:o}=e,i=new Float32Array(s*o*2),l=e.mask||new Uint8Array(s*o*2);if(e.mask||l.fill(255),t==="vector-uv")for(let f=0;f<s*o;f++)i[2*f]=n[0][f],i[2*f+1]=-n[1][f];else if(t==="vector-magdir")for(let f=0;f<s*o;f++){const h=n[0][f],a=$t(n[1][f]),r=Math.cos(a-Math.PI/2),c=Math.sin(a-Math.PI/2);i[2*f]=r*h,i[2*f+1]=c*h}return{data:i,mask:l,width:s,height:o}}async function Re(t,e,n,s,o,i){const l=performance.now(),f=Ot(e.spatialReference);if(!f){const y=await Mt(t,e,n,s,o,i);return et("esri-2d-profiler")&&X().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-l)),et("esri-2d-profiler")&&X().info("I.9","Number of parts",1),y}const[h,a]=f.valid,r=a-h,c=Math.ceil(e.width/r),p=e.width/c,u=Math.round(n/c);let m=e.xmin;const d=[],x=performance.now();for(let y=0;y<c;y++){const g=new Nt({xmin:m,xmax:m+p,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});d.push(Mt(t,g,u,s,o,i)),m+=p}const w=await Promise.all(d);et("esri-2d-profiler")&&X().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-x)),et("esri-2d-profiler")&&X().info("I.9","Number of parts",w.length);const M={data:new Float32Array(n*s*2),mask:new Uint8Array(n*s),width:n,height:s};let k=0;for(const y of w){for(let g=0;g<y.height;g++)for(let A=0;A<y.width;A++)k+A>=n||(M.data[2*(g*n+k+A)]=y.data[2*(g*y.width+A)],M.data[2*(g*n+k+A)+1]=y.data[2*(g*y.width+A)+1],M.mask[g*n+k+A]=y.mask[g*y.width+A]);k+=y.width}return et("esri-2d-profiler")&&X().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-l)),M}async function Mt(t,e,n,s,o,i){var a;const l={requestProjectedLocalDirections:!0,signal:i};if(o!=null&&(l.timeExtent=o),t.type==="imagery"){await t.load({signal:i});const r=t.rasterInfo.dataType,c=await t.fetchImage(e,n,s,l);return((a=c==null?void 0:c.pixelData)==null?void 0:a.pixelBlock)==null?{data:new Float32Array(n*s*2),mask:new Uint8Array(n*s),width:n,height:s}:kt(r,c.pixelData.pixelBlock)}await t.load({signal:i});const f=t.serviceRasterInfo.dataType,h=await t.fetchPixels(e,n,s,l);return(h==null?void 0:h.pixelBlock)==null?{data:new Float32Array(n*s*2),mask:new Uint8Array(n*s),width:n,height:s}:kt(f,h.pixelBlock)}export{D,ie as F,we as H,ge as J,me as K,ye as Q,L as R,De as T,Xt as U,de as X,xe as Y,ke as Z,Re as _,Te as a,Pe as b,bt as c,Fe as d,Be as e,dt as f,Ae as g,Ie as h,vt as i,_e as j,Tt as k,ve as l,Ve as m,be as n,Ue as o,Se as p,pt as r,ot as s,Me as t,mt as u,Ce as v,St as w,yt as y};
