import{D as f,H as y,B as m}from"./index-BeTPrQ6f.js";import{N as R,W as d}from"./projectionUtils-CsX1UTBu-DsZaU4xz.js";class u{constructor(s){this.geometry=s,this.spatialReference=s.spatialReference}export(){return this._exporter(this.coordinates,this.spatialReference)}clone(s){const o=new u(this.geometry);return o.spatialReference=this.spatialReference,o.coordinates=s??this.coordinates.map(t=>t.clone()),o._exporter=this._exporter,o}async project(s,o){if(this.spatialReference.equals(s))return this.clone();await R([{source:this.spatialReference,dest:s}],{signal:o});const t=new f({spatialReference:this.spatialReference,points:this.coordinates.map(p=>[p.x,p.y])}),n=d(t,s);if(!n)return null;const a=this.coordinates.map((p,i)=>{const l=p.clone(),r=n.points[i];return l.x=r[0],l.y=r[1],l}),e=this.clone(a);return e.spatialReference=s,e}static fromGeometry(s){const o=new u(s);if(s instanceof u)return o.coordinates=s.coordinates.map(t=>t.clone()),o._exporter=(t,n)=>{const a=s.clone(t);return a.spatialReference=n,a},o;switch(s.type){case"point":{const t=s,{hasZ:n,hasM:a}=t;return o.coordinates=n&&a?[new c(t.x,t.y,t.z,t.m)]:n?[new c(t.x,t.y,t.z)]:a?[new c(t.x,t.y,null,t.m)]:[new c(t.x,t.y)],o._exporter=(e,p)=>s.hasM?new m(e[0].x,e[0].y,e[0].z,e[0].m,p):new m(e[0].x,e[0].y,e[0].z,p),o}case"multipoint":{const t=s,{hasZ:n,hasM:a}=t;return o.coordinates=n&&a?t.points.map(e=>new c(e[0],e[1],e[2],e[3])):n?t.points.map(e=>new c(e[0],e[1],e[2])):a?t.points.map(e=>new c(e[0],e[1],null,e[2])):t.points.map(e=>new c(e[0],e[1])),o._exporter=(e,p)=>s.hasM?new f({points:e.map(i=>[i.x,i.y,i.z??0,i.m??0]),hasZ:!0,hasM:!0,spatialReference:p}):new f({points:e.map(i=>[i.x,i.y,i.z??0]),spatialReference:p}),o}case"polyline":{const t=s,n=[],a=[],{hasZ:e,hasM:p}=s;let i=0;for(const l of t.paths)if(a.push([i,i+l.length]),i+=l.length,e&&p)for(const r of l)n.push(new c(r[0],r[1],r[2],r[3]));else if(e)for(const r of l)n.push(new c(r[0],r[1],r[2]));else if(p)for(const r of l)n.push(new c(r[0],r[1],null,r[2]));else for(const r of l)n.push(new c(r[0],r[1]));return o.coordinates=n,o._exporter=(l,r)=>{const w=s.hasM?l.map(h=>[h.x,h.y,h.z??0,h.m??0]):l.map(h=>[h.x,h.y,h.z??0]),x=a.map(h=>w.slice(h[0],h[1]));return new y({paths:x,hasM:s.hasM,hasZ:!0,spatialReference:r})},o}}}}class c{constructor(s,o,t=null,n=null,a=null,e=null){this.x=s,this.y=o,this.z=t,this.m=n,this.tile=a,this.elevationTile=e}clone(){return new c(this.x,this.y,this.z,this.m)}}export{u as f};
