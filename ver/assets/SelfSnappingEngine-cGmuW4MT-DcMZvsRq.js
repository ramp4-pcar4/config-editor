import{bM as J,aa as K,v as T,I as q,df as C,t as W,bP as X}from"./index-C8m3jhgc.js";import{F as U,q as D}from"./globalCss-CFN4F315-D4Tn2bn1.js";import{o as G,t as b}from"./quantityUtils-RaoZoCNH-6NuEKBur.js";import{Q as $,Y as ee,Z as m,u,a0 as _,a1 as f,a2 as F,a3 as z,a4 as S,a5 as te,a6 as R,R as Z,a7 as ie,O as se,a8 as M,z as l,H as P,a9 as H,aa as re,ab as L,ac as oe,r as ne,ad as ae,ae as he,af as pe}from"./SketchViewModel-T2dNp9Tt-Bb84_YaR.js";import{M as j,i as B,P as de,l as ce,y as le,A as ge,f as Q}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{m as Y}from"./geodesicLengthMeasurementUtils-X1SKKkBz-BLf9dNlD.js";import{o as I}from"./vec2f64-CEUyUoff-BBc0aQ6D.js";import{O as fe,r as me,A as ue}from"./vec32-BuqRmYBM-CIiFy01h.js";import"./Queue-B8H6jIv7-CGxuMpyH.js";import"./signal-DxzURL18-wfRwoo2f.js";import"./Version-BTMwSXf1-BhPPVtmW.js";import"./UpdatingHandles-DBzjq66S-B3uXjtAE.js";import"./projection-m8vi7Cxv-5dN8ECj8.js";import"./GraphicsLayer-GkJJfSu5-IKsLpVgx.js";import"./GraphicsCollection-rAFZo1AJ-Dmo8O3V2.js";import"./Layer-B8q-l4yV-DeVeCMqx.js";import"./TimeExtent-gZaEUVeW-BJxSd7M2.js";import"./ScaleRangeLayer-DIxukUBC-C94t5fcW.js";import"./layerContainerType-ChWdCT09-G5sdAsSy.js";import"./jsonUtils-DzmXEA9_-_npj7tsJ.js";import"./parser-hXQyB-Qx-vNllFoQp.js";import"./mat4f32-CiZjBg9k-CUm34GoR.js";import"./mat4-BFStKTjU-eFKmoA7r.js";import"./common-CYWrYyJl-E8-sukrT.js";import"./ElevationInfo-DkWlof50-S8pb4AhB.js";import"./lengthUtils-wU9RRIqK-Cfmv-SV3.js";import"./projectVectorToVector-D0K_S4MR-Cw13OHxK.js";import"./projectPointToVector-CG1hALQu-B0EfrEkI.js";import"./geodesicUtils-DV-lFWtb-CMinezVC.js";import"./Query-CxQYWcUQ-DQFSvrsp.js";import"./Field-Cj6Pz3TI-ByZDJlm_.js";import"./fieldType-VTpxE-EM-BwVu7TAV.js";import"./vec42-D8CJyqHG-DnfLTeQH.js";import"./vec4f64-CjUMzAyX-DPYbdAom.js";import"./plane-B_adY3_o-DYdqSZe5.js";import"./mat3f64-Dh9_zhFu-BIT-k8Dm.js";import"./mat4f64-BaJwL7tQ-k0uMm8LY.js";import"./quatf64-C16JxGFv-BKWK1F8U.js";import"./sphere-Cj20syUS-DHNl_4h3.js";import"./mat3-DOnW3DjW-C3hbW9XY.js";import"./index-CVKk0WAC-I6CFsyPj.js";import"./draw-store-C1_quxsr-CU4-JqKs.js";import"./intl-DLmy-Li5-CBPkUqcW.js";import"./jsxFactory-C5LxVioS-HM4dZcpE.js";import"./uuid-Dj9mdEVg-BaKSCiyT.js";import"./layerViewUtils-Bk5QNiAa-BCUON9xC.js";import"./widget-BgluoE6k-BqrdMK9f.js";import"./diffUtils-BSe9IE26-BODWUFPE.js";import"./ViewingMode-CyR_b1T8-_s7_Gbsk.js";import"./meshVertexSpaceUtils-BwEbYR8F-D9891p4Y.js";import"./MeshLocalVertexSpace-DFCiKNRA-DESVmUAB.js";import"./hydratedFeatures-BDT5zTGB-D34u0kiH.js";import"./Scheduler-Br-2v2ys-BSgwEpHb.js";import"./geometryEngineBase-DueYg7ux-B6e4gAE3.js";import"./_commonjsHelpers-BITg13Vk-KnjfkSck.js";import"./hydrated-Bae3cp-4-nqx1jgSS.js";import"./mat2d-BQA-1WB--Pnyy0dhf.js";import"./quat-D8L_R4I0-B7PMZ9PX.js";import"./drapedUtils-7RfmdK5D-9SlWaGcp.js";import"./utils-C0LvbFCo-RMQaTNpt.js";import"./substitute-TfjvVaWd-Ba2-FIfF.js";class k{constructor(e,t){this.view=e,this.options=t,this.squaredShortLineThreshold=P.shortLineThreshold*P.shortLineThreshold}snap(e,t){return t.vertexHandle!=null?t.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(e,t):this.snapNewVertex(e,t)}edgeExceedsShortLineThreshold(e,t){return this.exceedsShortLineThreshold(f(e.leftVertex.pos,this.view,t),f(e.rightVertex.pos,this.view,t),t)}exceedsShortLineThreshold(e,t,{spatialReference:i}){return this.squaredShortLineThreshold===0||S(m(t,i,u,this.view),m(e,i,u,this.view))>this.squaredShortLineThreshold}isVertical(e,t,{spatialReference:i}){const s=X(i);return Q(l(e),l(t))*s<P.verticalLineThresholdMeters}squaredProximityThreshold(e){return e==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:e,touchSensitivityMultiplier:t}=this.options,i=e*t;return i*i}}class xe extends k{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=i.edges.length,o=[];if(s<1)return o;const{spatialReference:n}=t,h=m(e,n,u,this.view),{view:a}=this,p=i.edges[s-1];let d=p;do{if(this.edgeExceedsShortLineThreshold(d,t)){const c=_(d,a,t);this._processCandidateProposal(c.left,c.right,e,h,t,o)}d=d.leftVertex.leftEdge}while(d&&d!==p);return o}snapExistingVertex(e,t){const i=[],s=t.vertexHandle,o=s.component;if(o.edges.length<2)return i;const{view:n}=this,{spatialReference:h}=t,a=m(e,h,u,n),p=s.leftEdge,d=s.rightEdge;p&&d&&this.edgeExceedsShortLineThreshold(p,t)&&this.edgeExceedsShortLineThreshold(d,t)&&this._processCandidateProposal(f(p.leftVertex.pos,n,t),f(d.rightVertex.pos,n,t),e,a,t,i);const c=o.edges[0];let g=c;do{if(g!==s.leftEdge&&g!==s.rightEdge&&this.edgeExceedsShortLineThreshold(g,t)){const v=_(g,n,t);this._processCandidateProposal(v.left,v.right,e,a,t,i)}g=g.rightVertex.rightEdge}while(g&&g!==c);return i}_processCandidateProposal(e,t,i,s,o,n){var c;const{spatialReference:h,pointer:a}=o,p=C();ve(p,e,t,i,o);const d=F(z(p));S(s,m(d,h,u,this.view))<this.squaredProximityThreshold(a)&&n.push(new te({lineStart:e,lineEnd:t,targetPoint:d,isDraped:((c=o.elevationInfo)==null?void 0:c.mode)==="on-the-ground"}))}}function ve(r,e,t,i,s){Ee(r,e,t,i,s)||we(r,i,e,t)}function Ee(r,e,t,i,{spatialReference:s}){const o=R(e,t,s,s);if(o==null)return!1;const n=R(t,i,s,s);if(n==null)return!1;const h=Y(t,i,s);if(h==null)return!1;const a=Math.abs(U.shortestSignedDiff(o,n))>Math.PI/2?D.normalize(o+Math.PI):o;return Z(r,t,s,G(h,"meters"),b(a,"radians","geographic"),"geodesic"),r[2]=i[2],!0}function we(r,e,t,i){ie(e,{start:t,end:i,type:se.LINE},r),r[2]=e[2]}let Ve=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=t.edges.length,s=t.vertices.length,o=[];if(i<2)return o;const{view:n}=this,h=m(r,e.spatialReference,u,n),a=f(t.vertices[s-1].pos,n,e),p=f(t.vertices[0].pos,n,e),d=t.edges[i-1];let c=d;do{if(this.edgeExceedsShortLineThreshold(c,e)){const g=_(c,n,e);this._checkEdgeForParallelLines(g,a,r,h,e,o),this._checkEdgeForParallelLines(g,p,r,h,e,o)}c=c.leftVertex.leftEdge}while(c&&c!==d);return o}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<3)return t;const{view:o}=this,n=m(r,e.spatialReference,u,o),h=i.leftEdge,a=i.rightEdge,p=s.vertices[0],d=f(p.pos,o,e),c=s.vertices.length,g=s.vertices[c-1],v=f(g.pos,o,e),V=s.edges[0];let x=V;do{if(x!==h&&x!==a&&this.edgeExceedsShortLineThreshold(x,e)){const E=_(x,o,e);h&&this._checkEdgeForParallelLines(E,f(h.leftVertex.pos,o,e),r,n,e,t),a&&this._checkEdgeForParallelLines(E,f(a.rightVertex.pos,o,e),r,n,e,t),i===p?this._checkEdgeForParallelLines(E,v,r,n,e,t):i===g&&this._checkEdgeForParallelLines(E,d,r,n,e,t)}x=x.rightVertex.rightEdge}while(x&&x!==V);return t}_checkEdgeForParallelLines(r,e,t,i,s,o){var c;const n=r.left,h=r.right;if(M(w,l(e),l(n),l(h)),j(w,l(e))<P.parallelLineThreshold)return;M(w,l(t),l(n),l(h),l(e));const{spatialReference:a,pointer:p}=s,d=F(H(w[0],w[1],t[2]));if(S(i,m(d,a,u,this.view))<this.squaredProximityThreshold(p)){if(this.isVertical(d,e,s)||this.isVertical(n,h,s)||ye(r,o))return;o.push(new re({referenceLine:r,lineStart:e,targetPoint:d,isDraped:((c=s.elevationInfo)==null?void 0:c.mode)==="on-the-ground"}))}}};function ye(r,e){const t=r.left,i=r.right;for(const s of e)if(M(w,l(i),l(s.constraint.start),l(s.constraint.end),l(t)),j(w,l(i))<P.parallelLineThreshold)return s.addReferenceLine(r),!0;return!1}const w=I();class Pe extends k{snapNewVertex(e,t){const i=t.editGeometryOperations.data.components[0],s=[];if(i.vertices.length<2)return s;const{view:o}=this,n=m(e,t.spatialReference,u,o),h=i.vertices.at(-1);this._checkForSnappingCandidate(L.LastVertex,s,h.leftEdge,h,h.leftEdge.leftVertex,e,n,t);const a=i.vertices[0];return this._checkForSnappingCandidate(L.FirstVertex,s,a.rightEdge,a,a.rightEdge.rightVertex,e,n,t),s}snapExistingVertex(e,t){const i=[],s=t.vertexHandle;if(s.component.vertices.length<3)return i;const{view:o}=this,n=m(e,t.spatialReference,u,o),h=s.leftEdge,a=s.rightEdge;if(h!=null&&h.leftVertex.leftEdge){const p=h.leftVertex.leftEdge;this._checkForSnappingCandidate(L.ExistingEdge,i,p,p.rightVertex,p.leftVertex,e,n,t)}if(a!=null&&a.rightVertex.rightEdge){const p=a.rightVertex.rightEdge;this._checkForSnappingCandidate(L.ExistingEdge,i,p,p.leftVertex,p.rightVertex,e,n,t)}return i}_checkForSnappingCandidate(e,t,i,s,o,n,h,a){if(!this.edgeExceedsShortLineThreshold(i,a))return;const p=this.view,d=f(s.pos,p,a),c=f(o.pos,p,a);Se(N,c,d,n,a),this._checkForSnappingCandidateAlongProjectedRay(e,t,c,d,N,n,h,a)}_checkForSnappingCandidateAlongProjectedRay(e,t,i,s,o,n,h,a){var E;const{spatialReference:p,pointer:d}=a,c=B(O,l(n),l(s)),g=de(o,c)/ce(o),v=le(O,l(s),o,g),V=F(H(v[0],v[1],n[2]));if(S(h,m(V,p,u,this.view))>this.squaredProximityThreshold(d)||this.isVertical(V,s,a)||this.isVertical(s,i,a))return;const x=fe(C(),s,o,Math.sign(g));t.push(new oe({targetPoint:V,constraint:new ne(s,z(x)),previousVertex:i,otherVertex:s,otherVertexType:ae.CENTER,selfSnappingType:e,isDraped:((E=a.elevationInfo)==null?void 0:E.mode)==="on-the-ground"}))}}function Se(r,e,t,i,s){Te(r,e,t,i,s)||Le(r,e,t)}function Te(r,e,t,i,{spatialReference:s}){const o=R(e,t,s,s);if(o==null)return!1;const n=R(t,i,s,s);if(n==null)return!1;const h=Math.sign(D.shortestSignedDiff(o,n))*Math.PI*.5,a=b(o+h,"radians","geographic"),p=C(),d=Y(t,i,s);return d!=null&&(Z(p,t,s,G(d,"meters"),a,"geodesic"),me(r,p,t),!0)}function Le(r,e,t){const i=B(O,l(t),l(e));ue(r,i[1],-i[0],0)}const O=I(),N=C();let _e=class extends k{snapNewVertex(r,e){const t=e.editGeometryOperations.data.components[0],i=[],s=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||s<2)return i;const{view:o}=this,n=t.vertices[0],h=t.vertices[s-1],a=f(n.pos,o,e),p=f(h.pos,o,e);return this._processCandidateProposal(a,p,r,e,i),i}snapExistingVertex(r,e){const t=[],i=e.vertexHandle,s=i.component;if(s.edges.length<2||e.editGeometryOperations.data.type==="polyline"&&(i.index===0||i.index===s.vertices.length-1))return t;const{view:o}=this,n=f(i.leftEdge.leftVertex.pos,o,e),h=f(i.rightEdge.rightVertex.pos,o,e);return this._processCandidateProposal(n,h,r,e,t),t}_processCandidateProposal(r,e,t,i,s){var g;if(!this.exceedsShortLineThreshold(r,e,i))return;const o=ge(A,l(r),l(e),.5),n=.5*Q(l(r),l(e)),h=he(A,l(t),o,n),a=F(H(h[0],h[1],t[2])),{spatialReference:p,pointer:d}=i,c=m(t,p,u,this.view);if(S(c,m(a,p,u,this.view))<this.squaredProximityThreshold(d)){if(this.isVertical(r,a,i)||this.isVertical(a,e,i))return;s.push(new pe({targetPoint:a,point1:r,point2:e,isDraped:((g=i.elevationInfo)==null?void 0:g.mode)==="on-the-ground"}))}}};const A=I();let y=class extends J{constructor(r){super(r),this.updating=!1,this._snappers=new K,this._domain=$.SELF}initialize(){this._snappers.push(new Ve(this.view,this.options),new xe(this.view,this.options),new Pe(this.view,this.options),new _e(this.view,this.options))}set options(r){this._set("options",r);for(const e of this._snappers)e.options=r}async fetchCandidates(r,e,t){if(!(e&this._domain&&this.options.effectiveSelfEnabled))return[];const i=[];for(const s of this._snappers.items)for(const o of s.snap(r,t))i.push(o);return ee(r,i),i}};T([q({readOnly:!0})],y.prototype,"updating",void 0),T([q({constructOnly:!0})],y.prototype,"view",void 0),T([q()],y.prototype,"options",null),y=T([W("esri.views.interactive.snapping.SelfSnappingEngine")],y);export{y as SelfSnappingEngine};
