const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./geometryEngineJSON-CGn_tfx8-CijjZxZ3.js","./geometryEngineBase-DueYg7ux-B6e4gAE3.js","./_commonjsHelpers-BITg13Vk-KnjfkSck.js","./json-BI97KiBB-Ce5cWfI2.js"])))=>i.map(i=>d[i]);
import{a5 as ue,fr as y,dz as le,c as he,a8 as Ct,jk as pe,d4 as Tt,d5 as de,_ as fe}from"./index-CBMEoBe1.js";import{I as h}from"./enums-DBi1-Mm2-CUS1pvQe.js";import{Q as xe,t as me,q as Mt,a as Et,x as zt,z as T,V as ye,J as _e}from"./CIMSymbolHelper-Bcp4nGf3-C59xUPAe.js";import{F as ge,D as Ot,d as Ut}from"./Rect-KI3be8Nv-BI-7XdfN.js";import{s as et,n as At,c as ut,d as lt,Z as Se,X as Wt,Y as Ht,e as Dt,o as ke,h as ve,Q as Pe,t as be,r as H}from"./UpdateTracking2D-CaPtqow6-CrcOQvI4.js";import{N as it,S as C,o as Xt,i as ht,R as pt,t as dt}from"./enums-f9UUstHQ-hLTu4V1l.js";import{t as rt,K as ct,n as P,J as st,d as we,$ as Te,_ as Me,r as Ee,c as ze}from"./definitions-CBIQmVpq-o3EUznKY.js";import{U as Ae,B as De,D as Ie}from"./libtess-D7mkf7O_-CqSkDAPh.js";import{l as Vt,f as Le}from"./utils-BddLNd1v-Bnk4Kdmo.js";import{b as Zt}from"./utils-BYqzY6_X-FI4tArPo.js";import"./earcut-XDcq3zAf-BcwyrT7l.js";import{c as Ne}from"./OptimizedGeometry-1qDYm3YK-DaEUjOqr.js";import{x as Ye,q as Be,_ as Fe}from"./mat2d-BQA-1WB--Pnyy0dhf.js";import{l as Ge}from"./mat2df32-BCnkwMW8-BLRY8i4P.js";import{L as J}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{L as j}from"./rasterizingUtils-B8CPqgVl-C9tH1z2k.js";import{X as Re,G as Ce}from"./dataViewUtils-xig9T3UA-DKo_U9gx.js";function Oe(t,e,i,r,s,n,o){yt=0;const a=(r-i)*n,c=s&&s.length,u=c?(s[0]-i)*n:a;let l,p,x,d,f,m=qt(e,i,r,0,u,n,!0);if(m&&m.next!==m.prev){if(c&&(m=Xe(e,i,r,s,m,n)),a>80*n){l=x=e[0+i*n],p=d=e[1+i*n];for(let _=n;_<u;_+=n){const k=e[_+i*n],v=e[_+1+i*n];l=Math.min(l,k),p=Math.min(p,v),x=Math.max(x,k),d=Math.max(d,v)}f=Math.max(x-l,d-p),f=f!==0?1/f:0}V(m,t,n,l,p,f,o,0)}}function qt(t,e,i,r,s,n,o){let a;if(o===$e(t,e,i,r,s,n)>0)for(let c=r;c<s;c+=n)a=It(c+e*n,t[c+e*n],t[c+1+e*n],a);else for(let c=s-n;c>=r;c-=n)a=It(c+e*n,t[c+e*n],t[c+1+e*n],a);return a&&N(a,a.next)&&(Z(a),a=a.next),a}function X(t,e=t){if(!t)return t;let i,r=t;do if(i=!1,r.steiner||!N(r,r.next)&&S(r.prev,r,r.next)!==0)r=r.next;else{if(Z(r),r=e=r.prev,r===r.next)break;i=!0}while(i||r!==e);return e}function V(t,e,i,r,s,n,o,a){if(!t)return;!a&&n&&(t=Qt(t,r,s,n));let c=t;for(;t.prev!==t.next;){const u=t.prev,l=t.next;if(n?We(t,r,s,n):Ue(t))e.push(u.index/i+o),e.push(t.index/i+o),e.push(l.index/i+o),Z(t),t=l.next,c=l.next;else if((t=l)===c){a?a===1?V(t=je(t,e,i,o),e,i,r,s,n,o,2):a===2&&Ke(t,e,i,r,s,n,o):V(X(t),e,i,r,s,n,o,1);break}}}function Ue(t){const e=t.prev,i=t,r=t.next;if(S(e,i,r)>=0)return!1;let s=t.next.next;const n=s;let o=0;for(;s!==t.prev&&(o===0||s!==n);){if(o++,R(e.x,e.y,i.x,i.y,r.x,r.y,s.x,s.y)&&S(s.prev,s,s.next)>=0)return!1;s=s.next}return!0}function We(t,e,i,r){const s=t.prev,n=t,o=t.next;if(S(s,n,o)>=0)return!1;const a=s.x<n.x?s.x<o.x?s.x:o.x:n.x<o.x?n.x:o.x,c=s.y<n.y?s.y<o.y?s.y:o.y:n.y<o.y?n.y:o.y,u=s.x>n.x?s.x>o.x?s.x:o.x:n.x>o.x?n.x:o.x,l=s.y>n.y?s.y>o.y?s.y:o.y:n.y>o.y?n.y:o.y,p=xt(a,c,e,i,r),x=xt(u,l,e,i,r);let d=t.prevZ,f=t.nextZ;for(;d&&d.z>=p&&f&&f.z<=x;){if(d!==t.prev&&d!==t.next&&R(s.x,s.y,n.x,n.y,o.x,o.y,d.x,d.y)&&S(d.prev,d,d.next)>=0||(d=d.prevZ,f!==t.prev&&f!==t.next&&R(s.x,s.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0))return!1;f=f.nextZ}for(;d&&d.z>=p;){if(d!==t.prev&&d!==t.next&&R(s.x,s.y,n.x,n.y,o.x,o.y,d.x,d.y)&&S(d.prev,d,d.next)>=0)return!1;d=d.prevZ}for(;f&&f.z<=x;){if(f!==t.prev&&f!==t.next&&R(s.x,s.y,n.x,n.y,o.x,o.y,f.x,f.y)&&S(f.prev,f,f.next)>=0)return!1;f=f.nextZ}return!0}function It(t,e,i,r){const s=O.create(t,e,i);return r?(s.next=r.next,s.prev=r,r.next.prev=s,r.next=s):(s.prev=s,s.next=s),s}function Z(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function He(t){let e=t,i=t;do(e.x<i.x||e.x===i.x&&e.y<i.y)&&(i=e),e=e.next;while(e!==t);return i}function Xe(t,e,i,r,s,n){const o=new Array;for(let a=0,c=r.length;a<c;a++){const u=qt(t,e,i,r[a]*n,a<c-1?r[a+1]*n:i*n,n,!1);u===u.next&&(u.steiner=!0),o.push(He(u))}o.sort(Je);for(const a of o)s=Ve(a,s);return s}function Ve(t,e){const i=Ze(t,e);if(!i)return e;const r=Jt(i,t);return X(r,r.next),X(i,i.next)}function Ze(t,e){let i=e;const r=t.x,s=t.y;let n,o=-1/0;do{if(s<=i.y&&s>=i.next.y&&i.next.y!==i.y){const x=i.x+(s-i.y)*(i.next.x-i.x)/(i.next.y-i.y);if(x<=r&&x>o){if(o=x,x===r){if(s===i.y)return i;if(s===i.next.y)return i.next}n=i.x<i.next.x?i:i.next}}i=i.next}while(i!==e);if(!n)return null;if(r===o)return n.prev;const a=n,c=n.x,u=n.y;let l,p=1/0;for(i=n.next;i!==a;)r>=i.x&&i.x>=c&&r!==i.x&&R(s<u?r:o,s,c,u,s<u?o:r,s,i.x,i.y)&&(l=Math.abs(s-i.y)/(r-i.x),(l<p||l===p&&i.x>n.x)&&q(i,t)&&(n=i,p=l)),i=i.next;return n}function Qt(t,e,i,r){let s;for(;s!==t;s=s.next){if(s=s||t,s.z===null&&(s.z=xt(s.x,s.y,e,i,r)),s.prev.next!==s||s.next.prev!==s)return s.prev.next=s,s.next.prev=s,Qt(t,e,i,r);s.prevZ=s.prev,s.nextZ=s.next}return t.prevZ.nextZ=null,t.prevZ=null,qe(t)}function qe(t){let e,i=1;for(;;){let r,s=t;t=null,e=null;let n=0;for(;s;){n++,r=s;let o=0;for(;o<i&&r;o++)r=r.nextZ;let a=i;for(;o>0||a>0&&r;){let c;o===0?(c=r,r=r.nextZ,a--):a!==0&&r?s.z<=r.z?(c=s,s=s.nextZ,o--):(c=r,r=r.nextZ,a--):(c=s,s=s.nextZ,o--),e?e.nextZ=c:t=c,c.prevZ=e,e=c}s=r}if(e.nextZ=null,i*=2,n<2)return t}}function S(t,e,i){return(e.y-t.y)*(i.x-e.x)-(e.x-t.x)*(i.y-e.y)}function $t(t,e,i,r){return!!(N(t,e)&&N(i,r)||N(t,r)&&N(i,e))||S(t,e,i)>0!=S(t,e,r)>0&&S(i,r,t)>0!=S(i,r,e)>0}function Qe(t,e){let i=t;do{if(i.index!==t.index&&i.next.index!==t.index&&i.index!==e.index&&i.next.index!==e.index&&$t(i,i.next,t,e))return!0;i=i.next}while(i!==t);return!1}function $e(t,e,i,r,s,n){let o=0;for(let a=r,c=s-n;a<s;a+=n)o+=(t[c+e*n]-t[a+e*n])*(t[a+1+e*n]+t[c+1+e*n]),c=a;return o}function R(t,e,i,r,s,n,o,a){return(s-o)*(e-a)-(t-o)*(n-a)>=0&&(t-o)*(r-a)-(i-o)*(e-a)>=0&&(i-o)*(n-a)-(s-o)*(r-a)>=0}function q(t,e){return S(t.prev,t,t.next)<0?S(t,e,t.next)>=0&&S(t,t.prev,e)>=0:S(t,e,t.prev)<0||S(t,t.next,e)<0}function xt(t,e,i,r,s){return(t=1431655765&((t=858993459&((t=252645135&((t=16711935&((t=32767*(t-i)*s)|t<<8))|t<<4))|t<<2))|t<<1))|(e=1431655765&((e=858993459&((e=252645135&((e=16711935&((e=32767*(e-r)*s)|e<<8))|e<<4))|e<<2))|e<<1))<<1}function N(t,e){return t.x===e.x&&t.y===e.y}function Je(t,e){return t.x-e.x}function je(t,e,i,r){let s=t;do{const n=s.prev,o=s.next.next;!N(n,o)&&$t(n,s,s.next,o)&&q(n,o)&&q(o,n)&&(e.push(n.index/i+r),e.push(s.index/i+r),e.push(o.index/i+r),Z(s),Z(s.next),s=t=o),s=s.next}while(s!==t);return s}function Ke(t,e,i,r,s,n,o){let a=t;do{let c=a.next.next;for(;c!==a.prev;){if(a.index!==c.index&&ti(a,c)){let u=Jt(a,c);return a=X(a,a.next),u=X(u,u.next),V(a,e,i,r,s,n,o,0),void V(u,e,i,r,s,n,o,0)}c=c.next}a=a.next}while(a!==t)}function ti(t,e){return t.next.index!==e.index&&t.prev.index!==e.index&&!Qe(t,e)&&q(t,e)&&q(e,t)&&ei(t,e)}function ei(t,e){let i=t,r=!1;const s=(t.x+e.x)/2,n=(t.y+e.y)/2;do i.y>n!=i.next.y>n&&i.next.y!==i.y&&s<(i.next.x-i.x)*(n-i.y)/(i.next.y-i.y)+i.x&&(r=!r),i=i.next;while(i!==t);return r}function Jt(t,e){const i=O.create(t.index,t.x,t.y),r=O.create(e.index,e.x,e.y),s=t.next,n=e.prev;return t.next=e,e.prev=t,i.next=s,s.prev=i,r.next=i,i.prev=r,n.next=r,r.prev=n,r}class O{constructor(){this.index=0,this.x=0,this.y=0,this.prev=null,this.next=null,this.z=null,this.prevZ=null,this.nextZ=null,this.steiner=!1}static create(e,i,r){const s=yt<mt.length?mt[yt++]:new O;return s.index=e,s.x=i,s.y=r,s.prev=null,s.next=null,s.z=null,s.prevZ=null,s.nextZ=null,s.steiner=!1,s}}const mt=[],ii=8096;let yt=0;for(let t=0;t<ii;t++)mt.push(new O);const ri=1e-5,I=new Ot(0,0,0,1,0),_t=new Ot(0,0,0,1,0);function Lt(t,e,i){let r=0;for(let s=1;s<i;s++){const n=t[2*(e+s-1)],o=t[2*(e+s-1)+1];r+=(t[2*(e+s)]-n)*(t[2*(e+s)+1]+o)}return r}function si(t,e,i,r,s){let n=0;const o=2;for(let a=i;a<r;a+=3){const c=(t[a]-s)*o,u=(t[a+1]-s)*o,l=(t[a+2]-s)*o;n+=Math.abs((e[c]-e[l])*(e[u+1]-e[c+1])-(e[c]-e[u])*(e[l+1]-e[c+1]))}return n}function ni(t,e){const{coords:i,lengths:r}=e,s=0,n=t;let o=0;for(let a=0;a<r.length;){let c=a,u=r[a],l=Lt(i,o,u);const p=[];for(;++c<r.length;){const m=r[c],_=Lt(i,o+u,m);if(!(_>0))break;l+=_,p.push(o+u),u+=m}const x=n.length;Oe(n,i,o,o+u,p,2,s);const d=si(n,i,x,n.length,s),f=Math.abs(l);if(Math.abs((d-f)/Math.max(1e-7,f))>ri)return n.length=0,!1;a=c,o+=u}return!0}function oi(t){const{coords:e,lengths:i}=t,{buffer:r}=Ie(e,i);return r}function ai(t,e,i){let r=0;for(let s=0;s<t.lengths.length;s++){const n=t.lengths[s];for(let o=0;o<n;o++){const a=t.coords[2*(o+r)],c=t.coords[2*(o+r)+1];if(a<e||a>i||c<e||c>i)return!0}r+=n}return!1}function jt(t,e){if(t==null)return null;if(!ai(t,-128,rt+128))return t;I.setPixelMargin(e),I.reset(Ut.Polygon);let i=0;for(let o=0;o<t.lengths.length;o++){const a=t.lengths[o];let c=t.coords[2*(0+i)],u=t.coords[2*(0+i)+1];I.moveTo(c,u);for(let l=1;l<a;l++)c=t.coords[2*(l+i)],u=t.coords[2*(l+i)+1],I.lineTo(c,u);I.close(),i+=a}const r=I.result(!1);if(!r)return null;const s=[],n=[];for(const o of r){let a=0;for(const c of o)n.push(c.x),n.push(c.y),a++;s.push(a)}return new Ne(s,n)}function ci(t,e){_t.setPixelMargin(e);const i=_t,r=-e,s=rt+e;let n=[],o=!1;if(!t.nextPath())return null;let a=t.pathLength(),c=!0;for(;c;){t.seekPathStart();const u=[];if(!t.pathSize)return null;i.reset(Ut.LineString),t.nextPoint();let l=t.x,p=t.y;if(o)i.moveTo(l,p);else{if(l<r||l>s||p<r||p>s){o=!0;continue}u.push({x:l,y:p})}let x=!1;for(;t.nextPoint();)if(l=t.x,p=t.y,o)i.lineTo(l,p);else{if(l<r||l>s||p<r||p>s){x=!0;break}u.push({x:l,y:p})}if(x)o=!0;else{if(o){const d=i.resultWithStarts();if(d)for(const f of d)n.push({...f,pathLength:a})}else n.push({line:u,start:0,pathLength:a});c=t.nextPath(),a=c?t.pathLength():0,o=!1}}return n=n.filter(u=>u.line.length>1),n.length===0?null:n}I.setExtent(rt),_t.setExtent(rt);const ui=96/72;let li=class{static executeEffects(t,e,i,r,s){const n=ui,o=Mt(t);let a=new zt(e);for(const c of t){const u=Et(c);u&&(a=u.execute(a,c,n,i,r,o,s))}return a}static applyEffects(t,e,i){if(!t)return e;const r=Mt(t);let s,n=new zt(T.fromJSONCIM(e));for(const c of t){const u=Et(c);u&&(n=u.execute(n,c,1,null,i,r,!1))}const o=[];let a=null;for(;s=n.next();)o.push(...pe(s)),a=s.geometryType;return o.length===0||a===null?null:a==="esriGeometryPolygon"?{rings:o}:{paths:o}}},Kt=null;function St(){return Kt}async function hi(){Kt=await fe(()=>import("./geometryEngineJSON-CGn_tfx8-CijjZxZ3.js"),__vite__mapDeps([0,1,2,3]),import.meta.url).then(t=>t.g)}function te(t){switch(t){case h.BYTE:case h.UNSIGNED_BYTE:return 1;case h.SHORT:case h.UNSIGNED_SHORT:case h.HALF_FLOAT:return 2;case h.FLOAT:case h.INT:case h.UNSIGNED_INT:return 4}}function pi(t){const e=[],i=[],r=[];for(const s of t){const n=te(s.type)*s.count;switch(n%2||n%4||4){case 4:e.push(s);continue;case 2:i.push(s);continue;case 1:r.push(s);continue;default:throw new Error("Found unexpected dataType byte count")}}return e.push(...i),e.push(...r),e}let di=class ee{static fromVertexSpec(e,i){const{attributes:r,optionalAttributes:s}=e;let n,o,a;const c=[];for(const m in r){const _=r[m];_.pack==="position"?n={..._,name:m,offset:0}:_.pack==="id"?o={..._,name:m,offset:4}:m==="bitset"?a={..._,name:m,offset:7}:c.push({..._,name:m})}for(const m in s)if(i[m]===!0){const _=s[m];c.push({..._,name:m})}const u=pi(c),l=[];let p=8,x=1;for(const m of u)l.push({...m,offset:p}),p+=te(m.type)*m.count,m.packAlternating&&(x=Math.max(m.packAlternating.count,x));const d=Uint32Array.BYTES_PER_ELEMENT,f=p%d;return new ee(n,o,a,l,p+(f?d-f:0),x)}constructor(e,i,r,s,n,o){this.position=e,this.id=i,this.bitset=r,this.standardAttributes=s,this.stride=n,this.packVertexCount=o,s.push(r),this._attributes=[e,i,r,...s]}get attributeLayout(){if(!this._attributeLayout){const e=Le(this._attributes),i=this._attributes.map(r=>({name:r.name,count:r.count,offset:r.offset,type:r.type,packPrecisionFactor:r.packPrecisionFactor,normalized:r.normalized??!1}));this._attributeLayout={attributes:i,hash:e,stride:this.stride}}return this._attributeLayout}},fi=class ie{static fromVertexSpec(e,i){const r=di.fromVertexSpec(e,i);return new ie(r)}constructor(e){this._spec=e,this._packed=new Uint8Array(this._spec.stride*this._spec.packVertexCount),this._packedU32View=new Uint32Array(this._packed.buffer),this._dataView=new DataView(this._packed.buffer)}get attributeLayout(){return this._spec.attributeLayout}get stride(){return this._spec.stride}writeVertex(e,i,r,s,n,o){var a;for(let c=0;c<this._spec.packVertexCount;c++){const u=c*this._spec.stride;this._packPosition(r,s,u),this._packId(i,u);const l=this._spec.bitset;if(o){if(l.packTessellation){const p=l.packTessellation(o,n,r,s);this._pack(p,l,u)}for(const p of this._spec.standardAttributes)if(p.packTessellation!=null){const x=p.packTessellation(o,n,r,s);this._pack(x,p,u)}else if((a=p.packAlternating)!=null&&a.packTessellation){const x=p.packAlternating.packTessellation(o,n,r,s);for(let d=0;d<this._spec.packVertexCount;d++){const f=x[d];this._pack(f,p,d*this._spec.stride)}}}}e.vertexWriteRegion(this._packedU32View)}pack(e,i){var r;for(const s of this._spec.standardAttributes)if(s.pack&&typeof s.pack!="string"){const n=s.pack(e,i);for(let o=0;o<this._spec.packVertexCount;o++)this._pack(n,s,o*this._spec.stride)}else if((r=s.packAlternating)!=null&&r.pack){const n=s.packAlternating.pack(e,i);for(let o=0;o<this._spec.packVertexCount;o++){const a=n[o];this._pack(a,s,o*this._spec.stride)}}}_packPosition(e,i,r){const{offset:s}=this._spec.position,n=this._spec.position.packPrecisionFactor??1,o=Ce(e*n,i*n);this._dataView.setUint32(r+s,o,!0)}_packId(e,i){const r=e*(this._spec.id.packPrecisionFactor??1),s=4278190080&this._dataView.getUint32(i+this._spec.id.offset,!0);this._dataView.setUint32(i+this._spec.id.offset,r|s,!0)}_pack(e,i,r){Re(this._dataView,e,i,r)}};function xi(t){if(!t)return!1;for(const e of t)switch(e.effect.type){case"CIMGeometricEffectBuffer":case"CIMGeometricEffectOffset":case"CIMGeometricEffectDonut":return!0}return!1}let U=class{constructor(t,e,i,r){this._instanceId=t,this._evaluator=e,this._enabledOptionalAttributes=i,this._viewParams=r,this._evaluator.evaluator=s=>this.vertexSpec.createComputedParams(s)}get _vertexPack(){if(!this._cachedVertexPack){const t=fi.fromVertexSpec(this.vertexSpec,this._enabledOptionalAttributes);this._evaluator.hasDynamicProperties||t.pack(this._evaluator.evaluatedMeshParams,this._viewParams),this._cachedVertexPack=t}return this._cachedVertexPack}get evaluatedMeshParams(){return this._evaluator.evaluatedMeshParams}get hasEffects(){return!!this.evaluatedMeshParams.effects}get instanceId(){return this._instanceId}get attributeLayout(){return this._vertexPack.attributeLayout}get _preventEffectClipping(){return!1}setReferences(t){this._references=t}getBoundsInfo(){return null}getTileInfo(){return this._viewParams.tileInfo}async loadDependencies(){var t;xi((t=this._evaluator.inputMeshParams.effects)==null?void 0:t.effectInfos)&&await hi()}enqueueRequest(t,e,i){this._evaluator.hasDynamicProperties&&this._evaluator.enqueueRequest(t,e,i)}write(t,e,i,r,s){var x;this.ensurePacked(e,i,r);const n=this.evaluatedMeshParams.effects;if(!n||n.length===0)return void this._write(t,i,void 0,s);const o=(x=i.readGeometryForDisplay())==null?void 0:x.clone();if(!o)return;const a=T.fromOptimizedCIM(o,i.geometryType),c=St();a.invertY();const u=t.id||"",l=li.executeEffects(n,a,u,c,this._preventEffectClipping);let p;for(;p=l.next();)p.invertY(),this._write(t,i,p,s)}ensurePacked(t,e,i){if(!this._evaluator.hasDynamicProperties)return;const r=this._evaluator.evaluateMeshParams(t,e,i);this._vertexPack.pack(r,this._viewParams)}hasArcadeDependency(t){return this._evaluator.hasArcadeDependency(t)}_writeVertex(t,e,i,r,s){const n=this.evaluatedMeshParams;this._vertexPack.writeVertex(t,e,i,r,n,s)}};const mi=100,yi=ue("featurelayer-fast-triangulation-enabled");let kt=class extends U{async loadDependencies(){await Promise.all([super.loadDependencies(),De()])}_write(t,e,i){const r=(i==null?void 0:i.asOptimized())??e.readGeometryForDisplay(),s=this._clip(r);s&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,s),t.recordEnd())}_clip(t){if(!t)return null;const e=this.hasEffects;return jt(t,e?256:8)}_writeGeometry(t,e,i){const r=i.maxLength>mi,s=[],n=this.createTesselationParams(e);if(!r&&yi&&ni(s,i))return void(s.length&&this._writeVertices(t,e,i.coords,n,s));const o=oi(i);this._writeVertices(t,e,o,n)}_writeVertices(t,e,i,r,s){const n=e.getDisplayId(),o=t.vertexCount(),a=this.hasEffects;let c=0;if(s)for(const u of s){const l=i[2*u],p=i[2*u+1];a&&t.recordBounds(l,p,0,0),this._writeVertex(t,n,l,p,r),c++}else for(let u=0;u<i.length;u+=2){const l=Math.round(i[u]),p=Math.round(i[u+1]);a&&t.recordBounds(l,p,0,0),this._writeVertex(t,n,l,p,r),c++}t.indexEnsureSize(c);for(let u=0;u<c;u++)t.indexWrite(u+o)}};const _i={createComputedParams:t=>t,optionalAttributes:{},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},inverseArea:{type:h.FLOAT,count:1,packTessellation:({inverseArea:t})=>t}}};let br=class extends kt{constructor(){super(...arguments),this.vertexSpec=_i}createTesselationParams(t){return{inverseArea:1/t.readGeometryArea()}}};const gi=()=>Ct.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.meshWriterUtils"),Si=0,ki=100;function $(t,e){return[!!(t!=null&&t.minScale)&&e.scaleToZoom(t.minScale)||Si,!!(t!=null&&t.maxScale)&&e.scaleToZoom(t.maxScale)||ki]}function L(t){return 1<<t}function W(t){let e=0;for(const[i,r]of t)r&&(e|=1<<i);return e}function g(t){let e;if(!t)return[0,0,0,0];if(typeof t=="string"){const o=le.fromString(t);if(!o)return gi().errorOnce(new he("mapview:mesh-processing","Unable to parse string into color",{color:t})),[0,0,0,0];e=o.toArray()}else e=t;const[i,r,s,n]=e;return[i*(n/255),r*(n/255),s*(n/255),n]}function vi(t){switch(t){case"butt":case C.Butt:return ht.BUTT;case"round":case C.Round:return ht.ROUND;case"square":case C.Square:return ht.SQUARE}}function Pi(t){switch(t){case"bevel":case pt.Bevel:return dt.BEVEL;case"miter":case pt.Miter:return dt.MITER;case"round":case pt.Round:return dt.ROUND}}function ft(t,e){return Math.round(Math.min(Math.sqrt(t*e),255))}function K(t,e){return Math.round(t*e)/e}const Q={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:t},{tileInfo:e})=>$(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}};let re=class extends kt{constructor(){super(...arguments),this.vertexSpec=Q}createTesselationParams(t){return null}};const Y={createComputedParams:t=>t,optionalAttributes:Q.optionalAttributes,attributes:{...Q.attributes,tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:i,height:r}=t,s=e.x+P,n=e.y+P;return[s,n,s+i,n+r]}},inverseRasterizationScale:{count:1,type:h.BYTE,packPrecisionFactor:16,pack:({sprite:t})=>1/t.rasterizationScale}}};let bi=class extends re{constructor(){super(...arguments),this.vertexSpec=Y}_write(t,e,i){var o;const r=(i==null?void 0:i.asOptimized())??e.readGeometryForDisplay(),s=this._clip(r);if(!s)return;const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,s),t.recordEnd()}};function nt(t){const{sprite:e,aspectRatio:i,scaleProportionally:r}=t,s=y(t.height),n=s>0?s:e.height;let o=s*i;return o<=0?o=e.width:r&&(o*=e.width/e.height),{width:o,height:n}}function se(t){const{applyRandomOffset:e,sampleAlphaOnly:i}=t;return W([[Se,e],[Wt,i]])}const ne={createComputedParams:t=>t,optionalAttributes:Y.optionalAttributes,attributes:{...Y.attributes,bitset:{count:1,type:h.UNSIGNED_BYTE,pack:se},width:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).width},height:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).height},offset:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[y(t),-y(e)]},scale:{count:2,type:h.UNSIGNED_BYTE,packPrecisionFactor:16,pack:({scaleX:t,scaleY:e})=>[t,e]},angle:{count:1,type:h.UNSIGNED_BYTE,pack:({angle:t})=>ge(t)}}};let wr=class extends bi{constructor(){super(...arguments),this.vertexSpec=ne}},wi=class{constructor(){this.extrusionOffsetX=0,this.extrusionOffsetY=0,this.normalX=0,this.normalY=0,this.directionX=0,this.directionY=0,this.distance=0,this.pathLength=0}};const E={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:t},{tileInfo:e})=>$(t,e)}},attributes:{id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},bitset:{type:h.UNSIGNED_BYTE,count:1},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},offset:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[K(t,16),K(e,16)]},normal:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({normalX:t,normalY:e})=>[K(t,16),K(e,16)]},halfWidth:{type:h.HALF_FLOAT,count:1,pack:({width:t})=>y(.5*t)},referenceHalfWidth:{type:h.HALF_FLOAT,count:1,pack:({referenceWidth:t})=>y(.5*t)}}};let Ti=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const Nt=65535;let vt=class extends U{constructor(t,e,i,r){super(t,e,i,r),this.vertexSpec=E,this._currentWrite=new Ti,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:Nt,textured:!1},this._tessParams=new wi,this._initializeTessellator()}writeLineVertices(t,e,i){const r=this._getLines(e);r!=null&&this._writeVertices(t,i,r)}_initializeTessellator(){this._lineTessellator=new Ae(this._writeTesselatedVertex.bind(this),this._writeTriangle.bind(this),!0)}_write(t,e,i){const r=i??T.fromFeatureSetReaderCIM(e);r&&this._writeGeometry(t,e,r)}_writeGeometry(t,e,i,r){t.recordStart(this.instanceId,this.attributeLayout,r),this.writeLineVertices(t,i,e),t.recordEnd()}_getLines(t){return ci(t,Vt(this.evaluatedMeshParams))}_writeVertices(t,e,i){const{_currentWrite:r,_tessellationOptions:s,evaluatedMeshParams:n}=this,{width:o,capType:a,joinType:c,miterLimit:u,hasSizeVV:l}=n,p=y(.5*o);s.halfWidth=p,s.capType=vi(a),s.joinType=Pi(c),s.miterLimit=u;const x=!l;r.out=t,r.id=e.getDisplayId(),r.vertexCount=0,r.indexCount=0,r.vertexFrom=t.vertexCount(),r.vertexBounds=x&&p<we?0:1;for(const{line:d,start:f,pathLength:m}of i)s.initialDistance=f%Nt,r.pathLength=m,this._lineTessellator.tessellate(d,s,x)}_writeTesselatedVertex(t,e,i,r,s,n,o,a,c,u,l){const{out:p,id:x,vertexBounds:d,pathLength:f}=this._currentWrite;return this.hasEffects&&p.recordBounds(t,e,d,d),this._tessParams.extrusionOffsetX=o,this._tessParams.extrusionOffsetY=a,this._tessParams.normalX=c,this._tessParams.normalY=u,this._tessParams.directionX=s,this._tessParams.directionY=n,this._tessParams.distance=l,this._tessParams.pathLength=f,this._writeVertex(p,x,t,e,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(t,e,i){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(t),r.indexWrite(e),r.indexWrite(i),this._currentWrite.indexCount+=3}};const oe={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)}}},Pt={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>W([[Ht,!0]])},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)}}};let bt=class extends vt{constructor(){super(...arguments),this.vertexSpec=Pt}},ae=class extends re{constructor(t,e,i,r){super(t,e,i,r),this.vertexSpec=oe,this._lineMeshWriter=this._createOutlineWriter(t,e,i,r)}_createOutlineWriter(t,e,i,r){return new bt(t,e,i,r)}_write(t,e,i){const r=(i==null?void 0:i.asOptimized())??e.readGeometryForDisplay(),s=this._clip(r);s&&(t.recordStart(this.instanceId,this.attributeLayout),this._writeGeometry(t,e,s),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(s,"esriGeometryPolyline"),e),t.recordEnd())}_clip(t){return t?jt(t,Vt(this.evaluatedMeshParams)):null}ensurePacked(t,e,i){super.ensurePacked(t,e,i),this._lineMeshWriter.ensurePacked(t,e,i)}enqueueRequest(t,e,i){super.enqueueRequest(t,e,i),this._lineMeshWriter.enqueueRequest(t,e,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const ot=ne,Mi=Pt,Ei={createComputedParams:t=>t,optionalAttributes:ot.optionalAttributes,attributes:{...ot.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>se(t)},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).width},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>nt(t).height},aux3:{count:2,type:h.HALF_FLOAT,pack:({offsetX:t,offsetY:e})=>[y(t),y(e)]},aux4:{count:2,type:h.UNSIGNED_BYTE,pack:({scaleX:t,scaleY:e})=>[t*et,e*et]}}},zi={createComputedParams:t=>t,optionalAttributes:ot.optionalAttributes,attributes:{...ot.attributes,color:Mi.attributes.color,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>W([[Ht,!0]])},aux1:{count:1,type:h.HALF_FLOAT,pack:t=>y(.5*t.width)},aux2:{count:1,type:h.HALF_FLOAT,pack:t=>y(.5*t.referenceWidth)},aux3:{count:2,type:h.HALF_FLOAT,packTessellation:({extrusionOffsetX:t,extrusionOffsetY:e})=>[t,e]},aux4:{count:2,type:h.UNSIGNED_BYTE,packTessellation:({normalX:t,normalY:e})=>[t*et+At,e*et+At]}}};let Ai=class extends bt{constructor(){super(...arguments),this.vertexSpec=zi}},Tr=class extends ae{constructor(){super(...arguments),this.vertexSpec=Ei}_createOutlineWriter(t,e,i,r){return new Ai(t,e,i,r)}_write(t,e,i){var o;const r=(i==null?void 0:i.asOptimized())??e.readGeometryForDisplay(),s=this._clip(r);if(!s)return;const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,s),this._lineMeshWriter.writeLineVertices(t,T.fromOptimizedCIM(s,"esriGeometryPolyline"),e),t.recordEnd()}ensurePacked(t,e,i){super.ensurePacked(t,e,i),this._lineMeshWriter.ensurePacked(t,e,i)}enqueueRequest(t,e,i){super.enqueueRequest(t,e,i),this._lineMeshWriter.enqueueRequest(t,e,i)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}};const Di=()=>Ct.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.fill.GradientSizeHelper");let Ii=class{constructor(t,e){this._size=t,this._sizeUnits=e,this._relativeSize=null}get relativeSize(){return this._relativeSize??(this._relativeSize=this.calculateRelativeSize()),this._relativeSize}calculateRelativeSize(){if(this._sizeUnits===it.Relative){const t=Math.min(this._size/100,1);return[t,t]}return this.calculateRelativeSizeFromAbsolute()}},wt=class extends Ii{constructor(t,e,i,r){super(e,i),this.rotationMatrix00=1,this.rotationMatrix01=0,this.rotationMatrix10=0,this.rotationMatrix11=1,this.bounds={xmin:1/0,ymin:1/0,xmax:-1/0,ymax:-1/0},this.rotationMatrix00=Math.cos(r),this.rotationMatrix01=-Math.sin(r),this.rotationMatrix10=-this.rotationMatrix01,this.rotationMatrix11=this.rotationMatrix00;const{bounds:s,rotationMatrix00:n,rotationMatrix01:o,rotationMatrix10:a,rotationMatrix11:c}=this;t.forEachVertex((u,l)=>{const p=u*n+l*o,x=u*a+l*c;s.xmin=Math.min(s.xmin,p),s.ymin=Math.min(s.ymin,x),s.xmax=Math.max(s.xmax,p),s.ymax=Math.max(s.ymax,x)}),this.center=[(s.xmin+s.xmax)/2,(s.ymin+s.ymax)/2]}},Li=class extends wt{constructor(t,e,i,r){super(t,e,i,r),this.method="linear"}getRelativePosition(t,e){const{rotationMatrix00:i,rotationMatrix01:r,bounds:s}=this,{xmin:n,xmax:o}=s;return[(t*i+e*r-n)/(o-n),0]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:i,xmax:r}=e;return[y(t)/(r-i),0]}},Ni=class extends wt{constructor(t,e,i,r){super(t,e,i,r),this.method="rectangular"}getRelativePosition(t,e){const{bounds:i,center:r,rotationMatrix00:s,rotationMatrix01:n,rotationMatrix10:o,rotationMatrix11:a}=this,c=t*o+e*a,u=t*s+e*n-r[0],l=c-r[1];return[u*(2/(i.xmax-i.xmin)),-l*(2/(i.ymax-i.ymin))]}calculateRelativeSizeFromAbsolute(){const{_size:t,bounds:e}=this,{xmin:i,ymin:r,xmax:s,ymax:n}=e;return[y(2*t)/(s-i),y(2*t)/(n-r)]}};class Yi extends wt{constructor(e,i,r){super(e,i,r,0),this.method="circular";const{xmin:s,xmax:n,ymin:o,ymax:a}=this.bounds,c=n-s,u=a-o;this.radius=Math.sqrt(c*c+u*u)/2}getRelativePosition(e,i){const{center:r,radius:s}=this;return[(e-r[0])/s,-((i-r[1])/s)]}calculateRelativeSizeFromAbsolute(){const{_size:e}=this;return[y(e)/this.radius,0]}}function Bi(t,e){if(t==null)return null;const i=de(e.angle),r=e.gradientSize,s=e.gradientSizeUnits;switch(e.gradientMethod.toLowerCase()){case"linear":return new Li(t,r,s,i);case"rectangular":return new Ni(t,r,s,i);case"circular":return new Yi(t,r,s);default:return Di().errorOnce(`Gradient fill method "${e.gradientMethod}" currently unsupported.`),null}}const Fi={createComputedParams:t=>t,optionalAttributes:Q.optionalAttributes,attributes:{...Q.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientSizeUnits:t,gradientType:e})=>{let i=0;return t===it.Absolute&&(i|=L(Dt.isAbsolute)),e.toLowerCase()==="discrete"&&(i|=L(Dt.isDiscrete)),i}},tlbr:{count:4,type:h.UNSIGNED_SHORT,pack:({sprite:t})=>{const{rect:e,width:i,height:r}=t,s=e.x+P+st,n=e.y+P;return[s,n,s+i-2*st,n+r]}},relativePosition:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:t},e,i,r)=>(t==null?void 0:t.getRelativePosition(i,r))??[0,0]},relativeGradientSize:{count:2,type:h.HALF_FLOAT,packTessellation:({gradientStats:t})=>(t==null?void 0:t.relativeSize)??[1,1]},gradientMethod:{count:1,type:h.UNSIGNED_BYTE,pack:({gradientMethod:t})=>{switch(t.toLowerCase()){case"rectangular":return ut.rectangular;case"circular":return ut.circular;default:return ut.linear}}}}};let Mr=class extends kt{constructor(){super(...arguments),this.vertexSpec=Fi}get _preventEffectClipping(){return!0}createTesselationParams(t){return{gradientStats:Bi(t.readGeometryForDisplay(),this.evaluatedMeshParams)}}_write(t,e,i){var o;const r=(i==null?void 0:i.asOptimized())??e.readGeometryForDisplay(),s=this._clip(r);if(!s)return;const n=(o=this.evaluatedMeshParams.sprite)==null?void 0:o.textureBinding;t.recordStart(this.instanceId,this.attributeLayout,n),this._writeGeometry(t,e,s),t.recordEnd()}};const Gi={optionalAttributes:Y.optionalAttributes,createComputedParams:t=>t,attributes:{...Y.attributes,...oe.attributes}},Ri={optionalAttributes:Y.optionalAttributes,createComputedParams:t=>t,attributes:{...Y.attributes,...Pt.attributes}};class Ci extends bt{constructor(){super(...arguments),this.vertexSpec=Ri}}class Er extends ae{constructor(){super(...arguments),this.vertexSpec=Gi}_createOutlineWriter(e,i,r,s){return new Ci(e,i,r,s)}_write(e,i,r){var a;const s=(r==null?void 0:r.asOptimized())??i.readGeometryForDisplay(),n=this._clip(s);if(!n)return;const o=(a=this.evaluatedMeshParams.sprite)==null?void 0:a.textureBinding;e.recordStart(this.instanceId,this.attributeLayout,o),this._writeGeometry(e,i,n),this._lineMeshWriter.writeLineVertices(e,T.fromOptimizedCIM(n,"esriGeometryPolyline"),i),e.recordEnd()}ensurePacked(e,i,r){super.ensurePacked(e,i,r),this._lineMeshWriter.ensurePacked(e,i,r)}enqueueRequest(e,i,r){super.enqueueRequest(e,i,r),this._lineMeshWriter.enqueueRequest(e,i,r)}async loadDependencies(){await Promise.all([super.loadDependencies(),this._lineMeshWriter.loadDependencies()])}}const Oi={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1},offset:{type:h.BYTE,count:2,packAlternating:{count:4,pack:()=>[[-1,-1],[1,-1],[-1,1],[1,1]]}}}};let zr=class extends U{constructor(){super(...arguments),this.vertexSpec=Oi}_write(t,e){var r;t.recordStart(this.instanceId,this.attributeLayout);const i=e.getDisplayId();if(e.geometryType==="esriGeometryPoint"){const s=e.readXForDisplay(),n=e.readYForDisplay();this._writeQuad(t,i,s,n)}else e.geometryType==="esriGeometryMultipoint"&&((r=e.readGeometryForDisplay())==null||r.forEachVertex((s,n)=>{s>=0&&s<=512&&n>=0&&n<=512&&this._writeQuad(t,i,s,n)}));t.recordEnd()}_writeQuad(t,e,i,r){const s=t.vertexCount();this._writeVertex(t,e,i,r),t.indexWrite(s+0),t.indexWrite(s+1),t.indexWrite(s+2),t.indexWrite(s+1),t.indexWrite(s+3),t.indexWrite(s+2)}};class ce{static getPlacement(e,i,r,s,n,o){const a=_e(r);return a?(i===-1&&e.invertY(),a.execute(e,r,s,n,o)):null}}const Yt=96;class Ui{constructor(e){const{offsetX:i,offsetY:r,postAngle:s,fontSize:n,haloSize:o,outlineSize:a,scaleFactor:c,transforms:u}=e;if(this.offsetX=i,this.offsetY=r,this.postAngle=s,this.fontSize=Math.min(n,Yt),this.haloSize=o??0,this.outlineSize=a??0,this.transforms=u,u&&u.infos.length>1){const l=Zt(n,s,!1,i,r,u,!1);this.fontSize=Math.min(l.size,Yt);const p=l.size/n;this.haloSize*=p,this.outlineSize*=p,this.postAngle=l.rotation,this.offsetX=l.offsetX,this.offsetY=l.offsetY}c&&(this.fontSize*=c,this.offsetX*=c,this.offsetY*=c)}}const Wi=28,A=[4,4],tt=[16,4],Hi={topLeft:tt,topRight:tt,bottomLeft:tt,bottomRight:tt},at=[4,2],b=[4,6],Bt={topLeft:at,topRight:at,bottomLeft:b,bottomRight:b},Ft={topLeft:at,topRight:b,bottomLeft:at,bottomRight:b},Xi={topLeft:b,topRight:b,bottomLeft:A,bottomRight:A},Vi={topLeft:A,topRight:A,bottomLeft:b,bottomRight:b},Zi={topLeft:b,topRight:A,bottomLeft:b,bottomRight:A},qi={topLeft:A,topRight:b,bottomLeft:A,bottomRight:b},Qi={createComputedParams:t=>t,optionalAttributes:{zoomRange:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:ct,packTessellation:({minZoom:t,maxZoom:e})=>[t||0,e||Wi]},clipAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({clipAngle:t})=>$i(t||0)},referenceSymbol:{type:h.BYTE,count:4,packPrecisionFactor:1,packTessellation:(t,e)=>{const i=t.isLineLabel||!t.referenceBounds,r=xe(i?"center":e.horizontalAlignment),s=me(i?"middle":e.verticalAlignment),{offsetX:n,offsetY:o,size:a}=i?{offsetX:0,offsetY:0,size:0}:t.referenceBounds;return[y(n),-y(o),Math.round(y(a)),r+1<<2|s+1]}}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({isBackground:t,mapAligned:e})=>W([[ke,t],[ve,!!e]])},offset:{type:h.SHORT,count:2,packPrecisionFactor:8,packAlternating:{count:4,packTessellation:({offsets:t})=>{const{bottomLeft:e,bottomRight:i,topLeft:r,topRight:s}=t;return[r,s,e,i]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,packTessellation:({texcoords:t})=>{const{bottomLeft:e,bottomRight:i,topLeft:r,topRight:s}=t;return[r,s,e,i]}}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,packTessellation:({color:t})=>t},fontSize:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t})=>Math.round(y(t))},referenceSize:{type:h.UNSIGNED_BYTE,count:1,packPrecisionFactor:4,packTessellation:({fontSize:t},{referenceSize:e})=>Math.round(y(e??t))},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)},haloColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({haloColor:t})=>g(t)},outlineAndHaloSize:{type:h.UNSIGNED_SHORT,count:2,packPrecisionFactor:4,packTessellation:({outlineSize:t,haloSize:e})=>[Math.round(y(t)),Math.round(y(e))]}}};class Ar extends U{constructor(){super(...arguments),this.vertexSpec=Qi,this._textMeshParamsPropsInitialized=!1}ensurePacked(e,i,r){super.ensurePacked(e,i,r),this._textMeshParamsPropsInitialized&&!this._evaluator.hasDynamicProperties||(this._textMeshTransformProps=new Ui(this.evaluatedMeshParams),this._textMeshParamsPropsInitialized=!0)}_write(e,i,r){var c;const s=this._getShaping();if(!s)return;const n=i.getDisplayId();if(this.evaluatedMeshParams.placement!=null)return this._writePlacedTextMarkers(e,i,s,r);if(r!=null&&r.nextPath())return r.nextPoint(),this._writeGlyphs(e,n,r.x,r.y,s,0);if(i.geometryType==="esriGeometryPolygon"){const u=i.readCentroidForDisplay();if(!u)return;const[l,p]=u.coords;return this._writeGlyphs(e,n,l,p,s,0)}if(i.geometryType==="esriGeometryMultipoint")return void((c=i.readGeometryForDisplay())==null?void 0:c.forEachVertex((u,l)=>this._writeGlyphs(e,n,u,l,s,0)));const o=i.readXForDisplay(),a=i.readYForDisplay();return this._writeGlyphs(e,n,o,a,s,0)}_writePlacedTextMarkers(e,i,r,s){const n=s??T.fromFeatureSetReaderCIM(i);if(!n)return;const o=-1,a=ce.getPlacement(n,o,this.evaluatedMeshParams.placement,y(1),e.id,St());if(!a)return;const c=i.getDisplayId();let u=a.next();for(;u!=null;){const l=u.tx,p=-u.ty,x=-u.getAngle();this._writeGlyphs(e,c,l,p,r,x),u=a.next()}}_getShaping(e){var u;const i=this._textMeshTransformProps,r=this.evaluatedMeshParams;if(!((u=r.glyphs)!=null&&u.glyphs.length))return null;const s=y(i.fontSize),n=y(i.offsetX),o=y(i.offsetY),a=Tt(y(r.lineWidth),Me,Te),c=Ee*Tt(r.lineHeightRatio,.25,4);return ye(r.glyphs,{scale:s/ze,angle:i.postAngle,xOffset:n,yOffset:o,horizontalAlignment:r.horizontalAlignment,verticalAlignment:e||r.verticalAlignment,maxLineWidth:a,lineHeight:c,decoration:r.decoration,borderLineSizePx:y(r.boxBorderLineSize),hasBackground:!!r.boxBackgroundColor,useCIMAngleBehavior:r.useCIMAngleBehavior})}_writeGlyphs(e,i,r,s,n,o,a,c){const u=this.evaluatedMeshParams,l=this._textMeshTransformProps,p=y(l.fontSize),x=l.haloSize,d=l.outlineSize,f=y(l.offsetX),m=y(l.offsetY),[_,k]=$(u.scaleInfo,this.getTileInfo());o!==0&&n.setRotation(o);const v=n.bounds,D=r+v.x+f,M=s+v.y-m,B=2*(u.minPixelBuffer?u.minPixelBuffer/p:1),w=Math.max(v.width,v.height)*B;n.textBox&&(e.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),e.recordBounds(D,M,w,w),this._writeTextBox(e,i,r,s,n.textBox,a,c),e.recordEnd());for(const z of n.glyphs){e.recordStart(this.instanceId,this.attributeLayout,z.textureBinding),e.recordBounds(D,M,w,w);const{texcoords:F,offsets:G}=z;this._writeQuad(e,i,r,s,{texcoords:F,offsets:G,fontSize:p,haloSize:x,outlineSize:d,color:g(u.color),isBackground:!1,referenceBounds:a,minZoom:_,maxZoom:k,...c}),e.recordEnd()}o!==0&&n.setRotation(-o)}_writeTextBox(e,i,r,s,n,o,a){const c=this.evaluatedMeshParams,{fontSize:u,haloSize:l,outlineSize:p}=this._textMeshTransformProps,{boxBackgroundColor:x,boxBorderLineColor:d}=c,f={isBackground:!0,fontSize:u,haloSize:l,outlineSize:p,referenceBounds:o,...a};x&&(this._writeQuad(e,i,r,s,{texcoords:Hi,offsets:n.main,color:g(x),...f}),d||(this._writeQuad(e,i,r,s,{texcoords:Xi,offsets:n.top,color:g(x),...f}),this._writeQuad(e,i,r,s,{texcoords:Vi,offsets:n.bot,color:g(x),...f}),this._writeQuad(e,i,r,s,{texcoords:Zi,offsets:n.left,color:g(x),...f}),this._writeQuad(e,i,r,s,{texcoords:qi,offsets:n.right,color:g(x),...f}))),d&&(this._writeQuad(e,i,r,s,{texcoords:Bt,offsets:n.top,color:g(d),...f}),this._writeQuad(e,i,r,s,{texcoords:Bt,offsets:n.bot,color:g(d),...f}),this._writeQuad(e,i,r,s,{texcoords:Ft,offsets:n.left,color:g(d),...f}),this._writeQuad(e,i,r,s,{texcoords:Ft,offsets:n.right,color:g(d),...f}))}_writeQuad(e,i,r,s,n){const o=e.vertexCount();this._writeVertex(e,i,r,s,n),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const $i=t=>Math.round(t*(254/360)),Ji={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({gradientMethod:t,gradientSizeUnits:e,gradientType:i})=>W([[lt.isAlongLine,t.toLowerCase()==="alongline"],[lt.isAbsoluteSize,e===it.Absolute],[lt.isDiscrete,i.toLowerCase()==="discrete"]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:i,height:r}=t,s=e.x+P+st,n=e.y+P;return[s,n,s+i-2*st,n+r]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},gradientSize:{type:h.HALF_FLOAT,count:1,pack:({gradientSize:t,gradientSizeUnits:e})=>e===it.Relative?t/100:y(t)},totalLength:{type:h.HALF_FLOAT,count:1,packTessellation:({pathLength:t})=>t},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]}}};let Dr=class extends vt{get _preventEffectClipping(){return!0}constructor(t,e,i,r){super(t,e,i,r),this.vertexSpec=Ji,this._tessellationOptions.textured=!0}_write(t,e,i){const r=i??T.fromFeatureSetReaderCIM(e);if(!r)return;const{sprite:s}=this.evaluatedMeshParams;this._writeGeometry(t,e,r,s==null?void 0:s.textureBinding)}};const ji={createComputedParams:t=>t,optionalAttributes:E.optionalAttributes,attributes:{...E.attributes,bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({shouldSampleAlphaOnly:t,shouldScaleDash:e,isSDF:i})=>W([[Wt,t],[Pe,e],[be,i]])},tlbr:{type:h.UNSIGNED_SHORT,count:4,pack:({sprite:t})=>{const{rect:e,width:i,height:r}=t,s=e.x+P,n=e.y+P;return[s,n,s+i,n+r]}},accumulatedDistance:{type:h.UNSIGNED_SHORT,count:1,packTessellation:({distance:t})=>t},segmentDirection:{type:h.BYTE,count:2,packPrecisionFactor:16,packTessellation:({directionX:t,directionY:e})=>[t,e]},offsetAlongLine:{type:h.HALF_FLOAT,count:1,pack:({offsetAlongLine:t})=>y(t)},capType:{type:h.UNSIGNED_BYTE,count:1,pack:({capType:t})=>{switch(t){case C.Butt:case"butt":return 0;case C.Square:case"square":return 1;case C.Round:case"round":return 2;default:return 0}}}}};class Ir extends vt{constructor(e,i,r,s){super(e,i,r,s),this.vertexSpec=ji,this._tessellationOptions.textured=!0}_write(e,i,r){const s=r??T.fromFeatureSetReaderCIM(i);if(!s)return;const{sprite:n}=this.evaluatedMeshParams;this._writeGeometry(e,i,s,n==null?void 0:n.textureBinding)}}let Ki=class gt{static from(e){return"width"in e?this.fromSimpleMeshParams(e):this.fromComplexMeshParams(e)}static fromSimpleMeshParams(e){const i=new gt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects),{type:r,width:s,height:n,angle:o,alignment:a,outlineSize:c,referenceSize:u,sprite:l,overrideOutlineColor:p}=e;return i.rawWidth=y(s),i.rawHeight=y(n),i.angle=o,i.alignment=a,i.outlineSize=y(c),i.referenceSize=y(u),i.overrideOutlineColor=p,i.offsetX=y(e.offsetX),i.offsetY=y(e.offsetY),r!=="simple"||l.sdf||(i.rawWidth=l.width,i.rawHeight=l.height),i._computeSize(e,!1),i}static fromComplexMeshParams(e){const i=new gt(e.sprite,e.color,e.outlineColor,e.minPixelBuffer,e.placement,e.scaleInfo,e.effects);let{alignment:r,transforms:s,size:n,scaleX:o,anchorX:a,anchorY:c,angle:u,colorLocked:l,frameHeight:p,widthRatio:x,offsetX:d,offsetY:f,outlineSize:m,referenceSize:_,scaleFactor:k,sizeRatio:v,isAbsoluteAnchorPoint:D,rotateClockwise:M,scaleSymbolsProportionally:B,sprite:w}=e;if(s&&s.infos.length>0){const G=Zt(n,u,M,d,f,s);n=G.size,u=G.rotation,d=G.offsetX,f=G.offsetY,M=!1}k&&(n*=k,d*=k,f*=k);const z=o*(w.width/w.height);i.alignment=r,i.rawHeight=y(n),i.rawWidth=i.rawHeight*z,i.referenceSize=y(_),i.sizeRatio=v,i.sdfDecodeCoeff=(w.sdfDecodeCoeff??1)*v,i.angle=u,i.rotateClockwise=M,i.anchorX=a,i.anchorY=c,i.offsetX=y(d),i.offsetY=y(f),D&&n&&(w.sdf?i.anchorX=a/(n*x):i.anchorX=a/(n*z),i.anchorY=c/n);const F=B&&p?n/p:1;return i.outlineSize=m===0||isNaN(m)?0:y(m)*F,i.scaleSymbolsProportionally=B,i.colorLocked=l,i._computeSize(e,!0),i}constructor(e,i,r,s,n,o,a){this.sprite=e,this.color=i,this.outlineColor=r,this.minPixelBuffer=s,this.placement=n,this.scaleInfo=o,this.effects=a,this.rawWidth=0,this.rawHeight=0,this.angle=0,this.outlineSize=0,this.referenceSize=0,this.sizeRatio=1,this.sdfDecodeCoeff=1,this.alignment=Xt.SCREEN,this.scaleSymbolsProportionally=!1,this.overrideOutlineColor=!1,this.colorLocked=!1,this.anchorX=0,this.anchorY=0,this.computedWidth=0,this.computedHeight=0,this.texXmin=0,this.texYmin=0,this.texXmax=0,this.texYmax=0,this.offsetX=0,this.offsetY=0,this.rotateClockwise=!0}get boundsInfo(){return{size:Math.max(this.computedHeight,this.computedWidth),offsetX:this.offsetX,offsetY:this.offsetY}}_computeSize(e,i){const{sprite:r,hasSizeVV:s}=e,n=!!r.sdf,o=r.sdfPaddingRatio??.5,{rawWidth:a,rawHeight:c,sizeRatio:u,outlineSize:l}=this,p=r.rect;let x=a*u,d=c*u,f=0,m=0;if(n){const M=1/(1-o);if(x*=M,d*=M,s)this.computedWidth=x,this.computedHeight=d;else{const B=i&&a>c?x:a,w=c,z=l+2*1;this.computedWidth=Math.min(B+z,x),this.computedHeight=Math.min(w+z,d);const F=Math.max(r.width,r.height)/Math.max(x,d);f=(this.computedWidth-x)*F,m=(this.computedHeight-d)*F}}else this.computedWidth=x*(p.width/r.width),this.computedHeight=d*(p.height/r.height),f=2*P,m=2*P;const _=p.x+P-f/2,k=p.y+P-m/2,v=_+r.width+f,D=k+r.height+m;this.texXmin=Gt(_),this.texYmin=Gt(k),this.texXmax=Rt(v),this.texYmax=Rt(D),this.computedWidth*=(this.texXmax-this.texXmin)/(v-_),this.computedHeight*=(this.texYmax-this.texYmin)/(D-k),this.anchorX*=x/this.computedWidth,this.anchorY*=d/this.computedHeight}};function Gt(t,e=1e-7){const i=Math.ceil(t);return i-t<e?i:Math.floor(t)}function Rt(t,e=1e-7){const i=Math.floor(t);return t-i<e?i:Math.ceil(t)}const tr=3.14159265359/180,er=128/Math.PI;function ir(t,e){return t%=e,Math.abs(t>=0?t:t+e)}function rr(t){return ir(t*er,256)}function sr(t,e,i,r,s=!1){const n=Ge(),o=s?1:-1;return Ye(n),(e||i)&&Be(n,n,[e,-i]),r&&Fe(n,n,o*tr*-r),n}const nr={createComputedParams:t=>Ki.from(t),optionalAttributes:{zoomRange:{type:h.SHORT,count:2,packPrecisionFactor:ct,pack:({scaleInfo:t},{tileInfo:e})=>$(t,e)}},attributes:{pos:{type:h.SHORT,count:2,pack:"position",packPrecisionFactor:10},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:({sprite:t,alignment:e,scaleSymbolsProportionally:i,overrideOutlineColor:r,colorLocked:s})=>{let n=0;return t.sdf&&(n|=L(H.bitset.isSDF)),e===Xt.MAP&&(n|=L(H.bitset.isMapAligned)),i&&(n|=L(H.bitset.scaleSymbolsProportionally)),r&&(n|=L(H.bitset.overrideOutlineColor)),s&&(n|=L(H.bitset.colorLocked)),n}},offset:{type:h.HALF_FLOAT,count:2,packAlternating:{count:4,pack:({angle:t,computedWidth:e,computedHeight:i,anchorX:r,anchorY:s,offsetX:n,offsetY:o,rotateClockwise:a})=>{const c=sr(0,n,o,-t,a),u=-(.5+r)*e,l=-(.5-s)*i,p=[u,l],x=[u+e,l],d=[u,l+i],f=[u+e,l+i];return J(p,p,c),J(x,x,c),J(d,d,c),J(f,f,c),[p,x,d,f]}}},textureUV:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:({texXmax:t,texXmin:e,texYmax:i,texYmin:r})=>[[e,r],[t,r],[e,i],[t,i]]}},color:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({color:t})=>g(t)},outlineColor:{type:h.UNSIGNED_BYTE,count:4,normalized:!0,pack:({outlineColor:t})=>g(t)},sizing:{type:h.UNSIGNED_BYTE,count:4,pack:({rawWidth:t,rawHeight:e,outlineSize:i,referenceSize:r})=>{const s=Math.max(t,e);return[ft(s,128),ft(i,128),ft(r,128),0]}},placementAngle:{type:h.UNSIGNED_BYTE,count:1,packTessellation:({placementAngle:t})=>rr(t)},sdfDecodeCoeff:{type:h.UNSIGNED_SHORT,count:1,packPrecisionFactor:64,pack:({sdfDecodeCoeff:t})=>t}}};class Lr extends U{constructor(){super(...arguments),this.vertexSpec=nr}getBoundsInfo(){return this.evaluatedMeshParams.boundsInfo}_write(e,i,r){var d,f;const s=(d=this.evaluatedMeshParams.sprite)==null?void 0:d.textureBinding,n=i.getDisplayId();e.recordStart(this.instanceId,this.attributeLayout,s);const o=this.evaluatedMeshParams.minPixelBuffer,a=Math.max(this.evaluatedMeshParams.computedWidth,o),c=Math.max(this.evaluatedMeshParams.computedHeight,o),u=-this.evaluatedMeshParams.anchorX*this.evaluatedMeshParams.computedWidth,l=this.evaluatedMeshParams.anchorY*this.evaluatedMeshParams.computedHeight,p=this.evaluatedMeshParams.offsetX+u,x=-this.evaluatedMeshParams.offsetY+l;if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(e,i,r,a,c);else if(r!=null&&r.nextPath()){r.nextPoint();const m=r.x,_=r.y;e.recordBounds(m+p,_+x,a,c),this._writeQuad(e,n,m,_)}else if(i.geometryType==="esriGeometryPolygon"){const m=i.readCentroidForDisplay();if(!m)return;const[_,k]=m.coords;e.recordBounds(_+p,k+x,a,c),this._writeQuad(e,n,_,k)}else if(i.geometryType==="esriGeometryPoint"){const m=i.readXForDisplay(),_=i.readYForDisplay();e.recordBounds(m+p,_+x,a,c),this._writeQuad(e,n,m,_)}else(f=i.readGeometryForDisplay())==null||f.forEachVertex((m,_)=>{e.recordBounds(m+p,_+x,a,c),Math.abs(m)>j||Math.abs(_)>j||this._writeQuad(e,n,m,_)});e.recordEnd()}_writePlacedMarkers(e,i,r,s,n){var d;const o=r??((d=T.fromFeatureSetReaderCIM(i))==null?void 0:d.clone());if(!o)return;const a=-1,c=ce.getPlacement(o,a,this.evaluatedMeshParams.placement,y(1),e.id,St());if(!c)return;const u=i.getDisplayId();let l=c.next();const p=this.evaluatedMeshParams.offsetX,x=-this.evaluatedMeshParams.offsetY;for(;l!=null;){const f=l.tx,m=-l.ty;if(Math.abs(f)>j||Math.abs(m)>j){l=c.next();continue}const _=-l.getAngle();e.recordBounds(f+p,m+x,s,n),this._writeQuad(e,u,f,m,_),l=c.next()}}_writeQuad(e,i,r,s,n){const o=e.vertexCount(),a=n==null?null:{placementAngle:n};this._writeVertex(e,i,r,s,a),e.indexWrite(o+0),e.indexWrite(o+1),e.indexWrite(o+2),e.indexWrite(o+1),e.indexWrite(o+3),e.indexWrite(o+2)}}const or={createComputedParams:t=>t,optionalAttributes:{},attributes:{pos:{type:h.SHORT,count:2,packPrecisionFactor:10,pack:"position"},id:{type:h.UNSIGNED_BYTE,count:3,pack:"id"},bitset:{type:h.UNSIGNED_BYTE,count:1,pack:t=>0},offset:{type:h.SHORT,count:2,packPrecisionFactor:16,packAlternating:{count:4,pack:({size:t})=>{const e=y(t),i=-e/2,r=-e/2;return[[i,r],[i+e,r],[i,r+e],[i+e,r+e]]}}},texCoords:{type:h.SHORT,count:2,packPrecisionFactor:4,packAlternating:{count:4,pack:()=>[[0,1],[1,1],[0,0],[1,0]]}},size:{type:h.UNSIGNED_BYTE,count:2,pack:({size:t})=>[t,t]},referenceSize:{type:h.UNSIGNED_BYTE,count:1,pack:({size:t})=>y(t)},zoomRange:{type:h.UNSIGNED_BYTE,count:2,pack:({scaleInfo:t},{tileInfo:e})=>$(t,e)}}};class Nr extends U{constructor(){super(...arguments),this.vertexSpec=or}_write(e,i){const r=i.getDisplayId(),s=this.evaluatedMeshParams.minPixelBuffer,n=Math.max(y(this.evaluatedMeshParams.size),s);let o,a;if(i.geometryType==="esriGeometryPoint")o=i.readXForDisplay(),a=i.readYForDisplay();else{const u=i.readCentroidForDisplay();if(!u)return;o=u==null?void 0:u.coords[0],a=u==null?void 0:u.coords[1]}e.recordStart(this.instanceId,this.attributeLayout),e.recordBounds(o,a,n,n);const c=e.vertexCount();this._writeVertex(e,r,o,a),e.indexWrite(c+0),e.indexWrite(c+1),e.indexWrite(c+2),e.indexWrite(c+1),e.indexWrite(c+3),e.indexWrite(c+2),e.recordEnd()}}export{L as A,bi as K,Tr as N,Mr as O,li as Q,br as S,wr as T,$ as U,Er as X,U as Y,zr as Z,g as _,vt as a,re as b,Ar as e,Lr as f,Dr as i,Nr as m,Wi as n,Ir as o,ae as w};
