import{ac as z,N as T,a1 as S,aM as D,d6 as L,Y as x,d7 as M,h as p,p as P,Q as I,v as y,S as b,q as C,a2 as U,aD as N,s as k,n as j,d8 as E}from"./index-aQr1pzMk.js";import{G as H}from"./ByteSizeUnit-DL8UhsB0-B2-AmVRx.js";import{i as J}from"./LRUCache-DPWdPNTF-BhV6gJVw.js";import{e as R}from"./TileKey-B_6qmYK--BtZdR-Xy.js";import{c as F}from"./memoryEstimations-DeWfxwaV-BEOBMvAl.js";function G(t,e=!1){return t<=E?e?new Array(t).fill(0):new Array(t):new Uint32Array(t)}class g{constructor(e){Y(e);const{location:a,data:l}=e;this.location=Object.freeze(C(a));const i=this.location.width,n=this.location.height;let r=!0,h=!0;const o=Math.ceil(i*n/32),s=G(o);let f=0;for(let c=0;c<l.length;c++){const u=c%32;l[c]?(h=!1,s[f]|=1<<u):r=!1,u===31&&++f}h?(this._availability="unavailable",this.byteSize=40):r?(this._availability="available",this.byteSize=40):(this._availability=s,this.byteSize=40+F(s))}getAvailability(e,a){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const l=(e-this.location.top)*this.location.width+(a-this.location.left),i=l%32,n=l>>5,r=this._availability;return n<0||n>r.length?"unknown":r[n]&1<<i?"available":"unavailable"}static fromDefinition(e,a){const l=e.service.request||T,{row:i,col:n,width:r,height:h}=e,o={query:{f:"json"}};return a=a?{...o,...a}:o,l(K(e),a).then(s=>s.data).catch(s=>{var f;if(((f=s==null?void 0:s.details)==null?void 0:f.httpStatus)===422)return{location:{top:i,left:n,width:r,height:h},valid:!0,data:new Array(r*h).fill(0)};throw s}).then(s=>{if(s.location&&(s.location.top!==i||s.location.left!==n||s.location.width!==r||s.location.height!==h))throw new p("tilemap:location-mismatch","Tilemap response for different location than requested",{response:s,definition:{top:i,left:n,width:r,height:h}});return g.fromJSON(s)})}static fromJSON(e){return Object.freeze(new g(e))}}function A(t){return`${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}function K(t){var l;let e;if((l=t.service.tileServers)!=null&&l.length){const i=t.service.tileServers;e=`${i&&i.length?i[t.row%i.length]:t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`}else e=`${t.service.url}/tilemap/${t.level}/${t.row}/${t.col}/${t.width}/${t.height}`;const a=t.service.query;return a&&(e=`${e}?${a}`),e}function Y(t){if(!(t!=null&&t.location))throw new p("tilemap:missing-location","Location missing from tilemap response");if(t.valid===!1)throw new p("tilemap:invalid","Tilemap response was marked as invalid");if(!t.data)throw new p("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(t.data))throw new p("tilemap:data-mismatch","Data must be an array of numbers");if(t.data.length!==t.location.width*t.location.height)throw new p("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var d;function O(t,e,a){return new p("tile-map:tile-unavailable","Tile is not available",{level:t,row:e,col:a})}var m;let v=(m=class extends z{constructor(e){super(e),this._pendingTilemapRequests={},this.request=T,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new J(2*H.MEGABYTES),this.addHandles(S(()=>{const{layer:e}=this;return[e==null?void 0:e.parsedUrl,e==null?void 0:e.tileServers,e==null?void 0:e.apiKey,e==null?void 0:e.customParameters]},()=>this._initializeTilemapDefinition(),U))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,a,l){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const i=this._tilemapFromCache(e,a,l,this._tmpTilemapDefinition);return i?i.getAvailability(a,l):"unknown"}fetchAvailability(e,a,l,i){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(O(e,a,l)):this._fetchTilemap(e,a,l,i).catch(n=>n).then(n=>{if(n instanceof g){const r=n.getAvailability(a,l);if(r==="unavailable")throw O(e,a,l);return r}if(D(n))throw n;return"unknown"})}fetchAvailabilityUpsample(e,a,l,i,n){i.level=e,i.row=a,i.col=l;const r=this.layer.tileInfo;r.updateTileInfo(i);const h=this.fetchAvailability(e,a,l,n).catch(o=>{if(D(o))throw o;if(r.upsampleTile(i))return this.fetchAvailabilityUpsample(i.level,i.row,i.col,i,n);throw o});return this._fetchAvailabilityUpsamplePrefetch(i.id,e,a,l,n,h),h}async _fetchAvailabilityUpsamplePrefetch(e,a,l,i,n,r){if(!this._prefetchingEnabled||e==null)return;const h=`prefetch-${e}`;if(this.hasHandles(h))return;const o=new AbortController;r.then(()=>o.abort(),()=>o.abort());let s=!1;const f=N(()=>{s||(s=!0,o.abort())});if(this.addHandles(f,h),await L(10,o.signal).catch(()=>{}),s||(s=!0,this.removeHandles(h)),x(o))return;const c=new R(e,a,l,i),u={...n,signal:o.signal},w=this.layer.tileInfo;for(let q=0;d._prefetches.length<d._maxPrefetch&&w.upsampleTile(c);++q){const _=this.fetchAvailability(c.level,c.row,c.col,u);d._prefetches.push(_);const $=()=>{d._prefetches.removeUnordered(_)};_.then($,$)}}_fetchTilemap(e,a,l,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new p("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const n=this._tmpTilemapDefinition,r=this._tilemapFromCache(e,a,l,n);if(r)return Promise.resolve(r);const h=i==null?void 0:i.signal;return i={...i,signal:null},new Promise((o,s)=>{P(h,()=>s(k()));const f=A(n);let c=this._pendingTilemapRequests[f];if(!c){c=g.fromDefinition(n,i).then(w=>(this._tilemapCache.put(f,w,w.byteSize),w));const u=()=>{delete this._pendingTilemapRequests[f]};this._pendingTilemapRequests[f]=c,c.then(u,u)}c.then(o,s)})}_initializeTilemapDefinition(){var i;if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:a,customParameters:l}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:I({...e.query,...l,token:a??((i=e.query)==null?void 0:i.token)}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,a,l,i){i.level=e,i.row=a-a%this.size,i.col=l-l%this.size;const n=A(i);return this._tilemapCache.get(n)}get test(){}},d=m,m._maxPrefetch=4,m._prefetches=new M({initialSize:d._maxPrefetch}),m);y([b({constructOnly:!0})],v.prototype,"layer",void 0),y([b({constructOnly:!0})],v.prototype,"minLOD",void 0),y([b({constructOnly:!0})],v.prototype,"maxLOD",void 0),y([b({constructOnly:!0})],v.prototype,"request",void 0),y([b({constructOnly:!0})],v.prototype,"size",void 0),v=d=y([j("esri.layers.support.TilemapCache")],v);export{v as u};
