import{i as P}from"./TechniqueType-CMl1wqtX-7TDFwBxa.js";import{f8 as M,a8 as k,q as we,h as Ie,jc as F,jo as Le,a6 as ze}from"./index-aQr1pzMk.js";import{z as W,n as V,i as G}from"./CIMSymbolHelper-34UsTwam-Czf_50t2.js";import{$ as ie}from"./rasterizingUtils-1wASRzSP-vB261-s6.js";import{P as Ae,h as De,r as j}from"./enums-a_LDTPYU-CBIcy3mM.js";import{B as Se,Q as Ee,$ as ke,d as Re,V as fe,a as Be,n as Ce,v as Oe,O as Te,b as $e,L as Fe,k as We,_ as Ve,g as Ge,D as je,C as Q,R as N,G as H,W as U,H as _e,X as J,c as K,I as ee,e as ge,F as Ze,x as qe,f as Ye,h as Xe,Y as Qe,N as ye,i as Ne,j as He,s as Ue,r as Je,l as Ke,w as S,m as et,z as tt,M as st,A as it,o as rt,S as at,p as nt,q as ot,P as ct,t as xe,u as lt,U as ht,Z as mt,y as dt,E as ut}from"./PieChartMeshWriter-C17AlSWx-Cxqg_6ag.js";import{t as R,K as re,n as B}from"./definitions-MCCItX4r-o3EUznKY.js";import{c as pt}from"./constants-oLcGh8d3-CJuD0gcX.js";import{U as ft}from"./libtess-C6mGekL8-DhEHAynA.js";import{j as Z,q as ae}from"./mat2d-BQA-1WB--Pnyy0dhf.js";import{u as D}from"./mat2df32-fg3OHsAI-BF2V2zqo.js";import{L as ne,m as b,k as oe,j as q,b as _t,v as ce}from"./vec2-BnynUbeJ-CKtGJQAy.js";import{r as C}from"./vec2f32-hTAvipMV-C0AQcwEv.js";import{o as L}from"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{_ as gt,u as le}from"./featureConversionUtils-Bjjlcfdo-W23tSVOf.js";import{c as Y}from"./OptimizedGeometry-pzfNw1AT-DQmyFD5U.js";import{r as he}from"./BoundingBox-DlCd_wcU-DBB4UfPl.js";import{J as me,f as yt}from"./Utils-Co3xiu1z-ClJ0LPQa.js";import{A as xt}from"./ArcadeExpression-XjY3x7KV-C7Vuk4ae.js";import{x as Pt}from"./AttributeStore-Oa0mwyTc-DjF-C_WH.js";function te(l){let{pixelDimensions:e,texelDimensions:s,baseSize:a,referenceSize:r,strokeWidth:t,sizeRatio:i}=l;if(e||(e=l.sprite.sdf?[0,0]:[l.sprite.width,l.sprite.height]),s||(s=l.sprite.sdf?[0,0]:e),l.patternHeight!=null){const o=l.patternHeight/e[1];e[1]*=o,e[0]*=o}a===-1&&(a=e[1]),a=M(a),r=M(r),t=M(t);const n=(l.sprite.sdfDecodeCoeff??1)*i;return{...l,pixelDimensions:e,texelDimensions:s,baseSize:a,referenceSize:r,strokeWidth:t,sdfDecodeCoeff:n}}const X=64,vt=64,Mt=2;let Pe=class extends xe{get vertexSpec(){return{createComputedParams:te,optionalAttributes:{zoomRange:ee,value1Position2Value2:lt,lineLength:ye},attributes:{id:Q,bitset:N,pos:H,offset:U.marker,uv:ht.marker,animationPointerAndBaseSizeAndReferenceSize:J,sizing:K,angle:mt}}}_write(l,e){const s=this.evaluatedMeshParams.sprite,{textureBinding:a}=s;l.recordStart(this.instanceId,this.attributeLayout,a);const r=e.getDisplayId();if(this.shift&&e.geometryType==="esriGeometryPolyline")this._writeParticles(l,e);else if(this.evaluatedMeshParams.placement!=null)this._writePlacedMarkers(l,e);else if(e.geometryType==="esriGeometryPolygon"){const t=e.readCentroidForDisplay();if(!t)return;const[i,n]=t.coords;this._writeQuad(l,r,i,n)}else if(e.geometryType==="esriGeometryPoint"){const t=e.readXForDisplay(),i=e.readYForDisplay();this._writeQuad(l,r,t,i)}else{const t=e.readGeometryForDisplay();t&&t.forEachVertex((i,n)=>{this._writeQuad(l,r,i,n)})}l.recordEnd()}_writePlacedMarkers(l,e){var o;const s=(o=W.fromFeatureSetReaderCIM(e))==null?void 0:o.clone();if(!s)return;const a=-1,r=dt.getPlacement(s,a,this.evaluatedMeshParams.placement,M(1),l.id,ut());if(!r)return;const t=e.getDisplayId();let i=r.next(),n=null;for(;i!=null;){const c=i.tx,h=-i.ty;if(Math.abs(c)>ie||Math.abs(h)>ie){i=r.next();continue}const f=-i.getAngle();l.recordBounds(c,h,X,vt),this.shift?n&&this._writeQuad(l,t,n[0],n[1],void 0,f):this._writeQuad(l,t,c,h,void 0,f),n=[c,h],i=r.next()}}_writeParticles(l,e){const s=e.getDisplayId(),a=e.readGeometryForDisplay();if(!a)return;const r=[];a.forEachVertex((c,h)=>{r.push([c,h])});const t=bt(r);let i=0;for(let c=1;c<r.length;c++){const h=r[c][0]-r[c-1][0],f=r[c][1]-r[c-1][1],m=Math.sqrt(h*h+f*f);i+=m}const n=c=>{for(const h of t){const{a:f,b:m}=h;this._writeQuad(l,s,f.position[0],f.position[1],[f.distance-c,m.position[0],m.position[1],m.distance-c],this.evaluatedMeshParams.angleToLine?Math.atan2(f.direction[1],f.direction[0]):0,i,!0)}},{placement:o}=this.evaluatedMeshParams;if(!o||"placementTemplate"in o||o.type==="CIMMarkerPlacementOnVertices"){let c;if(o&&o.type!=="CIMMarkerPlacementOnVertices")c=o.placementTemplate;else{c=[0];for(const f of t){const{a:m,b:d}=f,p=m.position[0]-d.position[0],u=m.position[1]-d.position[1],_=Math.sqrt(p*p+u*u);c.push(_)}}let h=-1*i;for(;h<(1+Mt/2)*i;)for(const f of c)h+=f,n(h)}else o.type==="CIMMarkerPlacementAtExtremities"?o.extremityPlacement===j.JustBegin?n(1):o.extremityPlacement===j.JustEnd?(n(i-1),n(-1)):o.extremityPlacement===j.Both&&(n(1),n(i-1)):o.type==="CIMMarkerPlacementOnLine"&&n(i/2)}_writeQuad(l,e,s,a,r,t=0,i=0,n=!1){const o=this.evaluatedMeshParams.sprite,{rect:c}=o,h=c.x+B,f=c.y+B,m=c.x+c.width-B,d=c.y+c.height-B,p=l.vertexCount();n||l.recordBounds(s,a,X,X);const u={texXmin:h,texYmin:f,texXmax:m,texYmax:d,value1Position2Value2:r,angle:t/pt,lineLength:i};for(let _=0;_<4;_++)this._writeVertex(l,e,s,a,u);l.indexEnsureSize(6),l.indexWrite(p),l.indexWrite(p+1),l.indexWrite(p+2),l.indexWrite(p+1),l.indexWrite(p+3),l.indexWrite(p+2)}};function bt(l){const e=[];let s=0;for(let a=1;a<l.length;a++){const r=l[a-1],t=l[a],i=t[0]-r[0],n=t[1]-r[1],o=Math.sqrt(i*i+n*n),c=i/o,h=n/o;e.push({a:{position:r,distance:s,direction:[c,h]},b:{position:t,distance:s+o,direction:[c,h]}}),s+=o}return e}let wt=class extends Pe{constructor(){super(...arguments),this.shift=!1}},It=class extends Pe{constructor(){super(...arguments),this.shift=!0}},ve=class extends xe{_write(l,e,s){const a=s??W.fromFeatureSetReaderCIM(e);if(!a)return;const r=this.evaluatedMeshParams.sprite,{textureBinding:t}=r;l.recordStart(this.instanceId,this.attributeLayout,t);const i=e.getDisplayId();this._writePoly(l,i,a.asOptimized()),l.recordEnd()}},Lt=class extends ve{constructor(){super(...arguments),this.vertexSpec={createComputedParams:te,attributes:{id:Q,bitset:N,pos:H,offset:U.fill,tlbr:_e,animationPointerAndBaseSizeAndReferenceSize:J,sizing:K},optionalAttributes:{zoomRange:ee,value1Position2Value2:ge,lineLength:Ze}}}_writePoly(l,e,s){const a=[];if(!qe(a,s))return;const r=l.vertexCount();s.forEachVertex((t,i)=>{this._writeVertex(l,e,t,i)}),l.indexEnsureSize(a.length);for(const t of a)l.indexWrite(r+t)}},zt=class{constructor(){this.id=0,this.bitset=0,this.indexCount=0,this.vertexCount=0,this.vertexFrom=0,this.vertexBounds=0,this.pathLength=0}};const de=65535;class At extends ve{constructor(){super(...arguments),this.vertexSpec={createComputedParams:te,attributes:{id:Q,bitset:N,pos:H,offset:U.line,tlbr:_e,animationPointerAndBaseSizeAndReferenceSize:J,sizing:K,accumulatedDistance:Ye,normal:Xe,segmentDirection:Qe},optionalAttributes:{zoomRange:ee,value1Position2Value2:ge,lineLength:ye}},this._tessParams=new Ne,this._currentWrite=new zt,this._tessellationOptions={halfWidth:0,pixelCoordRatio:1,offset:0,wrapDistance:de,textured:!1},this._lineLength=0,this._lineTessellator=new ft((e,s,a,r,t,i,n,o,c,h,f)=>this._writeTesselatedVertex(e,s,a,r,t,i,n,o,c,h,f,this._lineLength),this._writeTriangle.bind(this),!1)}_writePoly(e,s,a){const r=He(W.fromOptimized(a,"esriGeometryPolyline"),64);if(r==null)return;const{_currentWrite:t,_tessellationOptions:i}=this,{baseSize:n,capType:o,joinType:c,miterLimit:h}=this.evaluatedMeshParams,f=M(.5*n);i.halfWidth=f,i.capType=Ue(o||Ae.Round),i.joinType=Je(c||De.Round),i.miterLimit=h||2,t.out=e,t.id=s,t.vertexCount=0,t.indexCount=0,t.vertexFrom=e.vertexCount(),t.vertexBounds=1;for(const{line:m,start:d,pathLength:p}of r){i.initialDistance=d%de,t.pathLength=p,this._lineLength=0;for(let u=1;u<m.length;u++){const _=m[u].x-m[u-1].x,g=m[u].y-m[u-1].y;this._lineLength+=Math.sqrt(_*_+g*g)}this._lineTessellator.tessellate(m,i,!1)}}_writeTesselatedVertex(e,s,a,r,t,i,n,o,c,h,f,m){const{out:d,id:p,vertexBounds:u,pathLength:_}=this._currentWrite;return this.hasEffects&&d.recordBounds(e,s,u,u),this._tessParams.extrusionOffsetX=n,this._tessParams.extrusionOffsetY=o,this._tessParams.normalX=c,this._tessParams.normalY=h,this._tessParams.directionX=t,this._tessParams.directionY=i,this._tessParams.distance=f,this._tessParams.pathLength=_,this._tessParams.lineLength=m,this._writeVertex(d,p,e,s,this._tessParams),this._currentWrite.vertexFrom+this._currentWrite.vertexCount++}_writeTriangle(e,s,a){const{out:r}=this._currentWrite;r.indexEnsureSize(3),r.indexWrite(e),r.indexWrite(s),r.indexWrite(a),this._currentWrite.indexCount+=3}}const O=1,z=0,Dt=128;function St(l,e){return F(`${l}${e}`)}function Et(l,e,s){return F(`${l}${e}${s}`)}function kt(l,e,s,a){return F(`${l}${e}${s*2**(S-a)}`)}function Rt(l,e,s,a,r){return F(`${l}${r}${e}${s*2**(S-a)}`)}const Bt=Le(l=>{let e=0;if(l===0)return 1/0;for(;!(l%2);)e++,l/=2;return e});class Ct extends fe{constructor(){super(...arguments),this._zoomLevel=0}_write(e,s,a,r){if(this._zoomLevel=r||0,a!=null)throw new Error("InternalError: EffectGeometry not support for LabelMeshWriter");switch(s.geometryType){case"esriGeometryPoint":{const t=s.readXForDisplay(),i=s.readYForDisplay();this._writePoint(e,t,i,0,s);break}case"esriGeometryEnvelope":case"esriGeometryPolygon":{const t=s.readCentroidForDisplay();if(!t)return;const[i,n]=t.coords;this._writePoint(e,i,n,0,s);break}case"esriGeometryMultipoint":{let t=0;const i=W.fromFeatureSetReader(s);if(i!=null&&i.nextPath())for(;i.nextPoint();)this._writePoint(e,i.x,i.y,t++,s);break}case"esriGeometryPolyline":this._writeLines(e,s)}}_getMetricDir(){const{horizontalAlignment:e,verticalAlignment:s}=this.evaluatedMeshParams;return[e==="center"?0:e==="right"?-1:1,s==="middle"?0:s==="bottom"?-1:1]}_createLineLabelMetric(e,s,a,r,t,i){var m,d;const[n,o]=this._getMetricDir(),c=((m=this.evaluatedMeshParams.scaleInfo)==null?void 0:m.maxScale)??0,h=((d=this.evaluatedMeshParams.scaleInfo)==null?void 0:d.minScale)??0,f=this.evaluatedMeshParams.labelClassId;return new me(e,f,s,a,r,t,n,o,c,h,i)}_writePoint(e,s,a,r,t){var _,g;if(s<0||s>R||a<0||a>R)return;const i=this._getShaping();if(!i)return;const n=t.getDisplayId(),o=this.evaluatedMeshParams.labelClassId,c=St(t.getObjectId(),r),h=Et(t.getObjectId(),o,r),[f,m]=this._getMetricDir(),d=((_=this.evaluatedMeshParams.scaleInfo)==null?void 0:_.maxScale)??0,p=((g=this.evaluatedMeshParams.scaleInfo)==null?void 0:g.minScale)??0,u=this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0};e.metricStart(new me(n,o,c,h,s,a,f,m,d,p,u)),this._writeGlyphs(e,n,s,a,i,0,u,void 0,!1),e.metricBoxWrite(i.boundsT),e.metricEnd()}_getPointReferenceBounds(){if(!this._references)return null;for(const e of this._references){const s=e.getBoundsInfo();if(s)return s}return null}_writeLines(e,s){const{scaleInfo:a,verticalAlignment:r}=this.evaluatedMeshParams,t=this.evaluatedMeshParams.repeatLabelDistance||128,i=this._getShaping("middle");if(!i)return;const n=(c,h,f,m)=>this._placeSubdivGlyphs(c,h,f,m),o=(i.bounds.width+t)/(1<<O);this._current={out:e,id:s.getDisplayId(),objId:s.getObjectId(),shaping:i,zoomRange:Ke(a,this.getTileInfo()),referenceBounds:this._getPointReferenceBounds()||{offsetX:0,offsetY:0,size:0},offsetDirection:null,pathIndex:0},this._verticalPlacement=r==="bottom"?"above":r==="top"?"below":null,this._verticalPlacement?this._writeAboveAndBelowAlong(s,n,o):this._writeCenterAlong(s,n,o)}_writeAboveAndBelowAlong(e,s,a){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:t}=this._current,i=t.bounds.halfHeight,n=e.readGeometryForDisplay();if(!n)return;const o=new Y;gt(o,n,!1,!1,"esriGeometryPolyline",1);const c=ue(new Y,o,i),h=ue(new Y,o,-i),f=le(h,"esriGeometryPolyline",!1,!1),m=le(c,"esriGeometryPolyline",!1,!1),d=V(m.paths,t.bounds.width),p=V(f.paths,t.bounds.width);this._current.offsetDirection="above";for(let u=0;u<d.length;u++)this._current.pathIndex=u,G(d[u],a,s,!!r);this._current.offsetDirection="below";for(let u=0;u<p.length;u++)this._current.pathIndex=u,G(p[u],a,s,!!r)}_writeCenterAlong(e,s,a){const{repeatLabel:r}=this.evaluatedMeshParams,{shaping:t}=this._current,i=V(e.readLegacyGeometryForDisplay().paths,t.bounds.width);for(let n=0;n<i.length;n++)this._current.pathIndex=n,G(i[n],a,s,!!r)}_placeSubdivGlyphs(e,s,a,r){const{allowOverrun:t,labelPosition:i,repeatLabelDistance:n}=this.evaluatedMeshParams,o=this._current.zoomRange[0],c=Bt(s),h=this._current.shaping.bounds.width/(1<<O),f=Math.sqrt(n||Dt)/(1<<O),m=Math.min(a,r-a),d=this._current.shaping.isMultiline?S:Math.log2(m/(f+h/2)),p=s===0?d:Math.min(c,d),u=Math.max(o,this._zoomLevel+O-p),_=this._zoomLevel-u,g=this._current.shaping.bounds.width/2*2**_,y=kt(this._current.objId,this._current.pathIndex,s,this._zoomLevel),v=Rt(this._current.objId,this._current.pathIndex,s,this._zoomLevel,this.evaluatedMeshParams.labelClassId);this._current.shaping.isMultiline?s===0&&this._placeStraight(e,u,y,v):t&&_<0?this._placeStraightAlong(e,o,y,v):i==="parallel"?this._placeStraightAlong(e,u,y,v):i==="curved"&&this._placeCurved(e,u,g,y,v)}_placeStraight(e,s,a,r){const{out:t,id:i,shaping:n,referenceBounds:o}=this._current,{x:c,y:h}=e;t.metricStart(this._createLineLabelMetric(i,a,r,c,h)),t.metricBoxWrite(n.boundsT);const f=e.angle*(180/Math.PI)%360,m=(e.angle*(180/Math.PI)+180)%360,d={clipAngle:f,mapAligned:!0,isLineLabel:!0,minZoom:s};this._writeGlyphs(t,i,c,h,n,0,o,d,!1);const p={clipAngle:m,mapAligned:!0,isLineLabel:!0,minZoom:s};this._writeGlyphs(t,i,c,h,n,0,o,p,!1),t.metricEnd()}_placeCurved(e,s,a,r,t){const{out:i,id:n}=this._current;i.metricStart(this._createLineLabelMetric(n,r,t,e.x,e.y));const o=e.clone(),c=e.angle*(180/Math.PI)%360,h=(e.angle*(180/Math.PI)+180)%360;this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||(this._placeFirst(o,s,1,c),this._placeBack(e,o,s,a,1,c),this._placeForward(e,o,s,a,1,c)),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||(this._placeFirst(o,s,0,h),this._placeBack(e,o,s,a,0,h),this._placeForward(e,o,s,a,0,h)),i.metricEnd()}_placeStraightAlong(e,s,a,r){const{out:t,id:i,shaping:n,zoomRange:o,referenceBounds:c}=this._current,{boxBorderLineColor:h,boxBackgroundColor:f}=this.evaluatedMeshParams,m=e.clone(),d=e.angle*(180/Math.PI)%360,p=(e.angle*(180/Math.PI)+180)%360,u=n.glyphs.length>0&&!(!h&&!f);if(t.metricStart(this._createLineLabelMetric(i,a,r,e.x,e.y)),u){const _=Math.max(s,o[0],0),g=Math.min(S,o[1]),y=Z(D(),-e.angle),v={minZoom:_,maxZoom:g,clipAngle:d,mapAligned:!0,isLineLabel:!0},x=M(this.evaluatedMeshParams.offsetX),I=M(this.evaluatedMeshParams.offsetY);if(!this._verticalPlacement||this._verticalPlacement===this._current.offsetDirection){const w=C(x,-1*I),[E,A]=n.shapeBackground(ae(D(),y,w));t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),this._writeTextBox(t,i,e.x,e.y,A,c,v),t.recordEnd()}if(!this._verticalPlacement||this._verticalPlacement!==this._current.offsetDirection){const w=C(x,I),[E,A]=n.shapeBackground(ae(D(),y,w));v.clipAngle=p,t.recordStart(this.instanceId,this.attributeLayout,n.glyphs[0].textureBinding),this._writeTextBox(t,i,e.x,e.y,A,c,v),t.recordEnd()}}this._verticalPlacement&&this._verticalPlacement!==this._current.offsetDirection||this._placeFirst(m,s,1,d,!0),this._verticalPlacement&&this._verticalPlacement===this._current.offsetDirection||this._placeFirst(m,s,0,p,!0),t.metricEnd()}_placeBack(e,s,a,r,t,i){const n=e.clone();let o=e.backwardLength+z;for(;n.prev()&&!(o>=r);)this._placeOnSegment(n,s,o,a,-1,t,i),o+=n.length+z}_placeForward(e,s,a,r,t,i){const n=e.clone();let o=e.remainingLength+z;for(;n.next()&&!(o>=r);)this._placeOnSegment(n,s,o,a,1,t,i),o+=n.length+z}_placeFirst(e,s,a,r,t=!1){const{out:i,id:n,shaping:o,zoomRange:c,referenceBounds:h}=this._current,f=o.glyphs,m=M(this.evaluatedMeshParams.offsetX),d=M(this.evaluatedMeshParams.offsetY),p=C(m,d),u=Z(D(),-e.angle);ne(p,p,u);for(const _ of f){const g=_.x>o.bounds.x?a:1-a,y=g*e.remainingLength+(1-g)*e.backwardLength,v=Math.abs(_.x+_.width/2-o.bounds.x),x=Math.max(0,this._zoomLevel+Math.log2(v/(y+z))),I=Math.max(s,t?0:x);if(_.maxZoom=Math.min(c[1],S),_.angle=e.angle+(1-a)*Math.PI,_.minZoom=Math.max(c[0],I),this._writeLineGlyph(i,n,e.x,e.y,_,r,h,!0),(a||this._current.offsetDirection)&&this._isVisible(_.minZoom,_.maxZoom)){const w=new he(_.bounds.x+p[0],_.bounds.y+p[1],_.bounds.width,_.bounds.height);i.metricBoxWrite(w)}}}_placeOnSegment(e,s,a,r,t,i,n){const{out:o,id:c,shaping:h,referenceBounds:f}=this._current,m=h.glyphs,d=e.dx/e.length,p=e.dy/e.length,u={x:e.x+a*-t*d,y:e.y+a*-t*p},_=M(this.evaluatedMeshParams.offsetX),g=M(this.evaluatedMeshParams.offsetY),y=C(_,g),v=Z(D(),-e.angle);ne(y,y,v);for(const x of m){const I=x.x>h.bounds.x?i:1-i;if(!(I&&t===1||!I&&t===-1))continue;const w=Math.abs(x.x+x.width/2-h.bounds.x),E=Math.max(0,this._zoomLevel+Math.log2(w/a)-.1),A=Math.max(r,this._zoomLevel+Math.log2(w/(a+e.length+z)));if(E!==0&&(x.angle=e.angle+(1-i)*Math.PI,x.minZoom=A,x.maxZoom=E,this._writeLineGlyph(o,c,u.x,u.y,x,n,f,!0),(i||this._current.offsetDirection)&&this._isVisible(x.minZoom,x.maxZoom))){const be=new he(x.bounds.x+y[0],x.bounds.y+y[1],x.bounds.width,x.bounds.height);o.metricBoxWrite(be)}}}_writeLineGlyph(e,s,a,r,t,i,n,o){if(a<0||a>R||r<0||r>R)return;e.recordStart(this.instanceId,this.attributeLayout,t.textureBinding);const{texcoords:c,offsets:h}=t,{fontSize:f,haloSize:m,outlineSize:d}=this._textMeshTransformProps;this._writeQuad(e,s,a,r,{texcoords:c,offsets:h,fontSize:f,haloSize:m,outlineSize:d,color:et(this.evaluatedMeshParams.color),isBackground:!1,referenceBounds:n,minZoom:Math.max(this._current.zoomRange[0],t.minZoom),maxZoom:Math.min(this._current.zoomRange[1],t.maxZoom),clipAngle:i,mapAligned:o,isLineLabel:!0}),e.recordEnd()}_packedZoom(e){return Math.floor(e*re)/re}_isVisible(e,s){let a=Math.max(this._current.zoomRange[0],e),r=Math.min(this._current.zoomRange[1],s);a=this._packedZoom(a),r=this._packedZoom(r);const t=this._packedZoom(this._zoomLevel);return a<=t&&t<=r}}function ue(l,e,s){const{coords:a,lengths:r}=e,t=L(),i=L(),n=L(),o=L(),c=L(),h=L(),f=2;let m=0;for(let d=0;d<r.length;d++){const p=r[d];for(let u=0;u<p;u++){const _=f*(u+m-1),g=f*(u+m),y=f*(u+m+1);u>0?b(t,a[_],a[_+1]):b(t,0,0),b(i,a[g],a[g+1]),u<p-1?b(n,a[y],a[y+1]):b(n,0,0),u===0?b(o,0,0):(oe(o,i,t),q(o,o),b(o,o[1],-o[0])),u===p-1?b(c,0,0):(oe(c,n,i),q(c,c),b(c,c[1],-c[0])),_t(h,o,c),q(h,h);const v=h[0]*c[0]+h[1]*c[1];v!==0&&ce(h,h,v),ce(h,h,s),l.coords.push(i[0]+h[0],i[1]+h[1])}l.lengths.push(p),m+=p}return l}class Ot extends Pt{constructor(e){super(),this._value=e}resize(e){}read(e,s){return this._value}readWithDefault(e,s,a){return this._value}hasArcadeDependency(e){return!1}}const Tt=()=>ze.getLogger("esri.views.2d.engine.webgl.shaderGraph.techniques.mesh.MeshWriterInputEvaluator");async function T(l,e,s,a){const{defaultValue:r,valueExpressionInfo:t,value:i}=e;if(t){if(t.type==="dictionary-template")return{...e,computed:l.createDictionaryTemplateField(t,s),defaultValue:r};const{expression:n}=t,o=await l.createComputedField({expression:n},a);return o?{...e,computed:o,defaultValue:r}:null}return{...e,computed:new Ot(i),defaultValue:r}}async function pe(l,e,s){const{valueExpressionInfo:a}=e,r=a.type==="dictionary-template"?l.createDictionaryTemplateField(a,s):await l.createComputedField({expression:a.expression});return r?{...e,computed:r}:null}function Me(l){return typeof l=="object"&&l!=null&&(!(!("valueExpressionInfo"in l)||!l.valueExpressionInfo)||"type"in l&&l.type==="Process"&&"op"in l&&l.op==="Random")}function $(l){if(Array.isArray(l)){for(const e of l)if($(e))return!0}if(typeof l=="object"){if(Me(l))return!0;for(const e in l)if($(l[e]))return!0}return!1}class se{static async create(e,s,a,r){const t={},i=new Map,n=new Map,o=new Map,c=new Map,h=new Map,f=new Map;for(const m in a){const d=a[m];if(d!=null&&typeof d=="object")if(Array.isArray(d)){if(typeof d[0]=="object")throw new Error(`InternalError: Cannot handle ${m}. Nested array params are not supported`);t[m]=d}else if("valueExpressionInfo"in d){if(d.value){t[m]=d.value;continue}const p=await pe(e,d,r);if(!p){t[m]=d.defaultValue;continue}i.set(m,p),t[m]=null}else switch(d.type){case"cim-effect-infos":if(d.effectInfos.some(p=>p.overrides.length)){n.set(m,{effects:await Promise.all(d.effectInfos.map(async p=>{const u=p.overrides.map(_=>T(e,_,r,!1));return{effect:p.effect,compiledOverrides:(await Promise.all(u)).filter(k)}}))});break}t[m]=d.effectInfos.map(p=>p.effect);break;case"cim-marker-placement-param":d.overrides.length&&o.set(m,{placementInfo:d,compiledOverrides:(await Promise.all(d.overrides.map(p=>T(e,p,r,!1)))).filter(k)}),t[m]=d.placement;break;case"text-rasterization-param":{if(d.overrides.length){const u=d.overrides.map(_=>T(e,_,r,d.useLegacyLabelEvaluationRules??!1));c.set(m,{compiledOverrides:(await Promise.all(u)).filter(k),rasterizationParam:d,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:d.resource};t[m]=await s.fetchResourceImmediate(p)??null;break}case"sprite-rasterization-param":{if(d.overrides.length){const u=d.overrides.map(_=>T(e,_,r,!1));c.set(m,{compiledOverrides:(await Promise.all(u)).filter(k),rasterizationParam:d,objectIdToResourceId:new Map});continue}if(d.resource.type==="animated"){c.set(m,{compiledOverrides:[],rasterizationParam:d,objectIdToResourceId:new Map});continue}const p={type:"cim-rasterization-info",resource:d.resource};t[m]=await s.fetchResourceImmediate(p)??null;break}case"cim-marker-transform-param":{const{params:p}=d;if($(p)){const u={compiledMarkerInfos:[]};await Promise.all(p.map(async _=>{const g={props:{}};for(const y in _)if(Me(_[y])){const v=await pe(e,_[y],r);g.compiledExpressionMap||(g.compiledExpressionMap=new Map);const x=g.compiledExpressionMap;v&&x.set(y,v)}else g.props[y]=_[y];u.compiledMarkerInfos.push(g)})),h.set(m,u)}else t[m]={type:"cim-marker-transform-info",infos:p};break}case"animation-params":{const{params:p}=d,u=tt(p);if($(u)){const _=await Promise.all(u.map(g=>st(g,e)));f.set(m,{params:_,propertyIdToResourceId:new Map,key:m})}else{const _=it(u),g=await s.fetchResourceImmediate({type:"animation-info",resource:_});g!=null&&g.type==="sprite"&&(t[m]={dataRow:g.rect.y,dataColumn:g.rect.x})}break}default:t[m]=d}else t[m]=d}return new se(a,t,i,n,o,c,h,f)}constructor(e,s,a,r,t,i,n,o){this.inputMeshParams=e,this._resolvedMeshParams=s,this._dynamicProperties=a,this._dynamicEffectProperties=r,this._dynamicPlacementProperties=t,this._dynamicAsyncProperties=i,this._dynamicTransformProperties=n,this._dynamicAsyncAnimations=o,this.evaluator=c=>c,this._arcadeDependencies=new Set;for(const c of this._expressions())xt(this._arcadeDependencies,c)}get hasDynamicProperties(){return!!(this._dynamicProperties.size||this._dynamicAsyncProperties.size||this._dynamicEffectProperties.size||this._dynamicTransformProperties.size||this._dynamicPlacementProperties.size||this._dynamicAsyncAnimations.size)}get evaluatedMeshParams(){return this._evaluatedMeshParams||(this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams)),this._evaluatedMeshParams}enqueueRequest(e,s,a){for(const r of this._dynamicAsyncProperties.values()){const t=we(r.rasterizationParam.resource);r.rasterizationParam.resource.type==="animated"&&r.rasterizationParam.resource.randomizeStartTime&&(t.primitiveName="__RESERVED__PRIMITIVE__NAME__",t.startGroup=rt(s.getObjectId()||0));for(const{primitiveName:n,propertyName:o,computed:c,defaultValue:h,valueExpressionInfo:f}of r.compiledOverrides)try{const m=r.rasterizationParam.resource.type==="animated"?t.primitiveName:n;yt(t,m,o,c,s,a,h)}catch(m){Tt().errorOnce(new Ie("invalid-arcade-expression","Encountered an error when evaluating the arcade expression",{error:m,valueExpressionInfo:f}))}const i=e.enqueueRequest({type:"cim-rasterization-info",resource:t});r.objectIdToResourceId.set(s.getObjectId(),i)}for(const r of this._dynamicAsyncAnimations.values()){const t=r.params.map(o=>at(o,s,a)).map(nt).map(o=>o.simplify()),i=ot(t),n=e.enqueueRequest({type:"animation-info",resource:i});r.propertyIdToResourceId.set(s.getObjectId()+"."+r.key,n)}}evaluateMeshParams(e,s,a){for(const[r,t]of this._dynamicProperties.entries())this._resolvedMeshParams[r]=t.computed.readWithDefault(s,a,t.defaultValue);for(const[r,t]of this._dynamicPlacementProperties.entries())for(const{computed:i,defaultValue:n,propertyName:o}of t.compiledOverrides){const c=i.readWithDefault(s,a,n);t.placementInfo.placement[o]=c,this._resolvedMeshParams[r]=t.placementInfo.placement}for(const[r,t]of this._dynamicEffectProperties.entries())for(const i of t.effects){for(const{computed:n,defaultValue:o,propertyName:c}of i.compiledOverrides){const h=n.readWithDefault(s,a,o);i.effect[c]=h}this._resolvedMeshParams[r]=t.effects.map(n=>n.effect)}for(const[r,t]of this._dynamicTransformProperties.entries()){const i={type:"cim-marker-transform-info",infos:[]};for(const n of t.compiledMarkerInfos){const o={...n.props};if(n.compiledExpressionMap)for(const[c,h]of n.compiledExpressionMap){const f=h.computed.readWithDefault(s,a,h.defaultValue);o[c]=typeof f=="number"||typeof f=="boolean"?f:h.defaultValue}i.infos.push(o)}this._resolvedMeshParams[r]=i}for(const[r,t]of this._dynamicAsyncProperties.entries()){const i=t.objectIdToResourceId.get(s.getObjectId());if(i==null)continue;const n=e.getResource(i);this._resolvedMeshParams[r]=n}for(const[r,t]of this._dynamicAsyncAnimations.entries()){const i=t.propertyIdToResourceId.get(s.getObjectId()+"."+r);if(i==null)continue;const n=e.getResource(i);this._resolvedMeshParams[r]={dataRow:n.rect.y,dataColumn:n.rect.x}}return this._evaluatedMeshParams=this.evaluator(this._resolvedMeshParams),this.evaluatedMeshParams}hasArcadeDependency(e){return this._arcadeDependencies.has(e)}*_expressions(){for(const e of this._dynamicProperties.values())yield e.computed;for(const e of this._dynamicEffectProperties.values())for(const s of e.effects)for(const a of s.compiledOverrides)yield a.computed;for(const e of this._dynamicPlacementProperties.values())for(const s of e.compiledOverrides)yield s.computed;for(const e of this._dynamicAsyncProperties.values())for(const s of e.compiledOverrides)yield s.computed;for(const e of this._dynamicTransformProperties.values())for(const s of e.compiledMarkerInfos)if(s.compiledExpressionMap!=null)for(const a of s.compiledExpressionMap.values())yield a.computed;for(const e of this._dynamicAsyncAnimations.values())for(const s of e.params)yield*ct(s)}}class rs{async createMeshWriter(e,s,a,r,t){const i=this._getMeshWriter(r.techniqueType),n=await se.create(e,s,r.inputParams,t),o=new i(r.id,n,r.optionalAttributes,a);return await o.loadDependencies(),o}_getMeshWriter(e){switch(e){case P.Fill:return je;case P.DotDensity:return Ge;case P.ComplexFill:return Ve;case P.PatternFill:return We;case P.GradientFill:return Fe;case P.OutlineFill:return $e;case P.PatternOutlineFill:return Te;case P.ComplexOutlineFill:return Oe;case P.Marker:return Ce;case P.PieChart:return Be;case P.Text:return fe;case P.Line:return Re;case P.TexturedLine:return ke;case P.GradientStroke:return Ee;case P.Heatmap:return Se;case P.Label:return Ct;case P.AnimatedMarker:return wt;case P.AnimatedMarkerShift:return It;case P.AnimatedFill:return Lt;case P.AnimatedLine:return At;default:throw new Error("Internal Error: Mesh writer not in the registry")}}}export{rs as O,Ot as v};
