const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./densifyOperator-BHu30UIi-B0l7RzcC.js","./index-BeTPrQ6f.js","./index-BlWAJbpo.css","./Point2D-BVUQyGsf-qih0ZuJV.js","./ProjectionTransformation-BXUROh_s-kKBZ5FDB.js","./Envelope2D-2iYexKQo-BCKocNS7.js","./Transformation2D-CZCvoz9N-B-IhcWnl.js","./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js","./OperatorDefinitions-DJdq_wrt-DP7_WWTp.js","./jsonConverter-CiKBkr5U-C590VlCu.js","./apiConverter-Djde5pBD-Dr3vspB4.js","./differenceOperator-DM4qBgat-D8Te2DyZ.js","./lengthOperator-BGZzaL7w-DRGNcDGP.js"])))=>i.map(i=>d[i]);
import{m as I,E as b,bR as Fe,bO as Pe,be as ge,R as De,n as oe,l as z,_ as Y,C as Be,e3 as Ie,P as ne,bx as K,B as F,aa as Ce,v as Re,Y as He,F as j,A as Je}from"./index-BeTPrQ6f.js";import{a as be}from"./OperationalLayer-Ds0FQSCg-DEUbTcjK.js";import{y as we,E as O,H as ze,I as ce,K as Se,n as Ee,Q as Ne,U as Oe,e as Me,i as We,G as Le,P as qe}from"./datasetUtils-CoevgV-1-DBvxeW7j.js";import{V as Ae,y as ue,l as Ge,T as $e,a as Ve,N as je,i as he,S as Ue,c as Qe,K as Ke,O as Ze,r as Ye,_ as Xe,F as me,b as et,L as de}from"./RasterJobHandlerMixin-UR-8PHpt-DPmd92HN.js";import{j as tt,l as it,x as nt,a as st,Q as rt}from"./RasterSymbolizer-BrZXkSNW-D-GxeREO.js";import{p as X,n as at}from"./TileInfo-BmHJ3kZT-BCenfvrA.js";import{QueueProcessor as ot}from"./QueueProcessor-Bne-Dlbg-BSQ_6P13.js";import{P as lt,Z as ct,Q as ut,U as ht,Y as mt}from"./RawBlockCache-BpKctfOs-CqPAG2bh.js";import{W as dt}from"./pixelRangeUtils-DcEknavd-BIL6Doop.js";import{q as ve,g as te,L as ft,K as pt,a as yt}from"./vectorFieldUtils-BL5wnf_H-VvdatiJz.js";import{B as se,W as re,s as Z,N as Q,i as fe,D as pe,$ as xt,H as ie,a as gt,K as It,I as Rt}from"./rasterProjectionHelper-DNfZ9Hwc-CptrPCWf.js";import{H as ae,B as bt}from"./clipUtils-BtWPrYe--B7EVDZv3.js";import{c as wt}from"./FeatureSet-BIUKCqNW-D9YRl-VE.js";import{W as St}from"./rasterFunctionHelper-BsM3I63S-BofSI0Pb.js";const ye=8,vt=256;let _t=0,v=class extends He{constructor(){super(...arguments),this._tileFetchQueue=new ot({concurrency:32,process:(t,i)=>this._fetchRawTile(t.pyramidLevel,t.row,t.col,{...t.options,signal:i})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(t){return t!=null&&t.ioConfig&&(t={...t,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:X.create(),...t.ioConfig}}),t}get _isGlobalWrappableSource(){const{rasterInfo:t}=this,i=Q(t.spatialReference);return i!=null&&t.extent.width>=i/2}get _hasNoneOrGCSShiftTransform(){const{transform:t}=this.rasterInfo;return t==null||t.type==="gcs-shift"}set rasterJobHandler(t){var i,s;this._set("rasterJobHandler",t),O(this)&&((s=(i=this.primaryRasters)==null?void 0:i.rasters)==null||s.forEach(r=>r.rasterJobHandler=t))}get rasterId(){return this.url||"rasterId-"+_t++}set url(t){this._set("url",Ie(t,ne.getLogger(this)))}async open(t){return this._openPromise??(this._openPromise=re().then(()=>this._open(t))),this._openPromise}async fetchTile(t,i,s,r={}){const e=r.tileInfo||this.rasterInfo.storageInfo.tileInfo,n=this.getTileExtentFromTileInfo(t,i,s,e);if(!n)throw new z("imagery-tile:out-of-bounds","Level for fetch tile out of range");return r={noClip:!0,...r},this.fetchPixels(n,e.size[0],e.size[1],r)}async identify(t,i={}){var E;t=K(F,t).clone().normalize();const{multidimensionalDefinition:s,timeExtent:r}=i,{rasterInfo:e}=this,{hasMultidimensionalTranspose:n,multidimensionalInfo:a}=e;let{transposedVariableName:o}=i;const l=a!=null&&n&&(r!=null||Se(s));l&&!o&&(o=s!=null&&s.length>0?s[0].variableName??void 0:a.variables[0].name,i={...i,transposedVariableName:o}),i=this._getRequestOptionsWithSliceId(i);const{spatialReference:c,extent:u}=e,{datumTransformation:m}=i;let h=fe(t,c,m);if(!u.intersects(h))return{location:h,value:null};if(e.transform!=null){const H=e.transform.inverseTransform(h);if(!e.nativeExtent.intersects(H))return{location:H,value:null};h=H}let p=0;const y=o!=null&&a!=null&&e.hasMultidimensionalTranspose;if(O(this)){const H=this.primaryRasters.rasters[0];if(y)return H.identify(h,i);const{pixelSize:N}=e,_=3,W=N.x*_/2,L=N.y*_/2,q=new j({xmin:h.x-W,xmax:h.x+W,ymin:h.y-L,ymax:h.y+L,spatialReference:c}),D={interpolation:"nearest",multidimensionalDefinition:s,sliceId:i.sliceId,bandIds:i.bandIds},{pixelBlock:T}=await H.fetchPixels(q,_,_,D),{pixelBlock:k}=await this.fetchPixels(q,_,_,D);if(T==null)return{location:h,value:null};const B=Math.floor(_*_*.5),A=!T.mask||T.mask[B]?T.pixels.map(C=>C[B]):null;let J;return k!=null&&(J=!k.mask||k.mask[B]?k.pixels.map(C=>C[B]):void 0),{location:h,value:A,processedValue:J,pyramidLevel:0}}if(!y){if(i.srcResolution)p=pe(i.srcResolution,e,this.ioConfig.sampling).pyramidLevel;else if(p=await this.computeBestPyramidLevelForLocation(t,i),p==null)return{location:h,value:null}}const g=this.identifyPixelLocation(h,p,null,y);if(g===null)return{location:h,value:null};const{row:f,col:d,rowOffset:x,colOffset:R,blockWidth:S}=g,w=await this._tileFetchQueue.push({pyramidLevel:p,row:f,col:d,options:i},{signal:i.signal});if(!((E=w==null?void 0:w.pixels)!=null&&E.length))return{location:h,value:null};const P=x*S+R;return this._processIdentifyResult(w,{srcLocation:h,position:P,pyramidLevel:p,useTransposedTile:!!y,requestSomeSlices:l,identifyOptions:i})}async fetchPixels(t,i,s,r={}){t=xt(t),r=this._getRequestOptionsWithSliceId(r);const{_hasNoneOrGCSShiftTransform:e}=this;if(r.requestRawData&&e)return this._fetchPixels(t,i,s,r);const n=Q(t.spatialReference),a=ie(t);if(n==null||a===0||a===1&&this._isGlobalWrappableSource&&e)return this._fetchPixels(t,i,s,r);if(a>=3)return{extent:t,pixelBlock:null};const o=[],{xmin:l,xmax:c}=t,u=Math.round(n/(c-l)*i),m=u-Math.round((n/2-l)/(c-l)*i);let h=0;const p=[];for(let d=0;d<=a;d++){const x=new j({xmin:d===0?l:-n/2,xmax:d===a?c-n*d:n/2,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference}),R=d===0?u-m:d===a?i-h:u;h+=R,p.push(R);const S=r.disableWrapAround&&d>0?null:this._fetchPixels(x,R,s,r);o.push(S)}const y=(await Promise.all(o)).map(d=>d==null?void 0:d.pixelBlock);let g=null;const f={width:i,height:s};return this.rasterJobHandler?g=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:y,srcMosaicSize:f,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:p},r)).pixelBlock:g=te(y,f,{blockWidths:p}),{extent:t,srcExtent:Z(t,this.rasterInfo.spatialReference,r.datumTransformation),pixelBlock:g}}async fetchRawPixels(t,i,s,r={}){i={x:Math.floor(i.x),y:Math.floor(i.y)};const e=await this._fetchRawTiles(t,i,s,r),{nativeExtent:n,nativePixelSize:a,storageInfo:o}=this.rasterInfo,l=2**t,c=a.x*l,u=a.y*l,m=new j({xmin:n.xmin+c*i.x,xmax:n.xmin+c*(i.x+s.width-1),ymin:n.ymax-u*(i.y+s.height-1),ymax:n.ymax-u*i.y,spatialReference:n.spatialReference});if(!e)return{extent:m,srcExtent:m,pixelBlock:null};const{pixelBlocks:h,mosaicSize:p}=e;if(h.length===1&&h[0]!=null&&h[0].width===s.width&&h[0].height===s.height)return{extent:m,srcExtent:m,pixelBlock:e.pixelBlocks[0]};const y=t>0?o.pyramidBlockWidth:o.blockWidth,g=t>0?o.pyramidBlockHeight:o.blockHeight,f={x:i.x%y,y:i.y%g};let d;return this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:h,srcMosaicSize:p,destDimension:s,clipOffset:f,clipSize:s,coefs:null,sampleSpacing:null,interpolation:r.interpolation,alignmentInfo:null,blockWidths:null},r)).pixelBlock:d=te(h,p,{clipOffset:f,clipSize:s}),{extent:m,srcExtent:m,pixelBlock:d}}fetchRawTile(t,i,s,r){throw new z("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(t){return Z(this.rasterInfo.extent,t)}decodePixelBlock(t,i){return!this.rasterJobHandler||i.useCanvas?st(t,i):this.rasterJobHandler.decode({data:t,options:i})}async request(t,i,s=0){const{customFetchParameters:r}=this.ioConfig,{range:e,query:n,headers:a}=i;s=s??i.retryCount??this.ioConfig.retryCount;const o=e?{Range:`bytes=${e.from}-${e.to}`}:null;try{return await Re(t,{...i,query:{...n,...r},headers:{...a,...o}})}catch(l){if(s>0)return s--,this.request(t,i,s);throw l}}getSliceIndex(t){const{multidimensionalInfo:i}=this.rasterInfo;return i==null||t==null||t.length===0?null:Me(t,i)}getTileExtentFromTileInfo(t,i,s,r){const e=r.lodAt(t);return e?this.getTileExtent({x:e.resolution,y:e.resolution},i,s,r.origin,r.spatialReference,r.size):null}updateTileInfo(){const{storageInfo:t,spatialReference:i,extent:s,pixelSize:r}=this.rasterInfo,{pyramidResolutions:e}=t;if(!t.tileInfo){const n=[],a=t.maximumPyramidLevel||0;let o=(r.x+r.y)/2,l=1/.0254*96*o;for(let u=0;u<=a&&(n.unshift(new at({level:a-u,resolution:o,scale:l})),u!==a);u++)if(e){const m=(e[u].x+e[u].y)/2;l*=m/o,o=m}else o*=2,l*=2;const c=new F({x:s.xmin,y:s.ymax,spatialReference:i});t.tileInfo=new X({origin:c,size:[t.blockWidth,t.blockHeight],spatialReference:i,lods:n}),t.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(t,i=512,s=512,r){const{width:e,height:n,nativeExtent:a,pixelSize:o,spatialReference:l}=t,c=new F({x:a.xmin,y:a.ymax,spatialReference:l});r==null&&(r=Math.max(0,Math.round(Math.log(Math.max(e,n))/Math.LN2-8)));const u=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[o],r);t.storageInfo=new rt({blockWidth:i,blockHeight:s,pyramidBlockWidth:i,pyramidBlockHeight:s,origin:c,firstPyramidLevel:1,maximumPyramidLevel:r,blockBoundary:u})}async computeBestPyramidLevelForLocation(t,i={}){return 0}computeBlockBoundary(t,i,s,r,e,n=0,a=2){if(e.length===1&&n>0){e=[...e];let{x:u,y:m}=e[0];for(let h=0;h<n;h++)u*=a,m*=a,e.push({x:u,y:m})}const o=[],{x:l,y:c}=r;for(let u=0;u<e.length;u++){const{x:m,y:h}=e[u];o.push({minCol:Math.floor((t.xmin-l+.1*m)/i/m),maxCol:Math.floor((t.xmax-l-.1*m)/i/m),minRow:Math.floor((c-t.ymax+.1*h)/s/h),maxRow:Math.floor((c-t.ymin-.1*h)/s/h)})}return o}getPyramidPixelSize(t){const{nativePixelSize:i}=this.rasterInfo,{pyramidResolutions:s,pyramidScalingFactor:r}=this.rasterInfo.storageInfo;if(t===0)return i;if(s!=null&&s.length)return s[t-1];const e=r**t;return{x:i.x*e,y:i.y*e}}identifyPixelLocation(t,i,s,r){const{spatialReference:e,nativeExtent:n,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:o,origin:l,transposeInfo:c}=a,u=r&&c!=null?c.tileSize[0]:a.blockWidth,m=r&&c!=null?c.tileSize[1]:a.blockHeight,h=fe(t,e,s);if(!n.intersects(h)||i<0||i>o)return null;const p=this.getPyramidPixelSize(i),{x:y,y:g}=p,f=(l.y-h.y)/g/m,d=(h.x-l.x)/y/u,x=Math.min(m-1,Math.floor((f-Math.floor(f))*m)),R=Math.min(u-1,Math.floor((d-Math.floor(d))*u));return{pyramidLevel:i,row:Math.floor(f),col:Math.floor(d),rowOffset:x,colOffset:R,blockWidth:u,srcLocation:h}}getTileExtent(t,i,s,r,e,n){const[a,o]=n,l=r.x+s*a*t.x,c=l+a*t.x,u=r.y-i*o*t.y,m=u-o*t.y;return new j({xmin:l,xmax:c,ymin:m,ymax:u,spatialReference:e})}getBlockWidthHeight(t){return{blockWidth:t>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:t>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(t,i,s){const r=this.rasterInfo.storageInfo.blockBoundary[t];return!r||r.maxRow<i||r.maxCol<s||r.minRow>i||r.minCol>s}updateImageSpaceRasterInfo(t){const{pixelSize:i}=t,{width:s,height:r}=t,e=ge.WebMercator;t.spatialReference=e,t.extent=t.nativeExtent=new j({xmin:-.5,ymax:.5,xmax:s-.5,ymin:.5-r,spatialReference:e}),t.isPseudoSpatialReference=!0,t.transform=null,t.pixelSize=new F({x:1,y:1,spatialReference:e});const{extent:n,storageInfo:a}=t;if(a){a.origin=new F({x:n.xmin,y:n.ymax,spatialReference:e});const{pyramidResolutions:o,tileInfo:l}=a;if(o&&o.forEach(c=>{c.x/=i.x,c.y/=i.y}),l){l.origin=a.origin;const c=(t.nativePixelSize.x+t.nativePixelSize.y)/2;l.lods.forEach((u,m)=>{u.resolution=c*2**m,u.scale=96*u.resolution/.0254})}}}async _fetchPixels(t,i,s,r={}){let e=ie(t);if(e>=2)return{extent:t,pixelBlock:null};const n=this._getSourceDataInfo(t,i,s,r),{pyramidLevel:a,srcResolution:o,srcExtent:l,srcWidth:c,srcHeight:u,ul:m}=n;if(c===0||u===0)return{extent:t,srcExtent:l,pixelBlock:null};const{rasterInfo:h}=this,p=h.transform,y=(p==null?void 0:p.type)==="gcs-shift",g=Q(t.spatialReference)!=null;!y&&g||(e=ie(n.srcExtent,y));const f=await this._fetchRawTiles(a,m,{width:c,height:u,wrapCount:e},r);if(!f)return{extent:t,srcExtent:l,pixelBlock:null};const d=h.storageInfo,x=a>0?d.pyramidBlockWidth:d.blockWidth,R=a>0?d.pyramidBlockHeight:d.blockHeight;let{x:S,y:w}=h.pixelSize;if(a>0){const{pyramidResolutions:M,pyramidScalingFactor:ke}=d;if(M!=null&&M[a-1])({x:S,y:w}=M[a-1]);else{const le=ke**a;S*=le,w*=le}}const P=h.spatialReference,E=new F({x:S,y:w,spatialReference:P}),H=x===c&&R===u&&m.x%x===0&&m.y%R===0,N=new F({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference}),_=!t.spatialReference.equals(P),W=P.isGeographic?1e-9:1e-4,{datumTransformation:L}=r;if(!_&&H&&f.pixelBlocks.length===1&&x===i&&R===s&&Tt(o,N,W))return{extent:t,srcExtent:l,srcTilePixelSize:E,pixelBlock:f.pixelBlocks[0]};const q=g&&Q(l.spatialReference)!=null&&this._hasNoneOrGCSShiftTransform,D=r.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");D&&!this.rasterJobHandler&&await re();const T=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:N.toJSON(),datumTransformation:L,rasterTransform:p,hasWrapAround:e>0||q,isAdaptive:this.ioConfig.optimizeProjectionAccuracy!==!1,includeGCSGrid:D},r):gt({projectedExtent:t,srcBufferExtent:f.extent,pixelSize:N,datumTransformation:L,rasterTransform:p,hasWrapAround:e>0||q,isAdaptive:!1,includeGCSGrid:D});let k;const B=!r.requestRawData,A={rows:T.spacing[0],cols:T.spacing[1]},J=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,f.extent.xmin):void 0,{pixelBlocks:C,mosaicSize:G,isPartiallyFilled:U}=f;let $=null;if(this.rasterJobHandler)({pixelBlock:k,localNorthDirections:$}=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:C,srcMosaicSize:G,destDimension:B?{width:i,height:s}:null,coefs:B?T.coefficients:null,sampleSpacing:B?A:null,projectDirections:D,gcsGrid:D?T.gcsGrid:null,isUV:this.rasterInfo.dataType==="vector-uv",interpolation:r.interpolation,alignmentInfo:J,blockWidths:null},r));else{const M=te(C,G,{alignmentInfo:J});k=B?ve(M,{width:i,height:s},T.coefficients,A,r.interpolation):M,D&&T.gcsGrid&&($=ft({width:i,height:s},T.gcsGrid),k=pt(k,this.rasterInfo.dataType,$))}return r.requestRawData||D?{extent:t,srcExtent:l,srcTilePixelSize:E,pixelBlock:k,transformGrid:T,localNorthDirections:$,isPartiallyFilled:U}:{extent:t,srcExtent:l,srcTilePixelSize:E,pixelBlock:k}}async _fetchRawTiles(t,i,s,r){const{origin:e,blockBoundary:n}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:o}=this.getBlockWidthHeight(t);let{x:l,y:c}=i,{width:u,height:m,wrapCount:h}=s;const p=this._getRasterTileAlignmentInfo(t,0);r.buffer&&(l-=r.buffer.cols,c-=r.buffer.rows,u+=2*r.buffer.cols,m+=2*r.buffer.rows);let y=0,g=0,f=0;h&&p!=null&&({worldColumnCountFromOrigin:g,originColumnOffset:f,rightPadding:y}=p,g*p.blockWidth-y>=l+u&&(y=0));const d=Math.floor(l/a),x=Math.floor(c/o),R=Math.floor((l+u+y-1)/a),S=Math.floor((c+m+y-1)/o),w=n[t];if(!w)return null;const{minRow:P,minCol:E,maxCol:H,maxRow:N}=w;if(h===0&&(S<P||R<E||x>N||d>H))return null;const _=new Array;let W=!1;const L=this.ioConfig.allowPartialFill==null?r.allowPartialFill:this.ioConfig.allowPartialFill;for(let J=x;J<=S;J++)for(let C=d;C<=R;C++){let G=C;if(!r.disableWrapAround&&h&&p!=null&&g<=C&&(G=C-g-f),J>=P&&G>=E&&N>=J&&H>=G){const U=this._tileFetchQueue.push({pyramidLevel:t,row:J,col:G,options:r},{signal:r.signal});L?_.push(new Promise($=>{U.then(M=>$(M)).catch(()=>{W=!0,$(null)})})):_.push(U)}else _.push(Promise.resolve(null))}if(_.length===0)return null;const q=await Promise.all(_),D={height:(S-x+1)*o,width:(R-d+1)*a},{spatialReference:T}=this.rasterInfo,k=this.getPyramidPixelSize(t),{x:B,y:A}=k;return{extent:new j({xmin:e.x+d*a*B,xmax:e.x+(R+1)*a*B,ymin:e.y-(S+1)*o*A,ymax:e.y-x*o*A,spatialReference:T}),pixelBlocks:q,mosaicSize:D,isPartiallyFilled:W}}_fetchRawTile(t,i,s,r){const{storageInfo:e}=this.rasterInfo,n=e.transposeInfo!=null&&!!r.transposedVariableName;if(!n){const m=e.blockBoundary[t];if(!m)return Promise.resolve(null);const{minRow:h,minCol:p,maxCol:y,maxRow:g}=m;if(i<h||s<p||i>g||s>y)return Promise.resolve(null)}const a=n?r.transposeVariableName:r.sliceId,o=this.rasterInfo.storageInfo.isBsqTile?r.bandIds:null,l=lt(this.rasterId,a,o),c=`${t}/${i}/${s}`;let u=ct(l,r.registryId,c);if(u==null){const m=new AbortController;u=this.fetchRawTile(t,i,s,{...r,signal:m.signal}),ut(l,r.registryId,c,u,m),u.catch(()=>ht(l,r.registryId,c))}return r.signal&&Je(r,()=>{mt(l,r.registryId,c)}),u}_computeMagDirValues(t){var l;const{bandCount:i,dataType:s}=this.rasterInfo;if(!(i===2&&s==="vector-magdir"||s==="vector-uv")||(t==null?void 0:t.length)!==2||!((l=t[0])!=null&&l.length))return null;const r=t[0].length;if(s==="vector-magdir"){const c=t[1].map(u=>(u+360)%360);return[t[0],c]}const[e,n]=t,a=[],o=[];for(let c=0;c<r;c++){const[u,m]=yt([e[c],n[c]]);a.push(u),o.push(m)}return[a,o]}_getRasterTileAlignmentInfo(t,i){return this._rasterTileAlignmentInfo==null&&(this._rasterTileAlignmentInfo=It(this.rasterInfo)),this._rasterTileAlignmentInfo.pyramidsInfo==null?null:{startX:i,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[t]}}_getSourceDataInfo(t,i,s,r={}){const e={datumTransformation:r.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};r.srcResolution&&(e.srcResolution=r.srcResolution,this._updateSourceDataInfo(t,e));const n=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:o,pyramidLevel:l}=e,c=a/i,u=o/s,m=l<n&&c*u>=16,h=l===n&&this._requireTooManySrcTiles(a,o,i,s);if(m||h||a===0||o===0){const p=new F({x:(t.xmax-t.xmin)/i,y:(t.ymax-t.ymin)/s,spatialReference:t.spatialReference});let y=Rt(p,this.rasterInfo.spatialReference,t,e.datumTransformation);const g=!y||r.srcResolution&&y.x+y.y<r.srcResolution.x+r.srcResolution.y;if(m&&r.srcResolution&&g){const f=Math.round(Math.log(Math.max(c,u))/Math.LN2)-1;if(n-l+3>=f){const d=2**f;y={x:r.srcResolution.x*d,y:r.srcResolution.y*d}}}y&&(e.srcResolution=y,this._updateSourceDataInfo(t,e))}return this._requireTooManySrcTiles(e.srcWidth,e.srcHeight,i,s)&&(e.srcWidth=0,e.srcHeight=0),e}_requireTooManySrcTiles(t,i,s,r){const{tileInfo:e}=this.rasterInfo.storageInfo,n=Math.ceil(t/e.size[0])*Math.ceil(i/e.size[1]),a=t/s,o=i/r,l=Math.max(1,(s+r)/1024);return n>=vt*l||a>ye||o>ye}_updateSourceDataInfo(t,i){i.srcWidth=0,i.srcHeight=0;const{rasterInfo:s}=this,r=s.spatialReference,{srcResolution:e,datumTransformation:n}=i,{pyramidLevel:a,pyramidResolution:o,excessiveReading:l}=pe(e,s,this.ioConfig.sampling);if(l)return;let c=i.srcExtent||Z(t,r,n);if(c==null)return;const u=s.transform;u&&(c=u.inverseTransform(c)),i.srcExtent=c;const{origin:m}=s.storageInfo,{width:h,height:p,ul:y}=We(c,m,o,a);i.pyramidLevel=a,i.pyramidResolution=o,i.srcWidth=h,i.srcHeight=p,i.ul=y}_getRequestOptionsWithSliceId(t){return this.rasterInfo.multidimensionalInfo!=null&&t.sliceId==null&&(t={...t,sliceId:this.getSliceIndex(t.multidimensionalDefinition)}),t}_processIdentifyResult(t,i){const{srcLocation:s,position:r,pyramidLevel:e,useTransposedTile:n}=i,a=t.pixels[0].length/t.width/t.height;if(!(!t.mask||t.mask[r]))return{location:s,value:null};const{multidimensionalInfo:o}=this.rasterInfo;if(o==null||!n){const f=t.pixels.map(R=>R[r]),d={location:s,value:f,pyramidLevel:e},x=this._computeMagDirValues(f.map(R=>[R]));return x!=null&&x.length&&(d.magdirValue=x.map(R=>R[0])),d}let l=t.pixels.map(f=>f.slice(r*a,r*a+a)),c=this._computeMagDirValues(l);const{requestSomeSlices:u,identifyOptions:m}=i;let h=Le(o,m.transposedVariableName);if(u){const f=qe(h,m.multidimensionalDefinition,m.timeExtent);l=l.map(d=>f.map(x=>d[x])),c=c==null?void 0:c.map(d=>f.map(x=>d[x])),h=f.map(d=>h[d])}const p=t.noDataValues||this.rasterInfo.noDataValue,y={pixels:l,pixelType:t.pixelType};let g;return p!=null&&(dt(y,p),g=y.mask),{location:s,value:null,dataSeries:h.map((f,d)=>{const x={value:(g==null?void 0:g[d])===0?null:l.map(R=>R[d]),multidimensionalDefinition:f.multidimensionalDefinition.map(R=>new we({...R,isSlice:!0}))};return c!=null&&c.length&&(x.magdirValue=[c[0][d],c[1][d]]),x}),pyramidLevel:e}}};function Tt(t,i,s){return Math.abs(t.x-i.x)<s&&Math.abs(t.y-i.y)<s}I([b()],v.prototype,"_rasterTileAlignmentInfo",void 0),I([b()],v.prototype,"_tileFetchQueue",void 0),I([b({readOnly:!0})],v.prototype,"_isGlobalWrappableSource",null),I([b({readOnly:!0})],v.prototype,"_hasNoneOrGCSShiftTransform",null),I([b()],v.prototype,"_openPromise",void 0),I([b()],v.prototype,"rasterJobHandler",null),I([b({readOnly:!0})],v.prototype,"rasterId",null),I([b(be)],v.prototype,"url",null),I([b({type:String,json:{write:!0}})],v.prototype,"datasetName",void 0),I([b({type:String,json:{write:!0}})],v.prototype,"datasetFormat",void 0),I([b()],v.prototype,"hasUniqueSourceStorageInfo",void 0),I([b()],v.prototype,"rasterInfo",void 0),I([b()],v.prototype,"ioConfig",void 0),I([b()],v.prototype,"sourceJSON",void 0),v=I([oe("esri.layers.support.rasterDatasets.BaseRaster")],v);const kt=40;let V=class extends v{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(t,i,s,r={}){var R,S;const{rasters:e,rasterIds:n}=this.primaryRasters;let a=!1;const{interpolation:o}=r,l=(R=this.rasterFunction.flatWebGLFunctionChain)==null?void 0:R.hasFocalFunction;!r.requestRawData&&l&&(a=e.length===1&&!r.skipRasterFunction,r={...r,interpolation:"bilinear",requestRawData:a}),r.requestRawData&&e.length>1&&!this.hasUniqueSourceStorageInfo&&(a=!1,r={...r,requestRawData:!1});const c=e.map(w=>w.fetchPixels(t,i,s,r)),u=await Promise.all(c),m=u.map(w=>w.pixelBlock),h=a||r.requestRawData?u.map(w=>w.srcTilePixelSize):null;if(r.skipRasterFunction||m.every(w=>w==null))return u[0];const p=((S=u.find(w=>w.pixelBlock!=null))==null?void 0:S.extent)??t;let y=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:n}):this.rasterFunction.process({extent:p,primaryPixelBlocks:m,primaryPixelSizes:h,primaryRasterIds:n});const{transformGrid:g}=u[0];if(!a||y==null||g==null){const w=r.noClip?null:this.getClippingGeometry(p.spatialReference);return!r.noClip&&y!=null&&w&&(y=await ae(y,p,w)),{...u[0],pixelBlock:y}}const f={rows:g.spacing[0],cols:g.spacing[1]};let d;this.rasterJobHandler?d=(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[y],srcMosaicSize:{width:y.width,height:y.height},destDimension:{width:i,height:s},coefs:g.coefficients,sampleSpacing:f,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:o,alignmentInfo:void 0,blockWidths:null},r)).pixelBlock:d=ve(y,{width:i,height:s},g.coefficients,f,o);const x=r.noClip?null:this.getClippingGeometry(t.spatialReference);return r.noClip||d==null||x==null||(d=await ae(d,t,x)),{extent:t,srcExtent:u[0].srcExtent,pixelBlock:d}}getClippingGeometry(t){const i=this._clippingGeometry.get("0");if(!t||!i)return i;const s=Pt(t);let r=this._clippingGeometry.get(s);return r!=null||(r=t.equals(i.spatialReference)?i:se(i,t),this._clippingGeometry.set(s,r)),r}async _open(t){var c,u,m,h;const{rasterFunction:i}=this;i.isRoot=!0,(u=(c=this.primaryRasters)==null?void 0:c.rasters)!=null&&u.length?i.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=i.getPrimaryRasters(),this.rasterJobHandler&&((m=this.primaryRasters.rasters)==null||m.forEach(p=>p.rasterJobHandler=this.rasterJobHandler)));const{rasters:s,rasterIds:r}=this.primaryRasters,e=s.map(p=>p.rasterInfo?void 0:p.open(t));await Promise.all(e);const n=s.map(({rasterInfo:p})=>p),a=i.bind({rasterInfos:n,rasterIds:r});if(i.rawSourceRasterInfos=n,!a.success||n.length===0)throw new z("raster-function:open",`cannot bind the function: ${a.error??""}`);const o=i.functionName==="Table"?i:(h=i.functionArguments)==null?void 0:h.raster;(o==null?void 0:o.functionName)==="Table"&&(i.rasterInfo.attributeTable=wt.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const l=n[0];this.hasUniqueSourceStorageInfo=n.length===1||n.slice(1).every(p=>Ft(p,l)),this.set("sourceJSON",s[0].sourceJSON),this.set("rasterInfo",i.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){var t;return(t=this.rasterJobHandler)==null?void 0:t.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const t=this.rasterFunction.getClippingGeometries()[0];let i=t==null?void 0:t.clippingGeometry;if(i&&t.clippingType==="inside"){const{extent:s}=this.rasterInfo,r=await Y(()=>import("./densifyOperator-BHu30UIi-B0l7RzcC.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url).then(a=>a.d),e=await Y(()=>import("./differenceOperator-DM4qBgat-D8Te2DyZ.js"),__vite__mapDeps([11,3,4,5,6,7,1,2,8,9,10]),import.meta.url).then(a=>a.d);let n=r.execute(Be.fromExtent(s),2*(s.width+s.height)/kt);n=se(n,i.spatialReference),i=e.execute(n,i)}this._clippingGeometry.clear(),i&&this._clippingGeometry.set("0",i)}};function Ft(t,i){const{storageInfo:s,pixelSize:r,spatialReference:e,extent:n}=t,{storageInfo:a,pixelSize:o,spatialReference:l,extent:c}=i;return r.x===o.x&&r.y===o.y&&e.equals(l)&&n.equals(c)&&s.blockHeight===a.blockHeight&&s.blockWidth===a.blockWidth&&s.maximumPyramidLevel===a.maximumPyramidLevel&&s.firstPyramidLevel===a.firstPyramidLevel&&s.pyramidBlockWidth===a.pyramidBlockWidth&&s.pyramidBlockHeight===a.pyramidBlockHeight&&s.pyramidScalingFactor===a.pyramidScalingFactor}function Pt(t){return String(t.wkid??t.wkt??t.wkt2)}I([b({type:String,json:{write:!0}})],V.prototype,"datasetFormat",void 0),I([b()],V.prototype,"tileType",void 0),I([b()],V.prototype,"rasterFunction",void 0),I([b()],V.prototype,"primaryRasters",void 0),V=I([oe("esri.layers.support.rasterDatasets.FunctionRaster")],V);const xe=1e3,$t=t=>{const i=t;let s=class extends i{constructor(...e){var n;super(...e),this._isConstructedFromFunctionRaster=!1,this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster=O((n=e[0])==null?void 0:n.raster)}destroy(){this._shutdownJobHandler()}get fullExtent(){var e;return(e=this.serviceRasterInfo)==null?void 0:e.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){var n;((n=e==null?void 0:e.functionName)==null?void 0:n.toLowerCase())==="none"&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",Ie(e,ne.getLogger(this)))}get renderer(){var a;if(this.type!=="imagery-tile")return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:n}=this;return e?(a=n==null?void 0:n.find(({name:o})=>o===e))==null?void 0:a.renderer.clone():this.internalRenderer}set renderer(e){this.type==="imagery-tile"&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){e==null&&this.rasterFunction==null?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,n,a){var l,c;const o=(c=(l=n==null?void 0:n.layerDefinition)==null?void 0:l.drawingInfo)==null?void 0:c.renderer;return Ve(o,a)||void 0}async computeStatisticsHistograms(e,n){await this.load(n),e=K(je,e).clone();const{serviceRasterInfo:a}=this;if(a==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:o}=e;if(o==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let l=o;const{spatialReference:c}=a;if(!o.spatialReference.equals(c)){await re();const d=o.type==="extent"?Z(o,c):se(o,c);if(d==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","geometry cannot be projected to the data source");l=d}const u=e.pixelSize??new F({x:a.pixelSize.x,y:a.pixelSize.y,spatialReference:c}),{extent:m,width:h,height:p}=bt(a,l,u),y=await this.fetchPixels(m,h,p,{...n,interpolation:"nearest"});if(y.pixelBlock==null)throw new z("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const g=await ae(y.pixelBlock,m,l),f=this._rasterJobHandler;return f?f.computeStatisticsHistograms({pixelBlock:g},n):it(g)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:n}=this.serviceRasterInfo??{};if(n==null)return e;const a=ze({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:a,timeExtent:void 0}}async updateRasterFunction(){var e;return this.loaded&&this.type==="imagery-tile"&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=(e=this.rasterFunction)==null?void 0:e.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:n,renderer:a}=this;if(!e||!n||!a)return;const{rasterInfo:o}=this.raster,l=ce(o,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),c=l==null?void 0:l.name,u=he(o,c);return this._updateSymbolizer(n,a,c,u)}async applyRenderer(e,n,a){const o=e==null?void 0:e.pixelBlock;if(!(o!=null&&o.pixels&&o.pixels.length>0))return null;await this.updateRenderer();const l=this.bandIds??[],{pixelBlock:c}=await this._symbolize({pixelData:e,simpleStretchParams:n,bandIds:l,symbolizer:this.symbolizer},a);return c}getRawDisplayBandIds(){let{bandIds:e,raster:n}=this;if(this.rasterFunction&&O(n)){const a=n.rasterFunction.rawInputBandIds;e=e!=null&&e.length&&(a!=null&&a.length)&&n.rasterInfo.bandCount!==1?e.map(o=>a[Math.min(o,a.length-1)]):a}return e&&e.length>3&&e.every((a,o)=>a===o)?null:e}getTileUrl(e,n,a){return this.raster.datasetFormat==="RasterTileServer"?`${this.url}/tile/${e}/${n}/${a}`:""}getCompatibleTileInfo(e,n,a=!1){if(!this.loaded||n==null)return null;if(a&&e.equals(this.spatialReference))return this.tileInfo;const o=Ce(e);return X.create({size:256,spatialReference:e,origin:o?{x:o.origin[0],y:o.origin[1]}:{x:n.xmin,y:n.ymax}})}getCompatibleFullExtent(e){var n;return this.loaded?((n=this._compatibleFullExtent)!=null&&n.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,n,a,o={}){var c;if(r(this),o.requestAsImageElement){const u=this.getTileUrl(e,n,a);return Re(u,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:o.signal}).then(m=>m.data)}const{serviceRasterInfo:l}=this;if(l.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null){const u=o.tileInfo||l.storageInfo.tileInfo,m=this.raster.getTileExtentFromTileInfo(e,n,a,u);if(m)return{extent:m,pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),((c=this.renderer)==null?void 0:c.type)==="raster-shaded-relief"&&(o={...o,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,n,a,o)}async fetchPixels(e,n,a,o={}){var c,u;if(this.serviceRasterInfo.multidimensionalInfo!=null&&(o=this.normalizeRasterFetchOptions(o)).multidimensionalDefinition==null)return{extent:e,pixelBlock:null};await this._initJobHandler(),await this.updateRasterFunction(),n=Math.round(n),a=Math.round(a);const l=await this.raster.fetchPixels(e,n,a,o);return(c=o.bandIds)!=null&&c.length&&!this.raster.rasterInfo.storageInfo.isBsqTile&&(l.pixelBlock=(u=l.pixelBlock)==null?void 0:u.extractBands(o.bandIds)),l}async getSamples(e,n){var u;if(await this.load(),(e=K(Ue,e).clone()).interpolation&&e.interpolation!=="nearest")throw new z("imagery-tile-mixin:get-samples","only nearest interpolation is currently supported");const a=(u=e.mosaicRule)==null?void 0:u.multidimensionalDefinition,o={...n,multidimensionalDefinition:a},l=(await this._getSampleLocations(e)).map(m=>this.identify(m,o).then(h=>(h.location=m,h))),c=(await Promise.all(l)).flatMap((m,h)=>this._convertRasterIdentifyResultToSample(m,h));return new Qe({samples:c})}async identify(e,n={}){var u,m;await this.load(),e=K(F,e).clone().normalize();const{raster:a,serviceRasterInfo:o}=this;if((o==null?void 0:o.multidimensionalInfo)!=null&&!(o.hasMultidimensionalTranspose&&!(!Se(n.multidimensionalDefinition)&&!n.transposedVariableName))&&(n=this.normalizeRasterFetchOptions(n)).multidimensionalDefinition==null)return{location:e,value:null};const l=(u=this.multidimensionalSubset)==null?void 0:u.areaOfInterest;if(l&&!l.contains(e))throw new z("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");let c;if((m=this.serviceRasterInfo)!=null&&m.storageInfo.isBsqTile){const h=O(a)?this.getRawDisplayBandIds():this.bandIds;c=h!=null&&h.length?h:void 0}return a.identify(e,{...n,bandIds:c})}hasStandardTime(){var o,l,c;const e=(o=this.serviceRasterInfo)==null?void 0:o.multidimensionalInfo;if(e==null||((l=this.serviceRasterInfo)==null?void 0:l.dataType)!=="standard-time")return!1;const n=this.multidimensionalDefinition,a=(c=n==null?void 0:n[0])==null?void 0:c.variableName;return e.variables.some(u=>u.name===a&&(!(n!=null&&n[0].dimensionName)||u.dimensions.some(m=>m.name==="StdTime")))}getStandardTimeValue(e){return new Date(Ee(e)).toISOString()}getMultidimensionalSubsetVariables(e){var a;const n=e??((a=this.serviceRasterInfo)==null?void 0:a.multidimensionalInfo);return Ne(this.multidimensionalSubset,n)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=Oe(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&O(this.raster)&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}async _initJobHandler(){if(!this._rasterJobHandler)return super._initJobHandler().then(async()=>{if(!this._rasterJobHandler)return;r(this);const{raster:e}=this;e.rasterJobHandler=this._rasterJobHandler,O(e)&&e.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch(()=>{}),this.renderer&&this.updateRenderer()}).catch(()=>{})}_shutdownJobHandler(){super._shutdownJobHandler(),this.raster&&(this.raster.rasterJobHandler=null)}async _getSampleLocations(e){const{geometry:n}=e;if(n.type==="point")return[n];const{spatialReference:a,type:o}=n;if(o==="multipoint")return n.points.map(d=>new F({x:d[0],y:d[1],spatialReference:a}));if(o==="polyline"){let d=n;if(e.sampleCount||e.sampleDistance){const x=await Y(()=>import("./densifyOperator-BHu30UIi-B0l7RzcC.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10]),import.meta.url).then(P=>P.d),R=(await Y(()=>import("./lengthOperator-BGZzaL7w-DRGNcDGP.js"),__vite__mapDeps([12,1,2,3,5,4,6,7,8,9,10]),import.meta.url).then(P=>P.l)).execute(n,{unit:"meters"}),S=Math.min(e.sampleCount||100,xe);let w=e.sampleDistance;w||(w=R/(S+(d.paths[0].length===2?1:0))),d=x.execute(n,w,{unit:"meters"})}return d.paths.flatMap(x=>x.map(R=>new F({x:R[0],y:R[1],spatialReference:a})))}const l=Math.min(e.sampleCount||100,xe),c=n.type==="extent",u=c?n:n.extent,m=Math.sqrt(u.width*u.height/l),h=u.height/m,p=u.width/m,{xmin:y,ymax:g}=u,f=[];for(let d=0;d<h;d++)for(let x=0;x<p;x++){const R=new F({x:y+(x+.5)*m,y:g-(d+.5)*m,spatialReference:a});(c||n.contains(R))&&f.push(R)}return f}_configDefaultInterpolation(){var e;if(this.interpolation==null){r(this);const{raster:n}=this,a=Ke(n.rasterInfo,n.tileType,(e=this.sourceJSON)==null?void 0:e.defaultResamplingMethod);this._set("interpolation",a)}}_configDefaultRenderer(e="no"){var h,p,y;r(this);const{rasterInfo:n}=this.raster,a=ce(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),o=a==null?void 0:a.name,l=Ze({variableName:o,rasterFunctionName:(h=this.rasterFunction)==null?void 0:h.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&n.bandCount>1&&(this.bandIds=(l==null?void 0:l.bandIds)??Ye(n)),!this.renderer||e==="override"){const g=Xe(this.raster),f=(l==null?void 0:l.renderer)??me(n,{bandIds:this.bandIds,variableName:o,rasterFunctionColorRamp:g}),d=n.statistics,x=d&&d.length>0?d[0]:null,R=(x==null?void 0:x.max)??0,S=(x==null?void 0:x.min)??0;this.raster.datasetFormat==="WCSServer"&&f.type==="raster-stretch"&&(R>1e24||S<-1e24)&&(f.dynamicRangeAdjustment=!0,f.customStatistics=null,f.stretchType==="none"&&(f.stretchType="min-max")),this.renderer=f}const c=et({...this.renderer.toJSON(),variableName:o}),u=he(n,o);this.symbolizer?(this.symbolizer.rendererJSON=c,this.symbolizer.rasterInfo=u):this.symbolizer=new nt({rendererJSON:c,rasterInfo:u});const m=this.symbolizer.bind();if(m.success){if(e==="auto"){const{colormap:g}=this.raster.rasterInfo,f=this.renderer;if(g!=null&&f.type==="raster-colormap"){const d=me(this.raster.rasterInfo);JSON.stringify(d)!==JSON.stringify(f)&&this._configDefaultRenderer("override")}else if(f.type==="raster-stretch"){const d=(p=this.bandIds)==null?void 0:p.length,x=(y=f.customStatistics)==null?void 0:y.length;!f.dynamicRangeAdjustment&&x&&d&&x!==d&&this._configDefaultRenderer("override")}}}else ne.getLogger(this).warn("imagery-tile-mixin",m.error||"The given renderer is not supported by the layer."),e==="auto"&&this._configDefaultRenderer("override")}async _updateRasterFunction(){var m;if(this._isConstructedFromFunctionRaster&&O(this.raster)){const h=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&h&&this._set("rasterFunction",ue.fromJSON(h)))}let e,n=this.raster,a=!1;O(n)?(e=n.primaryRasters.rasters,n=e[0],a=!0):e=[n];const{rasterFunction:o}=this;if(o){const h={raster:n};e.length>1&&e.forEach(g=>h[g.url]=g);const p=St(((m=o.functionDefinition)==null?void 0:m.toJSON())??o.toJSON(),h),y=new V({rasterFunction:p});y.rasterJobHandler=this._rasterJobHandler,await y.open(),this.raster=y}else this.raster=n,await n.open();if(this._cachedRendererJson=void 0,!a&&!o)return;const{bandIds:l}=this,{bandCount:c}=this.raster.rasterInfo,u=l!=null&&l.length?l.some(h=>h>=c):c>=3;l&&(u||this.renderer&&this.renderer.type!=="raster-stretch")&&this._set("bandIds",null),this._configDefaultRenderer("auto")}_convertRasterIdentifyResultToSample(e,n){var u;const{rasterInfo:a}=this.raster,o=a.storageInfo.pyramidScalingFactor**(e.pyramidLevel??0),l=(a.pixelSize.x+a.pixelSize.y)/2*o;if(!((u=e.dataSeries)!=null&&u.length))return[new de({location:e.location,pixelValue:e.value,locationId:n,resolution:l})];const c=[];return e.dataSeries.forEach(({value:m,multidimensionalDefinition:h},p)=>{const y={Variables:h[0].variableName,Dimensions:h.flatMap(({dimensionName:f})=>f).join(",")};for(const{dimensionName:f,values:d}of h){y[f]=Array.isArray(d[0])?d[0][0]:d[0];const x=d[d.length-1];y[`${f}_Max`]=Array.isArray(x)?x[x.length-1]:x}const g=new de({location:e.location,pixelValue:m,rasterId:p,locationId:n,resolution:l,attributes:y});c.push(g)}),c}};function r(e){if(!e.raster||!e.serviceRasterInfo)throw new z("imagery-tile","no raster")}return I([b({clonable:!1})],s.prototype,"_cachedRasterFunctionJson",void 0),I([b({clonable:!1})],s.prototype,"_compatibleFullExtent",void 0),I([b({clonable:!1})],s.prototype,"_isConstructedFromFunctionRaster",void 0),I([b({clonable:!1})],s.prototype,"_rasterFunctionUpdatePromise",void 0),I([b({type:[Fe],json:{write:{overridePolicy(){var e;return{enabled:!this.loaded||this.raster.tileType==="Raster"||((e=this.bandIds)==null?void 0:e.join(","))!=="0,1,2"}}}}})],s.prototype,"bandIds",void 0),I([b({json:{origins:{service:{read:{source:"copyrightText"}}}}})],s.prototype,"copyright",void 0),I([b({json:{read:!1}})],s.prototype,"fullExtent",null),I([b({json:{write:{overridePolicy(){return{enabled:!this.loaded||this.raster.tileType==="Raster"||this.interpolation!=="bilinear"}}}}}),Pe(tt)],s.prototype,"interpolation",void 0),I([b()],s.prototype,"ioConfig",void 0),I([b({type:[we],json:{write:!0}})],s.prototype,"multidimensionalDefinition",null),I([b({type:Ae,json:{write:!0}})],s.prototype,"multidimensionalSubset",void 0),I([b()],s.prototype,"raster",void 0),I([b({type:ue})],s.prototype,"rasterFunction",null),I([b()],s.prototype,"serviceRasterInfo",void 0),I([b()],s.prototype,"sourceJSON",void 0),I([b({readOnly:!0,type:ge,json:{read:!1}})],s.prototype,"spatialReference",void 0),I([b({type:X})],s.prototype,"tileInfo",void 0),I([b(be)],s.prototype,"url",null),I([b()],s.prototype,"renderer",null),I([b({types:$e,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){var n;const e=((n=this.renderer)==null?void 0:n.type)==="raster-stretch"&&this.renderer.stretchType==="none"&&!this.renderer.useGamma;return{enabled:!this.loaded||this.raster.tileType==="Raster"||!e}}},origins:{"web-scene":{types:Ge,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&e.type!=="vector-field"})}}}}})],s.prototype,"internalRenderer",null),I([De("internalRenderer")],s.prototype,"readRenderer",null),I([b({clonable:!1})],s.prototype,"symbolizer",void 0),s=I([oe("esri.layers.mixins.ImageryTileMixin")],s),s};function ee(t,i){if(!t||!i)return[];let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const r=[];if(i){const n=ee(t,s);for(let a=0;a<n.length;a++)ee(n[a],i).forEach(o=>r.push(o));return r}const e=t.getElementsByTagNameNS("*",s);if(!e||e.length===0)return[];for(let n=0;n<e.length;n++)r.push(e[n]||e.item(n));return r}function _e(t,i){if(!t||!i)return null;let s=i;i.includes("/")?(s=i.slice(0,i.indexOf("/")),i=i.slice(i.indexOf("/")+1)):i="";const r=ee(t,s);return r.length>0?i?_e(r[0],i):r[0]:null}function Te(t,i=null){const s=i?_e(t,i):t;let r;return s?(r=s.textContent||s.nodeValue,r?r.trim():null):null}function Dt(t,i){const s=ee(t,i),r=[];let e;for(let n=0;n<s.length;n++)e=s[n].textContent||s[n].nodeValue,e&&(e=e.trim(),e!==""&&r.push(e));return r}function Vt(t,i=null){var s;return((s=Te(t,i))==null?void 0:s.split(" ").map(r=>Number(r)))??[]}function jt(t,i){return Dt(t,i).map(s=>Number(s))}function Ut(t,i){const s=Te(t,i);return Number(s)}function Qt(t,i){var e;const s=(e=t==null?void 0:t.nodeName)==null?void 0:e.toLowerCase(),r=i.toLowerCase();return s.slice(s.lastIndexOf(":")+1)===r}function Kt(t){return t.nodeName.slice(t.nodeName.lastIndexOf(":")+1)}export{ee as $,$t as B,jt as C,Vt as D,Qt as H,Kt as J,Dt as T,V as W,Te as l,_e as o,v as w,Ut as z};
