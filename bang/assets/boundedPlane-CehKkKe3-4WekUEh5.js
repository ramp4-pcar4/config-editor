import{i4 as y,i6 as S,P as ri,is as B,eq as ei,dD as ti,ij as si}from"./index-BeTPrQ6f.js";import{L as x,c as ai}from"./sphere-CIGsF4vz-C3zVQu9y.js";import{Z as ci,G as ui,o as gi}from"./mat4-R0VY9B_E-DoEP887i.js";import{A as u,z as I,b as h,X as m,E as l,j as p,q as O,_ as P,g as bi,R as V,W as fi,v as G,l as L}from"./vec32-CI1xtKog-DFVYRcgb.js";import{D as Z,S as li,M as pi}from"./lineSegment-D8lwRkdT-CnWWOaLb.js";import{L as Y,t as q,V as di,Z as $,a as mi,M as Ii,c as hi,N as Mi,r as U,U as Pi,e as Ni,u as $i}from"./plane-wUwHaY3K-ZwGBF7HQ.js";import{Y as s,B as N}from"./vectorStacks-B2ngxq6F-myhPBoPk.js";const _=()=>ri.getLogger("esri.views.3d.support.geometryUtils.boundedPlane");function M(i=oi){return{plane:Y(i.plane),origin:S(i.origin),basis1:S(i.basis1),basis2:S(i.basis2)}}function wi(i,o,n){const r=zi.get();return r.origin=i,r.basis1=o,r.basis2=n,r.plane=di(0,0,0,0),T(r),r}function A(i,o=M()){return W(i.origin,i.basis1,i.basis2,o)}function Ai(i,o){u(o.origin,i.origin),u(o.basis1,i.basis1),u(o.basis2,i.basis2),Pi(o.plane,i.plane)}function W(i,o,n,r=M()){return u(r.origin,i),u(r.basis1,o),u(r.basis2,n),T(r),Ri(r,"fromValues()"),r}function T(i){q(i.basis2,i.basis1,i.origin,i.plane)}function X(i,o,n){i!==n&&A(i,n);const r=l(s.get(),f(i),o);return p(n.origin,n.origin,r),n.plane[3]-=o,n}function Ti(i,o,n){return D(o,n),X(n,R(i,i.origin),n),n}function vi(i,o){const n=i.basis1[0],r=i.basis2[1],[e,t]=i.origin;return ti(e-n,t-r,e+n,t+r,o)}function D(i,o=M()){const n=(i[2]-i[0])/2,r=(i[3]-i[1])/2;return P(o.origin,i[0]+n,i[1]+r,0),P(o.basis1,n,0,0),P(o.basis2,0,r,0),Mi(0,0,1,0,o.plane),o}function j(i,o,n){return!!hi(i.plane,o,n)&&ii(i,n)}function yi(i,o,n){if(j(i,o,n))return n;const r=J(i,o,s.get());return p(n,o.origin,l(s.get(),o.direction,bi(o.origin,r)/h(o.direction))),n}function J(i,o,n){const r=w.get();ni(i,o,r,w.get());let e=Number.POSITIVE_INFINITY;for(const t of z){const a=C(i,t,v.get()),g=s.get();if(Ni(r,a,g)){const c=fi(s.get(),o.origin,g),b=Math.abs(si(I(o.direction,c)));b<e&&(e=b,u(n,g))}}return e===Number.POSITIVE_INFINITY?K(i,o,n):n}function Si(i,o){return(o-i)/o}function K(i,o,n){if(j(i,o,n))return n;const r=w.get(),e=w.get();ni(i,o,r,e);let t=Number.POSITIVE_INFINITY;for(const a of z){const g=C(i,a,v.get()),c=s.get();if($i(r,g,c)){const b=ai(o,c);if(!U(e,c))continue;b<t&&(t=b,u(n,c))}}return F(i,o.origin)<t&&Q(i,o.origin,n),n}function Q(i,o,n){const r=Ii(i.plane,o,s.get()),e=Z(k(i,i.basis1),r,-1,1,s.get()),t=Z(k(i,i.basis2),r,-1,1,s.get());return O(n,p(s.get(),e,t),i.origin),n}function H(i,o,n){const{origin:r,basis1:e,basis2:t}=i,a=O(s.get(),o,r),g=N(e,a),c=N(t,a),b=N(f(i),a);return P(n,g,c,b)}function F(i,o){const n=H(i,o,s.get()),{basis1:r,basis2:e}=i,t=h(r),a=h(e),g=Math.max(Math.abs(n[0])-t,0),c=Math.max(Math.abs(n[1])-a,0),b=n[2];return g*g+c*c+b*b}function Vi(i,o){return Math.sqrt(F(i,o))}function _i(i,o){let n=Number.NEGATIVE_INFINITY;for(const r of z){const e=C(i,r,v.get()),t=li(e,o);t>n&&(n=t)}return Math.sqrt(n)}function Ei(i,o){return U(i.plane,o)&&ii(i,o)}function qi(i,o,n,r){return Fi(i,n,r)}function R(i,o){const n=-i.plane[3];return N(f(i),o)-n}function xi(i,o,n,r){const e=R(i,o),t=l(Ci,f(i),n-e);return p(r,o,t),r}function Oi(i,o){return V(i.basis1,o.basis1)&&V(i.basis2,o.basis2)&&V(i.origin,o.origin)}function Yi(i,o,n){return i!==n&&A(i,n),ci(d,o),ui(d,d),m(n.basis1,i.basis1,d),m(n.basis2,i.basis2,d),m($(n.plane),$(i.plane),d),m(n.origin,i.origin,o),mi(n.plane,n.plane,n.origin),n}function ji(i,o,n,r){return i!==r&&A(i,r),gi(E,o,n),m(r.basis1,i.basis1,E),m(r.basis2,i.basis2,E),T(r),r}function f(i){return $(i.plane)}function Fi(i,o,n){switch(o){case 0:u(n,i.basis1),L(n,n);break;case 1:u(n,i.basis2),L(n,n);break;case 2:u(n,f(i))}return n}function ii(i,o){const n=O(s.get(),o,i.origin),r=G(i.basis1),e=G(i.basis2),t=I(i.basis1,n),a=I(i.basis2,n);return-t-r<0&&t-r<0&&-a-e<0&&a-e<0}function k(i,o){const n=v.get();return u(n.origin,i.origin),u(n.vector,o),n}function C(i,o,n){const{basis1:r,basis2:e,origin:t}=i,a=l(s.get(),r,o.origin[0]),g=l(s.get(),e,o.origin[1]);p(n.origin,a,g),p(n.origin,n.origin,t);const c=l(s.get(),r,o.direction[0]),b=l(s.get(),e,o.direction[1]);return l(n.vector,p(c,c,b),2),n}function Ri(i,o){Math.abs(I(i.basis1,i.basis2)/(h(i.basis1)*h(i.basis2)))>1e-6&&_().warn(o,"Provided basis vectors are not perpendicular"),Math.abs(I(i.basis1,f(i)))>1e-6&&_().warn(o,"Basis vectors and plane normal are not perpendicular"),Math.abs(-I(f(i),i.origin)-i.plane[3])>1e-6&&_().warn(o,"Plane offset is not consistent with plane origin")}function ni(i,o,n,r){const e=f(i);q(e,o.direction,o.origin,n),q($(n),e,o.origin,r)}const oi={plane:Y(),origin:y(0,0,0),basis1:y(1,0,0),basis2:y(0,1,0)},w=new x(Y),v=new x(pi),Ci=ei(),zi=new x(()=>M()),z=[{origin:[-1,-1],direction:[1,0]},{origin:[1,-1],direction:[0,1]},{origin:[1,1],direction:[-1,0]},{origin:[-1,1],direction:[0,-1]}],d=B(),E=B(),Xi=Object.freeze(Object.defineProperty({__proto__:null,altitudeAt:R,axisAt:qi,cameraFrustumCoverage:Si,closestPoint:K,closestPointOnSilhouette:J,copy:A,copyWithoutVerify:Ai,create:M,distance:Vi,distance2:F,distanceToSilhouette:_i,elevate:X,equals:Oi,extrusionContainsPoint:Ei,fromAABoundingRect:D,fromValues:W,getExtent:vi,intersectRay:j,intersectRayClosestSilhouette:yi,normal:f,projectPoint:Q,projectPointLocal:H,rotate:ji,setAltitudeAt:xi,setExtent:Ti,transform:Yi,up:oi,updateUnboundedPlane:T,wrap:wi},Symbol.toStringTag,{value:"Module"}));export{Xi as C,M as I,T as M,A as P,Vi as X,W as Y,D as q};
