import{q as d,bp as M}from"./index-BeTPrQ6f.js";import{w as C}from"./colorUtils-DlmOacVt-BnN0T6wa.js";import{o as I}from"./FieldsIndex-Ds4D9xP7-BiTuE5Z3.js";import{$ as x}from"./ArcadeExpression-BGPPS6z--7N6gsB31.js";import{S,L as u,w as k,i as O,J as h,Z as N,b as P}from"./utils-CIm5uQvO-CtKf129F.js";import T from"./callExpressionWithFeature-C8T2jtcK-BKO8mxzd.js";import"./vec42-DHp-FUwt-Br7hmYJs.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./UnknownTimeZone-DzO8gKMe-d6rtFXqm.js";import"./timeZoneUtils-CdK7eU4Y-fyhJ3EFx.js";import"./TimeOnly-BFfVS_ja-C4MPGwCM.js";import"./enum-D3e-PyKo-Bl5V5br5.js";import"./defaultCIMValues-BWu-APou-XI-Li77m.js";import"./quantizationUtils-Ba9rpy9D-8ijlY328.js";const g=y=>{if(!y)return[0,0,0,0];const{r:e,g:r,b:i,a:s}=y;return[e,r,i,255*s]},o=class o{static findApplicableOverrides(e,r,i){if(e&&r){if(e.primitiveName){let s=!1;for(const t of i)if(t.primitiveName===e.primitiveName){s=!0;break}if(!s)for(const t of r)t.primitiveName===e.primitiveName&&i.push(t)}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const s of e.effects)o.findApplicableOverrides(s,r,i);if(e.symbolLayers)for(const s of e.symbolLayers)o.findApplicableOverrides(s,r,i);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMPictureStroke":case"CIMGradientStroke":case"CIMSolidFill":case"CIMPictureFill":case"CIMHatchFill":case"CIMGradientFill":case"CIMVectorMarker":case"CIMCharacterMarker":case"CIMPictureMarker":if(e.effects)for(const s of e.effects)o.findApplicableOverrides(s,r,i);if(e.markerPlacement&&o.findApplicableOverrides(e.markerPlacement,r,i),e.type==="CIMVectorMarker"){if(e.markerGraphics)for(const s of e.markerGraphics)o.findApplicableOverrides(s,r,i),o.findApplicableOverrides(s.symbol,r,i)}else e.type==="CIMCharacterMarker"?o.findApplicableOverrides(e.symbol,r,i):e.type==="CIMHatchFill"?o.findApplicableOverrides(e.lineSymbol,r,i):e.type==="CIMPictureMarker"&&o.findApplicableOverrides(e.animatedSymbolProperties,r,i)}}}static findEffectOverrides(e,r){if(!e)return null;if(e.type==="CIMGeometricEffectDashes"&&S(e),!r||!e.primitiveName)return{type:"cim-effect-param",effect:e,overrides:[]};const i=u(e),s=e.primitiveName,t=[];for(const a of r)a.primitiveName===s&&t.push(u(a));return{type:"cim-effect-param",effect:i,overrides:k(t)}}static async resolveSymbolOverrides(e,r,i,s,t,a,c){if(!(e!=null&&e.symbol))return null;let{symbol:p,primitiveOverrides:l}=e;const m=!!l;if(!m&&!s)return p;p=d(p),l=d(l);let v=!0;if(r||(r={attributes:{}},v=!1),m){if(v||(l=l.filter(f=>{var n;return!((n=f.valueExpressionInfo)!=null&&n.expression.includes("$feature"))})),c||(l=l.filter(f=>{var n;return!((n=f.valueExpressionInfo)!=null&&n.expression.includes("$view"))})),l.length>0){const f=O(r.attributes),n={spatialReference:i,fields:f,geometryType:t};await o.createRenderExpressions(l,n),o.evaluateOverrides(l,r,t??"esriGeometryPoint",a,c,new I(f))}o.applyOverrides(p,l)}return s&&o.applyDictionaryTextOverrides(p,r,s,null),p}static async createRenderExpressions(e,r){const i=[];for(const s of e){const t=s.valueExpressionInfo;if(!t||o._expressionToRenderExpression.has(t.expression))continue;const a=x(t.expression,r.spatialReference);i.push(a),a.then(c=>o._expressionToRenderExpression.set(t.expression,c))}i.length>0&&await Promise.all(i)}static evaluateOverrides(e,r,i,s,t,a){const c={$view:{scale:t==null?void 0:t.scale}};for(const p of e){p.value&&typeof p.value=="object"&&C(p.value)&&(p.propertyName==="Color"||p.propertyName==="StrokeColor")&&(p.value=g(p.value));const l=p.valueExpressionInfo;if(!l)continue;const m=o._expressionToRenderExpression.get(l.expression);m&&(p.value=T(m,r,c,i,a,s))}}static applyDictionaryTextOverrides(e,r,i,s,t="Normal"){if(e!=null&&e.type)switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":case"CIMTextSymbol":{const a=e.symbolLayers;if(!a)return;for(const c of a)c&&c.type==="CIMVectorMarker"&&o.applyDictionaryTextOverrides(c,r,i,s,e.type==="CIMTextSymbol"?e.textCase:t)}break;case"CIMVectorMarker":{const a=e.markerGraphics;if(!a)return;for(const c of a)c&&o.applyDictionaryTextOverrides(c,r,i,s)}break;case"CIMMarkerGraphic":{const a=e.textString;if(a&&a.includes("[")){const c=h(a,i);e.textString=N(r,c,s,t)}}}}static applyOverrides(e,r,i,s){if(e.primitiveName){for(const t of r)if(t.primitiveName===e.primitiveName){const a=P(t.propertyName);if(s&&s.push({cim:e,nocapPropertyName:a,value:e[a]}),i){let c=!1;for(const p of i)p.primitiveName===e.primitiveName&&(c=!0);c||i.push(t)}t.value!=null&&(e[a]=t.value)}}switch(e.type){case"CIMPointSymbol":case"CIMLineSymbol":case"CIMPolygonSymbol":if(e.effects)for(const t of e.effects)o.applyOverrides(t,r,i,s);if(e.symbolLayers)for(const t of e.symbolLayers)o.applyOverrides(t,r,i,s);break;case"CIMTextSymbol":break;case"CIMSolidStroke":case"CIMSolidFill":case"CIMVectorMarker":if(e.effects)for(const t of e.effects)o.applyOverrides(t,r,i,s);if(e.type==="CIMVectorMarker"&&e.markerGraphics)for(const t of e.markerGraphics)o.applyOverrides(t,r,i,s),o.applyOverrides(t.symbol,r,i,s)}}static restoreOverrides(e){for(const r of e)r.cim[r.nocapPropertyName]=r.value}static buildOverrideKey(e){let r="";for(const i of e)i.value!==void 0&&(r+=`${i.primitiveName}${i.propertyName}${JSON.stringify(i.value)}`);return r}static toValue(e,r){if(e==="DashTemplate")return r.split(" ").map(i=>Number(i));if(e==="Color"){const i=new M(r).toRgba();return i[3]*=255,i}return r}};o._expressionToRenderExpression=new Map;let b=o;export{b as OverrideHelper};
