import{B as w,ns as Q,a4 as X,a6 as q,aB as z,q as K,d4 as N,C as I,d3 as V,nt as B,H as Y,D as ee,eq as d,ek as te,dv as re,k0 as ae,eg as se,bj as ne,j$ as oe,el as ie,i1 as le,be as ce,m as S,E as C,n as he}from"./index-BeTPrQ6f.js";import{E as pe,z as ue,q as fe,l as de,Q as me,Z as O,S as ye}from"./vec32-CI1xtKog-DFVYRcgb.js";import{O as xe}from"./geodesicUtils-DHDMXkUY-CP5HeHA5.js";import{c as ge}from"./distanceOperator-C3n_j88h-CjjOO0Zj.js";import{c as Me,u as we}from"./simplifyOperator-CK8t6p1S-COLMjdqn.js";import{S as Re}from"./mat2d-Cf4xHr3Z-u09Kv-lR.js";import{n as E,r as Te}from"./mat2df64-VxtldH1S-CqyKAV7h.js";import{X as ve,L as Se}from"./quat-B6H0knG8-DtO1-hlf.js";import{e as j}from"./quatf64-C16JxGFv-BKWK1F8U.js";var k;let M=k=class extends I{constructor(t){super(t),this.center=null,this.geodesic=!1,this.numberOfPoints=60,this.radius=1e3,this.radiusUnit="meters"}initialize(){const t=this.center,e=this.numberOfPoints;if(this.hasZ=(t==null?void 0:t.hasZ)??!1,this.rings.length!==0||!t)return;const a=te(this.radius,this.radiusUnit,"meters"),s=t.spatialReference;let o,r="geographic";if(s.isWebMercator?r="webMercator":((s.wkid&&re[s.wkid])!=null||(s.wkt2||s.wkt)&&ae(s.wkt2||s.wkt))&&(r="projected"),this.geodesic){let n;switch(r){case"webMercator":n=se(t);break;case"projected":console.error("Creating a geodesic circle requires the center to be specified in web mercator or geographic coordinate system");break;case"geographic":n=t}o=this._createGeodesicCircle(n,a,e),r==="webMercator"&&(o=ne(o))}else{let n;r==="webMercator"||r==="projected"?n=a/oe(t.spatialReference):r==="geographic"&&(n=ie(a,"meters",le(t.spatialReference).radius)),o=this._createPlanarCircle(t,n,e)}this.spatialReference=o.spatialReference,this.addRing(o.rings[0])}clone(){const{center:t,numberOfPoints:e,radius:a,radiusUnit:s,geodesic:o}=this;return new k({center:t==null?void 0:t.clone(),numberOfPoints:e,radius:a,radiusUnit:s,geodesic:o})}_createGeodesicCircle(t,e,a){const s=[],o=[t.x,t.y];for(let r=0;r<360;r+=360/a){const n=this.hasZ?[0,0,t.z??0]:[0,0];xe(n,o,r,e,ce.WGS84),s.push(n)}return s.push(s[0]),new I({rings:[s]})}_createPlanarCircle(t,e,a){const s=[],o=2*Math.PI/a;for(let r=0;r<a;++r){const n=o*r,i=[t.x+Math.cos(-n)*e,t.y+Math.sin(-n)*e];this.hasZ&&i.push(t.z??0),s.push(i)}return s.push(s[0]),new I({spatialReference:t.spatialReference,rings:[s]})}};S([C({type:w})],M.prototype,"center",void 0),S([C()],M.prototype,"geodesic",void 0),S([C()],M.prototype,"numberOfPoints",void 0),S([C()],M.prototype,"radius",void 0),S([C()],M.prototype,"radiusUnit",void 0),M=k=S([he("esri.geometry.Circle")],M);const be=M;function Z(t,e,a=null){return a!=null?[t,e,a]:[t,e]}function l(t,e,a=null){return a!=null?{x:t,y:e,z:a}:{x:t,y:e}}class A{constructor(e){this.spatialReference=e}mapToLocalMultiple(e){return e.map(a=>this.mapToLocal(a)).filter(z)}get doUnnormalization(){return!1}}let We=class extends A{constructor(t,e,a=null){super(e),this._defaultZ=a,this.transform=E(),this.transformInv=E(),this.transform=Te(t),Re(this.transformInv,this.transform)}makeMapPoint(t,e){return Z(t,e,this._defaultZ)}mapToLocal(t){return l(this.transform[0]*t[0]+this.transform[2]*t[1]+this.transform[4],this.transform[1]*t[0]+this.transform[3]*t[1]+this.transform[5])}localToMap(t){return Z(this.transformInv[0]*t.x+this.transformInv[2]*t.y+this.transformInv[4],this.transformInv[1]*t.x+this.transformInv[3]*t.y+this.transformInv[5],this._defaultZ)}},Ce=class extends A{constructor(t,e){super(t.spatialReference),this.view=t,this.defaultZ=null,this.pWS=d(),this.tangentFrameUpWS=d(),this.tangentFrameRightWS=d(),this.tangentFrameForwardWS=d(),this.localFrameRightWS=d(),this.localFrameUpWS=d(),this.worldToLocalTransform=j(),this.localToWorldTransform=j(),this.scale=1,this.scale=t.resolution,this.referenceMapPoint=e,this.defaultZ=e.hasZ?e.z:null;const a=t.state.camera.viewRight;this.view.renderCoordsHelper.toRenderCoords(this.referenceMapPoint,this.pWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,0,this.tangentFrameRightWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,1,this.tangentFrameUpWS),this.view.renderCoordsHelper.worldBasisAtPosition(this.pWS,2,this.tangentFrameForwardWS);const s=d();pe(s,this.tangentFrameForwardWS,ue(a,this.tangentFrameForwardWS)),fe(this.localFrameRightWS,a,s),de(this.localFrameRightWS,this.localFrameRightWS),me(this.localFrameUpWS,this.tangentFrameForwardWS,this.localFrameRightWS),ve(this.worldToLocalTransform,this.localFrameRightWS,this.tangentFrameRightWS),Se(this.localToWorldTransform,this.worldToLocalTransform)}get doUnnormalization(){return this.view.viewingMode==="global"}makeMapPoint(t,e){return Z(t,e,this.defaultZ)}mapToLocal(t){const e=d();this.view.renderCoordsHelper.toRenderCoords(new w({x:t[0],y:t[1],spatialReference:this.spatialReference}),e),O(e,e,this.worldToLocalTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(e,new w({spatialReference:this.view.spatialReference}));return a!=null?l(a.x/this.scale,a.y/this.scale):null}localToMap(t){const e=d();this.view.renderCoordsHelper.toRenderCoords(new w({x:t.x*this.scale,y:t.y*this.scale,spatialReference:this.spatialReference}),e),O(e,e,this.localToWorldTransform);const a=this.view.renderCoordsHelper.fromRenderCoords(e,new w({spatialReference:this.view.spatialReference}));return a!=null?Z(a.x,a.y,this.defaultZ):null}};function $e(t,e){if(t.type==="2d")return new We(t.state.transform,t.spatialReference,e.length>2?e[2]:null);if(t.type==="3d"){const a=e.length>2?new w({x:e[0],y:e[1],z:e[2],spatialReference:t.spatialReference}):new w({x:e[0],y:e[1],spatialReference:t.spatialReference});return new Ce(t,a)}return null}function R(t,e){const a=new w({x:t[0],y:t[1],spatialReference:e});return t.length>2&&(a.z=t[2]),a}function _e(t,e){return new ee({points:t,spatialReference:e})}function Oe(t,e,a){const s=new Y({paths:t,spatialReference:e});return a&&B(s),s}function L(t,e,a,s=!0){const o=K(t);o.forEach(n=>{const i=n[0],p=n[n.length-1];N(i,p)&&n.length!==1||n.push(n[0])});let r=new I({rings:o,spatialReference:e});return r.rings.forEach(n=>{V(n)||n.reverse()}),a&&B(r),s&&!Me(r)&&q(e)&&(r=we(r)||r),r}function Ee(t,e,a){const s=e.mapToLocalMultiple(t),o=[],r={x:s[0].x,y:s[0].y},n={x:s[1].x,y:s[1].y},i=Math.round(n.x-r.x),p=Math.round(n.y-r.y),u=Math.max(Math.abs(i),Math.abs(p));if(a){const c={x:r.x+u,y:r.y+u},m={x:r.x-u,y:r.y-u};o.push(l(c.x,m.y),l(m.x,m.y),l(m.x,c.y),l(c.x,c.y))}else{const c={x:i>0?r.x+u:r.x-u,y:p>0?r.y+u:r.y-u};o.push(l(r.x,r.y),l(c.x,r.y),l(c.x,c.y),l(r.x,c.y))}return G(L([o.map(c=>e.localToMap(c)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function je(t,e,a){let s=e.mapToLocalMultiple(t);if(s.length===1){const i=s[0];s=[l(i.x-48,i.y+48),l(i.x+48,i.y-48),l(i.x+48,i.y-48),l(i.x-48,i.y+48)]}const o=[],r={x:s[0].x,y:s[0].y},n={x:s[1].x,y:s[1].y};if(a){const i=Math.round(n.x-r.x),p=Math.round(n.y-r.y);o.push(l(r.x-i,r.y-p),l(n.x,r.y-p),l(n.x,n.y),l(r.x-i,n.y))}else o.push(l(r.x,r.y),l(n.x,r.y),l(n.x,n.y),l(r.x,n.y));return G(L([o.map(i=>e.localToMap(i)).filter(z)],e.spatialReference,e.doUnnormalization,!0),o,e)}function G(t,e,a){const s=P(e[3],e[2],a),o=P(e[1],e[2],a),r=P(e[0],e[1],a),n=P(e[0],e[3],a);return{geometry:t,midpoints:s!=null&&o!=null&&r!=null&&n!=null?{top:s,right:o,bottom:r,left:n}:null}}function P(t,e,a){b[0]=t.x,b[1]=t.y,b[2]=0,W[0]=e.x,W[1]=e.y,W[2]=0,ye(b,b,W,.5),U.x=b[0],U.y=W[1],U.z=W[2];const s=a.localToMap(U);return s!=null?R(s,a.spatialReference):null}const U=l(0,0,0),b=d(),W=d();function qe(t,e,a,s){const o=e.mapToLocalMultiple(t);let r=null,n=null;if(a)r=o[0],n=o[1];else{const h=o[0],f=o[1],T=Math.round(f.x-h.x),v=Math.round(f.y-h.y),y=Math.max(Math.abs(T),Math.abs(v));r=l(T>0?h.x+y/2:h.x-y/2,v>0?h.y+y/2:h.y-y/2),n=l(Math.abs(T)>Math.abs(v)?r.x-y/2:r.x,Math.abs(T)>Math.abs(v)?r.y:r.y-y/2)}const i=e.localToMap(r),p=e.localToMap(n);if(i==null||p==null)return null;e.doUnnormalization&&Q([[i,p]],e.spatialReference);const u=R(i,e.spatialReference),c=R(p,e.spatialReference),m=X(e.spatialReference);let x=0;if(q(e.spatialReference))x=m*ge(u,c);else{const h=r.x-n.x,f=r.y-n.y;x=m*Math.sqrt(h*h+f*f)*(s||1)}const F=new be({center:u,radius:x,radiusUnit:"meters",spatialReference:e.spatialReference});return{geometry:L(F.rings,F.spatialReference,!1),center:u,edge:c}}function Be(t,e,a){const s=e.mapToLocalMultiple(t),o=s[0],r=s[1],n=Math.round(r.x-o.x),i=Math.round(r.y-o.y),p=l(a?o.x:o.x+n/2,a?o.y:o.y+i/2),u=a?n:n/2,c=a?i:i/2,m=60,x=[],F=2*Math.PI/m;function h(g){const D=Math.cos(g),J=Math.sin(g);return l(u*D+p.x,c*J+p.y)}for(let g=0;g<m;g++)x.push(h(g*F));x.push(x[0]);const{spatialReference:f,doUnnormalization:T}=e,v=L([x.map(g=>e.localToMap(g)).filter(z)],f,T,!1),y=e.localToMap(h(Math.PI/2)),H=e.localToMap(h(0)),$=e.localToMap(h(-Math.PI/2)),_=e.localToMap(h(Math.PI));return{geometry:v,midpoints:y!=null&&H!=null&&$!=null&&_!=null?{top:R(y,f),right:R(H,f),bottom:R($,f),left:R(_,f)}:null}}export{_e as C,je as I,qe as L,$e as P,Oe as U,We as Y,Be as Z,L as a,Ee as z};
