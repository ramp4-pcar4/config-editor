import{l as N}from"./index-12gn5LMs.js";import{r as O,I as P,V as Q}from"./rasterProjectionHelper-DGqzGF1m-LWHAZx_x.js";class U{constructor(n=15e3,t=5e3){this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=n,this._interval=Math.min(n,t)}decreaseRefCount(n,t){const e=n+"/"+t,l=this._cachedBlocks;if(l.has(e)){const o=l.get(e);return o.refCount--,o.refCount<=0&&(l.delete(e),o.controller&&o.controller.abort()),o.refCount}return 0}getBlock(n,t){const e=n+"/"+t,l=this._cachedBlocks;if(l.has(e)){const o=l.get(e);return o.ts=Date.now(),o.refCount++,l.delete(e),l.set(e,o),o.block}return null}putBlock(n,t,e,l){const o=this._cachedBlocks,s=n+"/"+t;if(o.has(s)){const i=o.get(s);i.ts=Date.now(),i.refCount++}else o.set(s,{block:e,ts:Date.now(),refCount:1,controller:l});this._trim(),this._updateTimer()}deleteBlock(n,t){const e=this._cachedBlocks,l=n+"/"+t;e.has(l)&&e.delete(l)}updateMaxSize(n){this._size=n,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(this._timer!=null)return;const n=this._cachedBlocks;this._timer=setInterval(()=>{const t=Array.from(n),e=Date.now();for(let l=0;l<t.length&&t[l][1].ts<=e-this._duration;l++)n.delete(t[l][0]);n.size===0&&this._clearTimer()},this._interval)}_trim(){const n=this._cachedBlocks;if(this._size===-1||this._size>=n.size)return;const t=Array.from(n);for(let e=0;e<t.length-this._size;e++)n.delete(t[e][0])}_clearTimer(){this._timer!=null&&(clearInterval(this._timer),this._timer=null)}}const f=new Map,d=new U;function F(r,n,t){const e=[];return n!=null&&e.push(`sliceId=${n}`),t!=null&&e.push(`bandIds=${t.join(",")}`),e.length?`${r}?${e.join("&")}`:r}function G(r,n){const t={extent:null,rasterInfo:n,cache:new Map},e=f.get(r);return e?(e.push(t),e.length-1):(f.set(r,[t]),0)}function J(r,n){const t=f.get(r);t&&(t[n]=null,t.some(e=>e!=null)||f.delete(r))}function K(r,n,t){var s,i;const e=f.get(r);if(!e)return n==null?d.decreaseRefCount(r,t):0;if(n==null||e[n]==null)return d.decreaseRefCount(r,t);const l=(s=e[n])==null?void 0:s.cache,o=l==null?void 0:l.get(t);if(l&&o){if(o.refCount--,o.refCount===0){l.delete(t);for(let c=0;c<e.length;c++)(i=e[c])==null||i.cache.delete(t);o.controller&&o.controller.abort()}return o.refCount}return 0}function ee(r,n,t){var o,s,i;const e=f.get(r);if(!e)return n==null?d.getBlock(r,t):null;if(n==null||e[n]==null){for(let c=0;c<e.length;c++){const a=(o=e[c])==null?void 0:o.cache.get(t);if(a)return a.refCount++,a.block}return d.getBlock(r,t)}const l=(s=e[n])==null?void 0:s.cache.get(t);if(l)return l.refCount++,l.block;for(let c=0;c<e.length;c++){if(c===n||!e[c])continue;const a=(i=e[c])==null?void 0:i.cache,m=a==null?void 0:a.get(t);if(a&&m)return m.refCount++,a.set(t,m),m.block}return null}function te(r,n,t,e,l=null){var i;const o=f.get(r);if(!o)return void(n==null&&d.putBlock(r,t,e,l));if(n==null||o[n]==null)return void d.putBlock(r,t,e,l);const s={refCount:1,block:e,isResolved:!1,isRejected:!1,controller:l};e.then(()=>s.isResolved=!0).catch(()=>s.isRejected=!0),(i=o[n])==null||i.cache.set(t,s)}function ne(r,n,t){var l;const e=f.get(r);e?n!=null&&e[n]!=null?(l=e[n])==null||l.cache.delete(t):d.deleteBlock(r,t):n==null&&d.deleteBlock(r,t)}function X(r,n){const t=f.get(r);return t?t[n]??null:null}function le(r,n,t,e,l,o,s=null){const i=X(r,n);if(!i)return;const c=i.extent,{cache:a,rasterInfo:m}=i;if(c&&c.xmin===t.xmin&&c.xmax===t.xmax&&c.ymin===t.ymin&&c.ymax===t.ymax)return;e=e??0;const C=t.clone().normalize(),{spatialReference:M,transform:R}=m,w=new Set;for(let _=0;_<C.length;_++){const h=C[_];if(h.xmax-h.xmin<=e||h.ymax-h.ymin<=e)continue;let u=O(h,M,s);if(u==null||R!=null&&(u=R.inverseTransform(u),u==null))continue;const D=new N({x:e,y:e,spatialReference:h.spatialReference});if(l==null&&!(l=P(D,M,h,s)))return;const{pyramidLevel:k,pyramidResolution:S,excessiveReading:A}=Q(l,m,o||"closest");if(A)return;const{storageInfo:x}=m,{origin:b}=x,{x:v,y:z}=S,I=Math.max(0,Math.floor((u.xmin-b.x)/v)),$=Math.max(0,Math.floor((b.y-u.ymax)/z)),H=Math.ceil(u.width/v-.1),V=Math.ceil(u.height/z-.1),T=k>0?x.pyramidBlockWidth:x.blockWidth,j=k>0?x.pyramidBlockHeight:x.blockHeight,g=x.blockBoundary[k];if(!g)continue;const p=1,W=Math.max(g.minCol,Math.floor(I/T)-p),E=Math.max(g.minRow,Math.floor($/j)-p),L=Math.min(g.maxCol,Math.floor((I+H-1)/T)+p),q=Math.min(g.maxRow,Math.floor(($+V-1)/j)+p);for(let y=E;y<=q;y++)for(let B=W;B<=L;B++)w.add(`${k}/${y}/${B}`)}a.forEach((_,h)=>{if(!w.has(h)){const u=a.get(h);(u==null||u.isResolved||u.isRejected)&&a.delete(h)}}),i.extent={xmin:t.xmin,ymin:t.ymin,xmax:t.xmax,ymax:t.ymax}}export{te as O,F as P,ne as U,G as V,J as X,K as Y,ee as Z,le as t};
