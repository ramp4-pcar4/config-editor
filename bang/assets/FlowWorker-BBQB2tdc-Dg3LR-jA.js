import{k4 as y,az as M,aA as v,m as z,n as k}from"./index-BeTPrQ6f.js";import{W as S,G as E}from"./dataUtils-Dmw3coU_-BChqYnqi.js";import{a as A}from"./Cyclical-Bzwh_QaL-CXh-hbnA.js";function T(n,a,t){const{extent:i,valid:u}=n,[e,o,r,s]=i;return!(t<o||t>s)&&(u!=null&&e>r?a>=r||a<=e:a>=e&&a<=r)}function b(n,a,t,i){const{extent:u,modelSize:e,valid:o}=n,[r,s,c]=u,f=j(r,c,o);let l=a/e[0]*f+r;return o!=null&&i&&(l=new A(o[0],o[1]).normalize(l)),[l,(e[1]-t)/e[1]*v(u)+s]}function j(n,a,t){if(t!=null&&n>a){const[i,u]=t;return u-n+(a-i)}return a-n}function F(n){return n?4:3}function I(n,a,t){const[i,u]=t.modelSize;let e=null;const o=new Map;a.forEach(s=>{o.set(s.lij,S(n,s))});const r=(s,c,f)=>y(s.extent,c,f);return(s,c)=>{const f=Math.round(s),l=Math.round(c);if(!n.wrapAround&&(f<0||f>=i||l<0||l>=u))return[0,0];const[d,m]=b(t,s,c,!0);if(!T(t,d,m))return[0,0];if(e==null||!r(e,d,m)){e=null;for(const[L,D]of a)if(r(D,d,m)){e=D;break}}if((e==null?void 0:e.data)==null)return[0,0];const g=o.get(e.lij);if(g==null)return[0,0];const{width:_,height:w,extent:h}=e;return g((d-h[0])/M(h)*_,w-(m-h[1])/v(h)*w)}}let p=class{constructor(){this._tileData=new Map}async generateStreamlines(n){const{flowData:a,flowExtentInfo:t,needsMagnitude:i,simulationSettings:u,startPositions:e}=n,o=x(S(u,a),u,t.modelSize,i,e);return{result:{streamlines:o},transferList:o==null?void 0:o.map(r=>r.vertices.buffer)}}async generateTiledStreamlines(n){const{flowDataTiles:a,flowExtentInfo:t,needsMagnitude:i,reset:u,simulationSettings:e,startPositions:o}=n;this._updateTileData(a,u);const r=x(I(e,this._tileData,t),e,t.modelSize,i,o);return{result:{streamlines:r},transferList:(r==null?void 0:r.map(s=>s.vertices.buffer))??[]}}_updateTileData(n,a){a&&this._tileData.forEach((t,i)=>{n.get(i)==null&&this._tileData.delete(i)}),n.forEach((t,i)=>{t.type==="delete"?this._tileData.delete(i):t.type!=="on-worker"&&t.type!=="waiting"&&this._tileData.set(i,t.data)})}};p=z([k("esri.views.3d.support.flow.FlowWorker")],p);const $=p;function x(n,a,t,i,u){if(n==null)return;const e=E(a,n,t[0],t[1],{positions:u}),o=[],r=F(i);for(const{vertices:s,stage:c}of e){const f=new Float32Array(s.length*r);for(let l=0;l<s.length;l++)f[l*r]=s[l].x,f[l*r+1]=s[l].y,f[l*r+2]=s[l].t,i&&(f[l*r+3]=s[l].speed);o.push({vertices:f,stage:c,hasMagnitude:i})}return o}export{$ as default};
