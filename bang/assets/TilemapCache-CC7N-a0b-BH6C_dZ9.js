import{aj as q,v as T,as as z,aH as L,bD as A,av as S,cw as x,i as P,cx as C,l as p,A as M,V as U,y as I,q as j,cy as k,m as d,E as b,n as E}from"./index-BeTPrQ6f.js";import{i as H}from"./LRUCache-CvGiiws0-B3io5Jp4.js";import{e as R}from"./TileKey-1TQKLvpf-ByD6Ad6n.js";import{c as F}from"./memoryEstimations-C_GUL8g_-JniNFd5l.js";function N(i,e=!1){return i<=k?e?new Array(i).fill(0):new Array(i):new Uint32Array(i)}class g{constructor(e){K(e);const{location:a,data:l}=e;this.location=Object.freeze(j(a));const t=this.location.width,r=this.location.height;let n=!0,o=!0;const h=Math.ceil(t*r/32),s=N(h);let c=0;for(let f=0;f<l.length;f++){const m=f%32;l[f]?(o=!1,s[c]|=1<<m):n=!1,m===31&&++c}o?(this._availability="unavailable",this.byteSize=40):n?(this._availability="available",this.byteSize=40):(this._availability=s,this.byteSize=40+F(s))}getAvailability(e,a){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const l=(e-this.location.top)*this.location.width+(a-this.location.left),t=l%32,r=l>>5,n=this._availability;return r<0||r>n.length?"unknown":n[r]&1<<t?"available":"unavailable"}static fromDefinition(e,a){const l=e.service.request||T,{row:t,col:r,width:n,height:o}=e,h={query:{f:"json"}};return a=a?{...h,...a}:h,l(J(e),a).then(s=>s.data).catch(s=>{var c;if(((c=s==null?void 0:s.details)==null?void 0:c.httpStatus)===422)return{location:{top:t,left:r,width:n,height:o},valid:!0,data:new Array(n*o).fill(0)};throw s}).then(s=>{if(s.location&&(s.location.top!==t||s.location.left!==r||s.location.width!==n||s.location.height!==o))throw new p("tilemap:location-mismatch","Tilemap response for different location than requested",{response:s,definition:{top:t,left:r,width:n,height:o}});return g.fromJSON(s)})}static fromJSON(e){return Object.freeze(new g(e))}}function D(i){return`${i.level}/${i.row}/${i.col}/${i.width}/${i.height}`}function J(i){var l;let e;if((l=i.service.tileServers)!=null&&l.length){const t=i.service.tileServers;e=`${t&&t.length?t[i.row%t.length]:i.service.url}/tilemap/${i.level}/${i.row}/${i.col}/${i.width}/${i.height}`}else e=`${i.service.url}/tilemap/${i.level}/${i.row}/${i.col}/${i.width}/${i.height}`;const a=i.service.query;return a&&(e=`${e}?${a}`),e}function K(i){if(!(i!=null&&i.location))throw new p("tilemap:missing-location","Location missing from tilemap response");if(i.valid===!1)throw new p("tilemap:invalid","Tilemap response was marked as invalid");if(!i.data)throw new p("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(i.data))throw new p("tilemap:data-mismatch","Data must be an array of numbers");if(i.data.length!==i.location.width*i.location.height)throw new p("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var y;function O(i,e,a){return new p("tile-map:tile-unavailable","Tile is not available",{level:i,row:e,col:a})}var u;let v=(u=class extends q{constructor(e){super(e),this._pendingTilemapRequests={},this.request=T,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new H(2097152),this.addHandles(z(()=>{const{layer:e}=this;return[e==null?void 0:e.parsedUrl,e==null?void 0:e.tileServers,e==null?void 0:e.apiKey,e==null?void 0:e.customParameters]},()=>this._initializeTilemapDefinition(),L))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,a,l){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const t=this._tilemapFromCache(e,a,l,this._tmpTilemapDefinition);return t?t.getAvailability(a,l):"unknown"}fetchAvailability(e,a,l,t){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(O(e,a,l)):this._fetchTilemap(e,a,l,t).catch(r=>r).then(r=>{if(r instanceof g){const n=r.getAvailability(a,l);if(n==="unavailable")throw O(e,a,l);return n}if(A(r))throw r;return"unknown"})}fetchAvailabilityUpsample(e,a,l,t,r){t.level=e,t.row=a,t.col=l;const n=this.layer.tileInfo;n.updateTileInfo(t);const o=this.fetchAvailability(e,a,l,r).catch(h=>{if(A(h))throw h;if(n.upsampleTile(t))return this.fetchAvailabilityUpsample(t.level,t.row,t.col,t,r);throw h});return this._fetchAvailabilityUpsamplePrefetch(e,a,l,r,o),o}async _fetchAvailabilityUpsamplePrefetch(e,a,l,t,r){if(!this._prefetchingEnabled)return;const n=`prefetch-${e}-${a}-${l}`;if(this.hasHandles(n))return;const o=new AbortController;r.then(()=>o.abort(),()=>o.abort());let h=!1;const s=S(()=>{h||(h=!0,o.abort())});if(this.addHandles(s,n),await x(10,o.signal).catch(()=>{}),h||(h=!0,this.removeHandles(n)),P(o))return;const c=new R(e,a,l),f={...t,signal:o.signal},m=this.layer.tileInfo;for(let w=0;y._prefetches.length<y._maxPrefetch&&m.upsampleTile(c);++w){const _=this.fetchAvailability(c.level,c.row,c.col,f);y._prefetches.push(_);const $=()=>{y._prefetches.removeUnordered(_)};_.then($,$)}}static cleanupTilemapCache(){this._prefetches.prune()}_fetchTilemap(e,a,l,t){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new p("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const r=this._tmpTilemapDefinition,n=this._tilemapFromCache(e,a,l,r);if(n)return Promise.resolve(n);const o=t==null?void 0:t.signal;return t={...t,signal:null},new Promise((h,s)=>{M(o,()=>s(U()));const c=D(r);let f=this._pendingTilemapRequests[c];if(!f){f=g.fromDefinition(r,t).then(w=>(this._tilemapCache.put(c,w,w.byteSize),w));const m=()=>{delete this._pendingTilemapRequests[c]};this._pendingTilemapRequests[c]=f,f.then(m,m)}f.then(h,s)})}_initializeTilemapDefinition(){var t;if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:a,customParameters:l}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:I({...e.query,...l,token:a??((t=e.query)==null?void 0:t.token)}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,a,l,t){t.level=e,t.row=a-a%this.size,t.col=l-l%this.size;const r=D(t);return this._tilemapCache.get(r)}get test(){}},y=u,u._maxPrefetch=4,u._prefetches=new C({initialSize:y._maxPrefetch}),u);d([b({constructOnly:!0})],v.prototype,"layer",void 0),d([b({constructOnly:!0})],v.prototype,"minLOD",void 0),d([b({constructOnly:!0})],v.prototype,"maxLOD",void 0),d([b({constructOnly:!0})],v.prototype,"request",void 0),d([b({constructOnly:!0})],v.prototype,"size",void 0),v=y=d([E("esri.layers.support.TilemapCache")],v);export{v as u};
