import{V as xe,G as ye,Z as Re,N as Me,B as fe,aR as ze,m as Ce,k as F,v as A,aE as Q,b as Ge,E as de,b3 as L,bd as z,d as oe,Y as Te,a4 as N,o as Ee}from"./Point2D-BVUQyGsf-qih0ZuJV.js";import{u as we,m as pe,R as ue,E as me,A as De,q as W,Z as ke,H as le,al as te,am as Oe,C as se,D as ie,w as qe,g as y,X as x,an as Pe,ao as ce,ap as M,s as R,aq as O,ar as Ae,as as Z,x as Le,I as Ne,Y as be}from"./ProjectionTransformation-BXUROh_s-kKBZ5FDB.js";import{Envelope2D as b}from"./Envelope2D-2iYexKQo-BCKocNS7.js";import{g as Ye}from"./OperatorShapePreservingLength-BW7Hyec4-DdJXcuto.js";import{jY as Y,jZ as ne}from"./index-BeTPrQ6f.js";import{E as ae}from"./Transformation2D-CZCvoz9N-B-IhcWnl.js";import{c as Fe}from"./GeodeticDistanceCalculator-Ce-woMPw-Cm0Rrgr0-C2uuBPD-.js";import"./SimpleGeometryCursor-DSF_YyIm-TAMgMsbK.js";import"./OperatorDefinitions-DJdq_wrt-DP7_WWTp.js";import"./Distance2DCalculator-CXhBP-8I-CW7HDKXX-kSux2duE.js";import"./OperatorGeodeticDensifyByLength-DkbFoGbg-C9s5kmiH.js";class Je{constructor(e,n,s,i,a=100){this.m_startPt=e.clone(),this.m_endPt=n.clone(),this.m_cE2=i,this.m_cE=Math.sqrt(this.m_cE2),this.m_c1By2e=1/(2*this.m_cE),this.m_cRpu=s.getGCS().getUnit().getUnitToBaseFactor(),this.isPcs=s.getCoordinateSystemType()===2,this.PEProjcs=s.getPECoordSys(),this.m_points=Ce(2*a,Number.NaN)}setSegmentEndPoints(e,n){this.m_startPt.assign(e),this.m_endPt.assign(n)}makeFunctor(){return e=>{const n=[0,0];n[0]=this.m_startPt.x*(1-e)+this.m_endPt.x*e,n[1]=this.m_startPt.y*(1-e)+this.m_endPt.y*e,this.isPcs&&qe.projToGeogCenter(this.PEProjcs,1,n,0);const s=Math.sin(n[1]*this.m_cRpu);return this.m_cE2===0?s:-Math.log((1-this.m_cE*s)/(1+this.m_cE*s))*this.m_c1By2e+s/(1-this.m_cE2*s*s)}}}function Ue(u,e,n){const s=new b;u.queryEnvelope(s);const i=Le(e,s,!0).total(),a=e.getPannableExtent();a.xmin=s.xmin-10*i,a.xmax=s.xmax+10*i;const t=new Ne().execute(u,a,e,n).getImpl().querySegmentIterator();t.stripAttributes();const _=le();e.querySpheroidData(_);const r=_.e2,o=r===0?2:1,l=new A(0,0),h=new A(0,0),m=new F(0),p=new Je(l,h,e,r,100);for(;t.nextPath();)for(;t.hasNextSegment();){const g=t.nextSegment();l.assign(g.getStartXY()),h.assign(g.getEndXY()),p.setSegmentEndPoints(l,h);const S=Z(6,0,1,1e-12,1e-15,p.makeFunctor());m.pe((h.x-l.x)*S)}const c=_.majorSemiAxis;return o*c*c*(1-r)*Math.PI*m.getResult()/e.getPannableExtent().width()}function Xe(u,e,n,s,i){const a=je(u,e,i);let t=Se(u,a.first,n,s,i),_=1,r=0,o=0;do{if(_++,a.first*=.5,a.first<50*e.getTolerance(0))return t;a.second*=2,o=Se(u,a.first,n,s,i),r=Math.abs(o-t),t=o}while(Math.abs(t)>1&&r>1e-8*Math.abs(t)&&(a.second<65e3&&_<8||_<4));return o}function Se(u,e,n,s,i){const a=new pe().execute(u,e,0,0,i);let t;t=s?new W().execute(a,s,i):a;const _=n.getUnit().getUnitToBaseFactor()===1?Math.PI/180:1,r=new b;t.queryEnvelope(r);const o=new b,l=new b,h=new b;o.setCoords({xmin:r.xmin,ymin:75*_,xmax:r.xmax,ymax:90*_}),l.setCoords({xmin:r.xmin,ymin:-60*_,xmax:r.xmax,ymax:75*_}),h.setCoords({xmin:r.xmin,ymin:-90*_,xmax:r.xmax,ymax:-60*_}),o.inflateCoords(.01*o.width(),0),l.inflateCoords(.01*l.width(),0),h.inflateCoords(.01*h.width(),0);let m=0;return m+=_e(t,o,n,i),m+=_e(t,l,n,i),m+=_e(t,h,n,i),m}function _e(u,e,n,s){const i=new Ne().execute(u,e,n,s);if(i!==null&&!i.isEmpty()){const a=new b;i.queryEnvelope(a);const{first:t,second:_}=He(n,a,!1),r=ue(n,t,null),o=new W().execute(i,r,s).calculateArea2D();return _&&t.destroy(),o}return 0}const V=[null,null,null,null,null,null,null];function Be(u,e,n){const s=u.getUnit().getUnitToBaseFactor(),i=e.getCenter();i.scale(180*s/Math.PI);const a=new A;a.x=0,a.y=0;let t=0;if(t===0){i.y>45?(a.y=N,t=0):i.y<-45?(a.y=-N,t=1):i.x>=45&&i.x<135?(a.x=N,t=2):i.x>=135||i.x<-135?(a.x=N,t=3):i.x<-45&&i.x>=-135?(a.x=-N,t=4):(a.x=0,t=5);const P=s*Math.sqrt(Ee(e.xmin-e.xmax)+Ee(e.ymin-e.ymax)),f=a.clone(),d=e.getCenter();if(d.scale(s),t<2&&(f.x=d.x),A.distance(f,d)+.5*P>N)return null}const _=V[t];if(_!==null&&_.getGCS().equalHorizontal(u))return _;const r=u.getText(),o=a.x,l=a.y,h=0,m=0;let p=0,c=-1;t!==6?c=M.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:(Me(n),p=0,c=M.PE_PRJ_CYLINDRICAL_EQAREA);const g=ce("EqualAreaPCS");let S;c===M.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?S=`PROJCS["${g}",${r},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${o}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:c===M.PE_PRJ_CYLINDRICAL_EQAREA?S=`PROJCS["${g}",${r},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${h}],PARAMETER["False_Northing",${m}],PARAMETER["Central_Meridian",${o}],PARAMETER["Standard_Parallel_1",${p}],PARAMETER["Latitude_of_Origin",${l}],UNIT["Meter",1.0]]`:Te("getEqualAreaPcsFixed");const E=be(S);return V[t]&&V[t].destroy(),V[t]=E,E}function He(u,e,n){const s=Be(u,e,n);if(s!==null)return oe(s,!1);const i=u.getText(),a=u.getUnit().getUnitToBaseFactor(),t=(e.xmin+e.width()/2)*a,_=(e.ymin+e.height()/2)*a,r=0,o=0;let l=0,h=0,m=-1;e.ymin*a>=75*Math.PI/180||e.ymax*a<=-60*Math.PI/180?m=M.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA:e.ymin>0||e.ymax<0?(l=(e.ymin+1/3*e.height())*a,h=(e.ymin+2/3*e.height())*a,m=M.PE_PRJ_ALBERS):(l=(e.ymin+2/3*e.height())*a,m=M.PE_PRJ_CYLINDRICAL_EQAREA);const p=ce("EqualAreaPCS");let c;return m===M.PE_PRJ_LAMBERT_AZIMUTHAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${o}],PARAMETER["Central_Meridian",${t}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:m===M.PE_PRJ_ALBERS?c=`PROJCS["${p}",${i},PROJECTION["Albers"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${o}],PARAMETER["Central_Meridian",${t}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Standard_Parallel_2",${h}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:m===M.PE_PRJ_CYLINDRICAL_EQAREA?c=`PROJCS["${p}",${i},PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting",${r}],PARAMETER["False_Northing",${o}],PARAMETER["Central_Meridian",${t}],PARAMETER["Standard_Parallel_1",${l}],PARAMETER["Latitude_of_Origin",${_}],UNIT["Meter",1.0]]`:Te("getEqualAreaPCSInstance"),oe(be(c),!0)}function je(u,e,n){const s=u.calculateLength2D(),i=new Ye().execute(u,e,n)/25e3,a=s/u.getSegmentCount()*2;let t=Math.min(a,s/i);return t===0&&(t=1),oe(t,s/t)}class Qe{getOperatorType(){return 10314}supportsCurves(){return!0}accelerateGeometry(e,n,s){return!1}canAccelerateGeometry(e){return!1}execute(e,n,s){if(n.getCoordinateSystemType()===0&&ye(""),e.isEmpty()||e.getDimension()<2)return 0;if(xe(e),e.getGeometryType()===Re.enumEnvelope){const o=new we;return o.addEnvelope(e,!1),this.execute(o,n,s)}let i=e;e.getDescription().getAttributeCount()>1&&(i=e.clone(),i.dropAllAttributes());const a=new pe().execute(i,0,n.getTolerance(0),0,s);let t=null;const _=n.getGCS();_!==n&&(t=ue(n,_));let r=new me().execute(a,n,!1,s);return r.isEmpty()?0:(r===e&&(r=e.clone()),n.isPannable()?Ue(r,n,s):Xe(r,n,_,t,s))}}function re(){return{m_p_PCS:new A,m_factor:Number.NaN,setValues:Ve,assign:Ze}}function Ve(u,e){this.m_factor=u,this.m_p_PCS.assign(e)}function Ze(u){this.m_factor=u.m_factor,this.m_p_PCS.assign(u.m_p_PCS)}class We{constructor(e,n,s,i){this.m_ptStart=new x,this.m_ptEnd=new x,this.m_ptStart.assign(n),this.m_ptEnd.assign(s),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y,this.m_e=Math.sqrt(e),this.m_e2=e,this.m_c1MinusE2=1-e;const a=Math.sin(i);let t;t=this.m_e2===0?2*a:a*(L(this.m_e*a)+1/(1-this.m_e2*a*a)),this.m_baseA=t}setSegmentEndPoints(e,n){this.m_ptStart.assign(e),this.m_ptEnd.assign(n),this.m_deltaX=this.m_ptEnd.x-this.m_ptStart.x,this.m_deltaY=this.m_ptEnd.y-this.m_ptStart.y}makeFunctor(){return e=>{const n=1-e,s=n*this.m_ptStart.x+e*this.m_ptEnd.x,i=n*this.m_ptStart.y+e*this.m_ptEnd.y,a=n*this.m_ptStart.z+e*this.m_ptEnd.z,t=s*s+i*i,_=a/Math.sqrt(a*a+this.m_c1MinusE2*this.m_c1MinusE2*t);let r;return this.m_e2===0?r=2*_:r=_*(L(this.m_e*_)+1/(1-this.m_e2*_*_)),(this.m_deltaY*s-this.m_deltaX*i)/t*(r-this.m_baseA)}}}function Ke(){return{e:Number.NaN,one_p_e:Number.NaN,one_m_e:Number.NaN,one_m_e_2:Number.NaN,atanh_e_over_e:Number.NaN,half_qp:Number.NaN,f:Number.NaN,z:Number.NaN}}function he(){return{sin_phi:Number.NaN,one_p_sin_phi:Number.NaN,one_m_sin_phi:Number.NaN,one_m_e_2_sin_2_phi:Number.NaN,sin_half_phi_pf:Number.NaN,sin_half_phi_pz:Number.NaN,sin_half_asin_e_sin_phi_pf:Number.NaN,sin_half_asin_e_sin_phi_pz:Number.NaN,atanh_sin_phi:Number.NaN,atanh_esin_phi:Number.NaN,make_negative:!1,initialize:et,changeSign:tt,assign:st,clone:it}}function et(u,e,n,s){const i=.5*u;this.sin_phi=Math.sin(u);const a=e*this.sin_phi,t=.5*Math.asin(a);this.one_p_sin_phi=1+this.sin_phi,this.one_m_sin_phi=1-this.sin_phi,this.one_m_e_2_sin_2_phi=(1+a)*(1-a),this.sin_half_phi_pf=Math.sin(i+n),this.sin_half_phi_pz=Math.sin(i+s),this.sin_half_asin_e_sin_phi_pf=Math.sin(t+n),this.sin_half_asin_e_sin_phi_pz=Math.sin(t+s),this.atanh_sin_phi=Math.log(this.sin_half_phi_pf/this.sin_half_phi_pz),this.atanh_esin_phi=Math.log(this.sin_half_asin_e_sin_phi_pf/this.sin_half_asin_e_sin_phi_pz)}function tt(){this.sin_phi=-this.sin_phi;let u=this.one_p_sin_phi;this.one_p_sin_phi=this.one_m_sin_phi,this.one_m_sin_phi=u,u=this.sin_half_phi_pf,this.sin_half_phi_pf=this.sin_half_phi_pz,this.sin_half_phi_pz=u,u=this.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pf=this.sin_half_asin_e_sin_phi_pz,this.sin_half_asin_e_sin_phi_pz=u,this.atanh_sin_phi=-this.atanh_sin_phi,this.atanh_esin_phi=-this.atanh_esin_phi}function st(u){this.sin_phi=u.sin_phi,this.one_p_sin_phi=u.one_p_sin_phi,this.one_m_sin_phi=u.one_m_sin_phi,this.one_m_e_2_sin_2_phi=u.one_m_e_2_sin_2_phi,this.sin_half_phi_pf=u.sin_half_phi_pf,this.sin_half_phi_pz=u.sin_half_phi_pz,this.sin_half_asin_e_sin_phi_pf=u.sin_half_asin_e_sin_phi_pf,this.sin_half_asin_e_sin_phi_pz=u.sin_half_asin_e_sin_phi_pz,this.atanh_sin_phi=u.atanh_sin_phi,this.atanh_esin_phi=u.atanh_esin_phi,this.make_negative=u.make_negative}function it(){return{...this}}class nt{constructor(e,n,s){this.m_transformPCS2GCS=null,this.m_scaleToRadians=new ae,this.m_scaleToDegrees=new ae,this.m_progressTracker=s,Me(n!==4),this.m_curveType=n,this.m_inputSR=e,e&&e.getCoordinateSystemType()!==0||ye(""),this.m_inputGCS=e.getGCS(),this.m_a=0,this.m_eSquared=0,this.m_b=0,this.m_rpu=0}executePolygonGeodeticArea(e){let n,s=e.clone();if(s.dropAllAttributes(),e.hasNonLinearSegments()&&(s=new pe().execute(s,0,this.m_inputSR.getTolerance(0),0,this.m_progressTracker)),this.m_inputSR.isPannable()){const t=new b;s.queryEnvelope(t);const _=this.m_inputSR.getPannableExtent();if(!_.containsEnvelope(t)){const r=_.getCenterX()-t.getCenterX(),o=new ae;o.setShiftCoords(r,0),s.applyTransformation(o),t.move(r,0);const l=new fe;_.queryIntervalX(l);const h=new fe;t.queryIntervalX(h),s=l.contains(h)?De(s,this.m_inputSR):new W().foldInto360RangeGeodetic(s,this.m_inputSR,this.m_curveType)}}if(this.m_transformPCS2GCS?(s=new me().execute(s,this.m_inputSR,!1,this.m_progressTracker),n=s.createInstance(),ke(this.m_transformPCS2GCS,s,n,this.m_progressTracker)||(n=new W().execute(s,this.m_transformPCS2GCS,this.m_progressTracker))):n=new me().execute(s,this.m_inputGCS,!1,this.m_progressTracker),n.isEmpty())return 0;if(this.m_curveType===1){const t=le();return this.m_inputGCS.querySpheroidData(t),this.m_a=t.majorSemiAxis,this.m_eSquared=t.e2,this.loxodromeArea(n)}const i=n.getImpl();this.m_rpu=this.m_inputGCS.getUnit().getUnitToBaseFactor(),this.m_scaleToRadians.setScale(this.m_rpu),i.applyTransformation(this.m_scaleToRadians),this.m_scaleToDegrees=this.m_scaleToRadians,this.m_scaleToDegrees.invertThis();const a=le();if(this.m_inputGCS.querySpheroidData(a),this.m_a=a.majorSemiAxis,this.m_b=a.minorSemiAxis,this.m_eSquared=a.e2,this.m_curveType===2)return this.executeClippedPolygonGreatEllipticArea(n);{const t={stack:[],error:void 0,hasError:!1};try{const _=te.unit(9101),r=this.m_inputGCS.getPECoordSys(),o=Y(t,r.cloneAlterUnits(_),!1);let l,h,m=this.executeClippedPolygonGeodeticArea(n,o,0),p=0;do p++,l=this.executeClippedPolygonGeodeticArea(n,o,p),h=Math.abs(l-m),m=l;while(Math.abs(l)>1&&h>1e-8*Math.abs(l)&&p<7);return l}catch(_){t.error=_,t.hasError=!0}finally{ne(t)}}}executeClippedPolygonGeodeticArea(e,n,s){const i={stack:[],error:void 0,hasError:!1};try{const a=new b;e.queryEnvelope(a);const t=Y(i,this.getEqualAreaPCSInstance(n,a),!1),_=e.clone();Oe(t,_);const r=50,o=_.getImpl().getAttributeStreamRef(0),l=e.getImpl().getAttributeStreamRef(0),h=Y(i,new se,!1),m=Y(i,new se,!1),p=40,c=[0,0],g=ze(re,p),S=Ce(p,-1),E=re(),P=re();let f,d;const I=t;let T=_.calculateArea2D();const w=new F(0),G=.5*Math.PI,J=1e-10*Math.abs(T)+1e-6,K=e.getPathCount();let D,k,$,q;const C=new A,v=new A,U=new A,X=new A,B=new A,H=new A;let ge,ee;for(k=e.getPathStart(0),D=0;D<K;D++,k=$)for($=e.getPathEnd(D),o.queryPoint2D($-1<<1,U),l.queryPoint2D($-1<<1,C),Math.abs(C.y)>G&&(C.y=Q(G,C.y)),q=k;q<$;q++,U.assign(X),C.assign(v)){if(o.queryPoint2D(q<<1,X),l.queryPoint2D(q<<1,v),Math.abs(v.y)>G&&(v.y=Q(G,v.y)),ge=A.distance(U,X),ge<r||C.y===0&&v.y===0)continue;ie.geodeticDistance(this.m_a,this.m_eSquared,C.x,C.y,v.x,v.y,h,m,null,this.m_curveType);const Ie=h.val,$e=m.val;for(E.setValues(0,U),P.setValues(1,X),d=s,g[0].assign(P),S[0]=s,f=0;f>=0;){ee=.5*(E.m_factor+P.m_factor),ie.geodeticCoordinate(this.m_a,this.m_eSquared,C.x,C.y,Ie*ee,$e,h,m,this.m_curveType),B.x=h.val,B.y=m.val,c[0]=B.x,c[1]=B.y,qe.geogToProj(I,1,c),H.x=c[0],H.y=c[1];const ve=-H.offset(E.m_p_PCS,P.m_p_PCS),j=.5*ve*A.distance(E.m_p_PCS,P.m_p_PCS);if(w.pe(j),Math.abs(j)>J||Math.abs(j)>0&&d>0)P.setValues(ee,H),f++,g[f].assign(P),Math.abs(j)<=J?(d--,S[f-1]=d,S[f]=d):(d=S[f-1],S[f]=d);else{if(f<=0)break;E.assign(P),f--,P.assign(g[f]),d=S[f]}}}return T+=w.getResult(),Math.abs(T)}catch(a){i.error=a,i.hasError=!0}finally{ne(i)}}executeClippedPolygonGreatEllipticArea(e){const n=[],s=[],i=new A,a=new A,t=y(1,this.m_eSquared,new A(0,.5*Math.PI)),_=new F(0),r=new F(0),o=new F(0),l=new x,h=new x,m=new b;e.queryLooseEnvelope(m);let p=0;m.containsCoords(m.xmin,0)||(p=Math.abs(m.ymin)<Math.abs(m.ymax)?m.ymin:m.ymax);const c=new We(this.m_eSquared,l,h,p),g=this.m_a*this.m_a,S=e.getImpl().querySegmentIterator();for(S.stripAttributes();S.nextPath();)for(;S.hasNextSegment();){const E=S.nextSegment();i.assign(E.getStartXY()),a.assign(E.getEndXY()),a.x-i.x>Math.PI?i.x+=2*Math.PI:a.x-i.x<-Math.PI&&(a.x+=2*Math.PI),this.splitSegmentCrossingItegralThreshold(E,n,s);for(let P of n)l.assign(y(this.m_a,this.m_eSquared,P.getStartXY())),h.assign(y(this.m_a,this.m_eSquared,P.getEndXY())),c.setSegmentEndPoints(l,h),this.adaptiveIntegrationWithRomberg(c,_);for(let P of s){let f=P.getStartXY(),d=P.getEndXY(),I=p;f.y<0&&(d=Ge(f,f=d),f.y=-f.y,d.y=-d.y,I=-I);const T=y(1,this.m_eSquared,f),w=y(1,this.m_eSquared,d),G=Math.min(f.y,d.y),J=Pe(this.m_eSquared,f.x,d.x,I,G);r.pe(J);const K=Math.abs(Pe(this.m_eSquared,f.x,d.x,G,N)),D=new x;D.setSub(T,t);const k=new x;k.setSub(w,t);const $=new x;$.setCrossProductVector(D,k);let q=g*(K-.5*$.length());q=Q(q,d.x-f.x),o.pe(q)}n.length=0,s.length=0}return o.getResult()+g*(.5*(1-this.m_eSquared)*_.getResult()+r.getResult())}getEqualAreaPCSInstance(e,n){const s=n.getCenterX(),i=0,a=0;let t,_;const r=n.height();let o,l;(o=n.ymin>45*Math.PI/180||n.ymax<45*-Math.PI/180)?t=Q(.5*Math.PI,n.getCenterY()):(t=n.getCenterY(),_=n.ymin+r*(2/3));const h=ce("EqualAreaPCS"),m=e.toString();return l=o?te.fromString(M.PE_TYPE_PROJCS,`PROJCS["${h}", ${m}, PROJECTION["Lambert_Azimuthal_Equal_Area"],PARAMETER["False_Easting",${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}], PARAMETER["Latitude_of_Origin", ${t}], UNIT["Meter",1.0]]`):te.fromString(M.PE_TYPE_PROJCS,`PROJCS["${h}", ${m}, PROJECTION["Cylindrical_Equal_Area"],PARAMETER["False_Easting", ${i}],PARAMETER["False_Northing", ${a}],PARAMETER["Central_Meridian", ${s}],PARAMETER["Standard_Parallel_1", ${_}],PARAMETER["Latitude_of_Origin", ${t}],UNIT["Meter",1.0]]`),l}splitSegmentCrossingItegralThreshold(e,n,s){const i=y(this.m_a,this.m_eSquared,new A(0,N)),a=y(this.m_a,this.m_eSquared,new A(0,-N)),t=this.splitSegmentPassingThroughPole(e);for(let _ of t){const r=_.getStartXY(),o=_.getEndXY(),l=y(this.m_a,this.m_eSquared,r),h=y(this.m_a,this.m_eSquared,o),m=new A,p=new x;let c=x.sqrDistance(i,l),g=x.sqrDistance(l,h);if(c<=100){if(!(g>400)){s.push(new R({start:r,end:o}));continue}p.assign(h.sub(l)),p.normalizeThis(),p.assign(l.add(p.mul(20))),m.assign(O(this.m_a,this.m_eSquared,p)),s.push(new R({start:r,end:m})),r.assign(m)}if(l.assign(y(this.m_a,this.m_eSquared,r)),c=x.sqrDistance(i,h),g=x.sqrDistance(l,h),c<=100){if(!(g>400)){s.push(new R({start:r,end:o}));continue}p.assign(h.sub(l)),p.normalizeThis(),p.assign(h.sub(p.mul(20))),m.assign(O(this.m_a,this.m_eSquared,p)),s.push(new R({start:m,end:o})),o.assign(m)}if(l.assign(y(this.m_a,this.m_eSquared,r)),h.assign(y(this.m_a,this.m_eSquared,o)),c=x.sqrDistance(a,l),g=x.sqrDistance(l,h),c<=100){if(!(g>400)){s.push(new R({start:r,end:o}));continue}p.assign(h.sub(l)),p.normalizeThis(),p.assign(l.add(p.mul(20))),m.assign(O(this.m_a,this.m_eSquared,p)),s.push(new R({start:r,end:m})),r.assign(m)}if(l.assign(y(this.m_a,this.m_eSquared,r)),h.assign(y(this.m_a,this.m_eSquared,o)),c=x.sqrDistance(a,h),g=x.sqrDistance(l,h),c<=100){if(!(g>400)){s.push(new R({start:r,end:o}));continue}p.assign(h.sub(l)),p.normalizeThis(),p.assign(h.sub(p.mul(20))),m.assign(O(this.m_a,this.m_eSquared,p)),s.push(new R({start:m,end:o})),o.assign(m)}n.push(new R({start:r,end:o}))}}splitSegmentPassingThroughPole(e){const n={stack:[],error:void 0,hasError:!1};try{const s=[],i=new x,a=new x,t=new x,_=new A,r=20,o=3.124139361,l=10,h=e.getStartXY(),m=e.getEndXY(),p=Y(n,new se,!1);if(ie.geodeticDistance(this.m_a,this.m_eSquared,h.x,h.y,m.x,m.y,p,null,null,2),Math.abs(m.x-h.x)>o&&p.val>r){const c=new Fe(new A(0,90),h.divide(this.m_rpu),m.divide(this.m_rpu),this.m_inputGCS,2,2);let g=Ae(c.makeFunctor(),0,1,1e-10);if(g.second<=l&&g.first>0&&g.first<1)return i.assign(y(this.m_a,this.m_eSquared,h)),a.assign(y(this.m_a,this.m_eSquared,m)),de(i,a,g.first,t),_.assign(O(this.m_a,this.m_eSquared,t)),s.push(new R({start:h,end:_})),s.push(new R({start:_,end:m})),s;if(c.setPointDistFrom(new A(0,-90)),g=Ae(c.makeFunctor(),0,1,1e-10),g.second<=l&&g.first>0&&g.first<1)return i.assign(y(this.m_a,this.m_eSquared,h)),a.assign(y(this.m_a,this.m_eSquared,m)),de(i,a,g.first,t),_.assign(O(this.m_a,this.m_eSquared,t)),s.push(new R({start:h,end:_})),s.push(new R({start:_,end:m})),s}return s.push(new R({start:h,end:m})),s}catch(s){n.error=s,n.hasError=!0}finally{ne(n)}}adaptiveIntegrationWithRomberg(e,n){const s=e.makeFunctor();let i=0,a=1,t=s(i),_=s(a);const r=1e-17,o=1e-14;let l=(i+a)/2,h=s(l),m=Math.abs(h-t),p=Math.abs(_-h),c=0;for(;c++<32&&(m/p<.1||p/m<.1);)m<p?(n.pe(Z(5,i,l,o,r,s)),i=l,t=h):(n.pe(Z(5,l,a,o,r,s)),a=l,_=h),l=(i+a)/2,h=Math.abs(s(l)),m=Math.abs(h-t),p=Math.abs(_-h);n.pe(Z(5,i,a,o,r,s))}loxodromeAreaHemi(e,n,s,i,a){const t=s.clone(),_=a.clone();let r,o,l,h,m,p,c,g,S,E,P,f,d,I,T,w;return t.make_negative&&t.changeSign(),_.make_negative&&_.changeSign(),P=i-n,Math.abs(t.sin_phi)===1||Math.abs(_.sin_phi)===1?e.half_qp*P:t.sin_phi===_.sin_phi?(E=.5*e.one_m_e_2*t.sin_phi*(1/t.one_m_e_2_sin_2_phi+L(e.e*t.sin_phi))*P,E):(T=Math.log(_.sin_half_phi_pf*t.sin_half_phi_pz/(_.sin_half_phi_pz*t.sin_half_phi_pf)),w=Math.log(_.sin_half_asin_e_sin_phi_pf*t.sin_half_asin_e_sin_phi_pz/(_.sin_half_asin_e_sin_phi_pz*t.sin_half_asin_e_sin_phi_pf)),this.m_eSquared===1?(m=0,r=.5*(T+_.sin_phi/_.one_m_e_2_sin_2_phi-t.sin_phi/t.one_m_e_2_sin_2_phi),o=0):(m=-2*e.atanh_e_over_e*(Math.log(_.one_p_sin_phi/t.one_p_sin_phi)-e.e*w),r=(T-e.e*w)/e.one_m_e_2,o=(Math.log(_.one_m_e_2_sin_2_phi/t.one_m_e_2_sin_2_phi)+m/e.atanh_e_over_e)/e.one_m_e_2),l=-w*(t.atanh_esin_phi+_.atanh_esin_phi),h=1/t.one_m_e_2_sin_2_phi-1/_.one_m_e_2_sin_2_phi,p=z(_.one_m_sin_phi/e.one_p_e,e.e)-z(t.one_m_sin_phi/e.one_p_e,e.e),c=z(_.one_p_sin_phi/e.one_p_e,e.e)-z(t.one_p_sin_phi/e.one_p_e,e.e),g=z(t.one_m_sin_phi/-e.one_m_e,e.e)-z(_.one_m_sin_phi/-e.one_m_e,e.e),S=z(t.one_p_sin_phi/-e.one_m_e,e.e)-z(_.one_p_sin_phi/-e.one_m_e,e.e),E=.25/r*(o+l+h+m+.5*(p+c+g+S)),E+=e.half_qp,f=.5*e.one_m_e_2*t.sin_phi*(1/t.one_m_e_2_sin_2_phi+L(e.e*t.sin_phi)),d=.5*e.one_m_e_2*_.sin_phi*(1/_.one_m_e_2_sin_2_phi+L(e.e*_.sin_phi)),d<f&&(I=f,f=d,d=I),E<f&&(E=f),E>d&&(E=d),E*=P,E)}loxodromeArea(e){const n=Math.PI/180;let s=0;const i=Ke(),a=he(),t=he();i.e=Math.sqrt(this.m_eSquared),i.one_p_e=1+i.e,i.one_m_e=1-i.e,i.one_m_e_2=1-this.m_eSquared,i.atanh_e_over_e=L(i.e),this.m_eSquared>=1?i.half_qp=1:i.half_qp=.5*(1+i.atanh_e_over_e*i.one_m_e_2),i.f=.25*Math.PI,i.z=.75*Math.PI,t.initialize(0,i.e,i.f,i.z);const _=e.getPathCount(),r=new A,o=new A,l=e.getImpl().getAttributeStreamRef(0);for(let h=0;h<_;h++){const m=e.getPathStart(h),p=e.getPathEnd(h);if(!(p-m<=1)){l.queryPoint2D(2*(p-1),r);for(let c=m;c<p;c++){l.queryPoint2D(2*c,o);const g=r.y*n,S=o.y*n;if(c===m?(a.initialize(g,i.e,i.f,i.z),a.make_negative=!1):a.assign(t),t.initialize(S,i.e,i.f,i.z),t.make_negative=!1,r.y*o.y<0){if(r.y>=90&&o.y<=-90||o.y>=90&&r.y<=-90)return Number.NaN;const E=he();E.initialize(0,i.e,i.f,i.z),E.make_negative=!1;const P=a.atanh_sin_phi-i.e*a.atanh_esin_phi,f=t.atanh_sin_phi-i.e*t.atanh_esin_phi,d=(f*r.x-P*o.x)/(f-P);g<0?(a.make_negative=!0,s-=this.loxodromeAreaHemi(i,r.x*n,a,d*n,E),a.make_negative=!1,s+=this.loxodromeAreaHemi(i,d*n,E,o.x*n,t)):(s+=this.loxodromeAreaHemi(i,r.x*n,a,d*n,E),t.make_negative=!0,s-=this.loxodromeAreaHemi(i,d*n,E,o.x*n,t),t.make_negative=!1)}else r.y>=0?s+=this.loxodromeAreaHemi(i,r.x*n,a,o.x*n,t):(a.make_negative=!0,t.make_negative=!0,s-=this.loxodromeAreaHemi(i,r.x*n,a,o.x*n,t),a.make_negative=!1,t.make_negative=!1);r.assign(o)}}}return this.m_a*s*this.m_a}calculate(e){if(e.isEmpty()||e.getDimension()<2)return 0;if(e.getGeometryType()===Re.enumEnvelope){const n=new we;return n.addEnvelope(e,!1),this.calculate(n)}return this.m_inputSR!==this.m_inputGCS&&this.m_transformPCS2GCS===null&&(this.m_transformPCS2GCS=ue(this.m_inputSR,this.m_inputGCS,null)),this.executePolygonGeodeticArea(e)}}class ft{getOperatorType(){return 10311}supportsCurves(){return!0}accelerateGeometry(e,n,s){return!1}canAccelerateGeometry(e){return!1}execute(e,n,s,i){return xe(e),s===4?new Qe().execute(e,n,i):new nt(n,s,i).calculate(e)}}export{ft as OperatorGeodeticArea};
