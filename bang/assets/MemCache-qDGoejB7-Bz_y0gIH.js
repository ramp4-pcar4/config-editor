const m=-3;var o;(function(c){c[c.ALL=0]="ALL",c[c.SOME=1]="SOME"})(o||(o={}));class b{get size(){return this._size}constructor(s=10485760){this._maxSize=s,this._db=new Map,this._size=0,this._hit=0,this._miss=0,this._users=new Map,this._sizeLimits=new Map}destroy(){this.clearAll(),this._sizeLimits.clear(),this._users.clear()}register(s){this._users.set(s.id.slice(0,-1),s)}deregister(s){this.clear(s),this._sizeLimits.delete(s),this._users.delete(s.id.slice(0,-1))}get maxSize(){return this._maxSize}set maxSize(s){this._maxSize=Math.max(s,-1),this._checkSize()}getSize(s,i){var e;return((e=this._db.get(s.id+i))==null?void 0:e.size)??0}put(s,i,e,h,n){i=s.id+i;const t=this._db.get(i);if(t&&(this._size-=t.size,s.size-=t.size,this._db.delete(i),t.entry!==e&&this._notifyRemove(i,t.entry,t.size,o.ALL)),h>this._maxSize)return void this._notifyRemove(i,e,h,o.ALL);if(e===void 0)return void console.warn("Refusing to cache undefined entry ");if(!h||h<0)return console.warn(`Refusing to cache entry with size ${h} for key ${i}`),void this._notifyRemove(i,e,0,o.ALL);const r=1+Math.max(n,-4)- -3;this._db.set(i,new u(e,h,r)),this._size+=h,s.size+=h,this._checkSize()}updateSize(s,i,e,h){i=s.id+i;const n=this._db.get(i);if(n&&n.entry===e){for(this._size-=n.size,s.size-=n.size;h>this._maxSize;){const t=this._notifyRemove(i,e,h,o.SOME);if(!(t!=null&&t>0))return void this._db.delete(i);h=t}n.size=h,this._size+=h,s.size+=h,this._checkSize()}}pop(s,i){i=s.id+i;const e=this._db.get(i);if(e)return this._size-=e.size,s.size-=e.size,this._db.delete(i),++this._hit,e.entry;++this._miss}get(s,i){i=s.id+i;const e=this._db.get(i);if(e!==void 0)return this._db.delete(i),e.lives=e.lifetime,this._db.set(i,e),++this._hit,e.entry;++this._miss}peek(s,i){const e=this._db.get(s.id+i);return e?++this._hit:++this._miss,e==null?void 0:e.entry}get performanceInfo(){const s={Size:Math.round(this._size/1048576)+"/"+Math.round(this._maxSize/1048576)+"MB","Hit rate":Math.round(100*this._getHitRate())+"%",Entries:this._db.size.toString()},i={},e=new Array;this._db.forEach((t,r)=>{const _=t.lifetime;e[_]=(e[_]||0)+t.size,this._users.forEach(d=>{const{id:f,name:z}=d;if(r.startsWith(f)){const l=i[z]||0;i[z]=l+t.size}})});const h={};this._users.forEach(t=>{const r=t.name;if("hitRate"in t&&typeof t.hitRate=="number"&&!isNaN(t.hitRate)&&t.hitRate>0){const _=i[r]||0;i[r]=_,h[r]=Math.round(100*t.hitRate)+"%"}else h[r]="0%"});const n=Object.keys(i);n.sort((t,r)=>i[r]-i[t]),n.forEach(t=>s[t]=Math.round(i[t]/2**20)+"MB / "+h[t]);for(let t=e.length-1;t>=0;--t){const r=e[t];r&&(s["Priority "+(t+-3-1)]=Math.round(r/this._size*100)+"%")}return s}resetStats(){this._hit=this._miss=0,this._users.forEach(s=>s.resetHitRate())}clear(s){const i=s.id;this._db.forEach((e,h)=>{h.startsWith(i)&&(this._size-=e.size,this._db.delete(h),this._notifyRemove(h,e.entry,e.size,o.ALL))}),s.size=0}clearAll(){this._db.forEach((s,i)=>this._notifyRemove(i,s.entry,s.size,o.ALL)),this._users.forEach(s=>s.size=0),this._size=0,this._db.clear()}*values(s){for(const[i,e]of this._db)i.startsWith(s.id)&&(yield e.entry)}_getHitRate(){return this._hit/(this._hit+this._miss)}_notifyRemove(s,i,e,h){var r;const n=(r=this._users.get(s.split(a)[0]))==null?void 0:r.removeFunc,t=n==null?void 0:n(i,h,e);return typeof t=="number"?t:null}_checkSize(){this._sizeLimits.forEach((s,i)=>this._checkSizeLimits(s,i)),this._checkSizeLimits(this.maxSize)}setMaxSize(s,i){i==null||i<=0?this._sizeLimits.delete(s):this._sizeLimits.set(s,i)}_checkSizeLimits(s,i){const e=i??this;if(e.size<=s)return;const h=i==null?void 0:i.id;let n=!0;for(;n;){n=!1;for(const[t,r]of this._db)if(r.lifetime===0&&(!h||t.startsWith(h))){const _=i??this._users.get(t.split(a)[0]);if(this._purgeItem(t,r,_),e.size<=.9*s)return;n||(n=this._db.has(t))}}for(const[t,r]of this._db)if(!h||t.startsWith(h)){const _=i??this._users.get(t.split(a)[0]);if(this._purgeItem(t,r,_),e.size<=.9*s)return}}_purgeItem(s,i,e){if(this._db.delete(s),i.lives<=1){this._size-=i.size,e&&(e.size-=i.size);const h=this._notifyRemove(s,i.entry,i.size,o.SOME);h!=null&&h>0&&(this._size+=h,e&&(e.size+=h),i.lives=i.lifetime,i.size=h,this._db.set(s,i))}else--i.lives,this._db.set(s,i)}}class u{constructor(s,i,e){this.entry=s,this.size=i,this.lifetime=e,this.lives=e}}const a=":";export{b as m,m as u};
