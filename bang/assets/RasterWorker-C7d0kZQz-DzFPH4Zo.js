import{F as m,B as x,m as S,bO as h,n as y}from"./index-BeTPrQ6f.js";import{c as O}from"./projectionUtils-CsX1UTBu-DsZaU4xz.js";import{f as i}from"./PixelBlock-DwvqalBN-B5no8ogH.js";import{l as g,a as k,x as B,E as N}from"./RasterSymbolizer-BrZXkSNW-D-GxeREO.js";import{h as J,H as P,B as b,j as v,J as w,g as z,q as T,L as D,K as F}from"./vectorFieldUtils-BL5wnf_H-VvdatiJz.js";import{W as L}from"./rasterFunctionHelper-BsM3I63S-BofSI0Pb.js";import{W as I,a as j}from"./rasterProjectionHelper-DNfZ9Hwc-CptrPCWf.js";import{c as E,d as W,y as R}from"./GCSShiftTransform-BFhwvXBC-paDwrATR.js";import{s as H}from"./dataUtils-Dmw3coU_-BChqYnqi.js";import"./projectBuffer-CMNsPBq1-CMpE7Jo3.js";import"./zscale-PLuFqpaL-BIEnWBsg.js";import"./pixelRangeUtils-DcEknavd-BIL6Doop.js";import"./_commonjsHelpers-BITg13Vk-KnjfkSck.js";import"./colorUtils-DlmOacVt-BnN0T6wa.js";import"./vec42-DHp-FUwt-Br7hmYJs.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./clipUtils-BtWPrYe--B7EVDZv3.js";import"./colorRamps-C5pnMn-A-BSSJ2zvJ.js";import"./Field-Dn1Bgq7n-CJCGLoNR.js";import"./fieldType-DvW5hpfa-DYUbIy_X.js";var u;let f=u=class extends R{constructor(){super(...arguments),this.type="identity"}clone(){return new u}};S([h({IdentityXform:"identity"})],f.prototype,"type",void 0),f=u=S([y("esri.layers.support.rasterTransforms.IdentityTransform")],f);const A={GCSShiftXform:W,IdentityXform:f,PolynomialXform:E};function G(n){if(!(n!=null&&n.type))return null;const r=A[n==null?void 0:n.type];if(r){const t=new r;return t.read(n),t}return null}function a(n){if(!n)return{result:null,transferList:[]};const{pixelBlock:r,transferList:t}=n.getTransferableObject();return{result:r,transferList:t}}class lr{convertVectorFieldData(r){const t=i.fromJSON(r.pixelBlock),s=a(J(t,r.type));return Promise.resolve(s)}convertPixelBlockToFeatures(r){const t=P({pixelBlock:i.fromJSON(r.pixelBlock),extent:m.fromJSON(r.extent),fieldNames:r.fieldNames,skipFactor:r.skipFactor,skipSpatialReference:!0,pixelIdOffset:r.pixelIdOffset,imageRowSize:r.imageRowSize});return Promise.resolve(t)}computeStatisticsHistograms(r){const t=i.fromJSON(r.pixelBlock),s=g(t,{histogramSize:r.histogramSize,includeSkewnessKurtosis:r.includeSkewnessKurtosis});return Promise.resolve(s)}async decode(r){return a(await k(r.data,r.options))}symbolize(r){r.pixelBlock=i.fromJSON(r.pixelBlock),r.extent=r.extent?m.fromJSON(r.extent):null;const t=a(this.symbolizer.symbolize(r));return Promise.resolve(t)}highlightPixels(r){const t=i.fromJSON(r.pixelBlock),s=i.fromJSON(r.renderedPixelBlock);return b(t,s,r.highlightOptions),Promise.resolve(s.toJSON())}async updateSymbolizer(r){var t;this.symbolizer=B.fromJSON(r.symbolizerJSON),r.histograms&&((t=this.symbolizer)==null?void 0:t.rendererJSON.type)==="rasterStretch"&&(this.symbolizer.rendererJSON.histograms=r.histograms)}async updateRasterFunction(r){this.rasterFunction=L(r.rasterFunctionJSON)}async process(r){var t;return a(this.rasterFunction.process({extent:m.fromJSON(r.extent),primaryPixelBlocks:r.primaryPixelBlocks.map(s=>s!=null?i.fromJSON(s):null),primaryPixelSizes:(t=r.primaryPixelSizes)==null?void 0:t.map(s=>s!=null?x.fromJSON(s):null),primaryRasterIds:r.primaryRasterIds}))}stretch(r){const t=a(this.symbolizer.simpleStretch(i.fromJSON(r.srcPixelBlock),r.stretchParams));return Promise.resolve(t)}estimateStatisticsHistograms(r){const t=N(i.fromJSON(r.srcPixelBlock));return Promise.resolve(t)}split(r){const t=v(i.fromJSON(r.srcPixelBlock),r.tileSize,r.maximumPyramidLevel??0,r.useBilinear===!1),s=[];let e;return t&&(e=new Map,t.forEach((o,l)=>{if(o){const{pixelBlock:p,transferList:c}=o.getTransferableObject();e.set(l,p),c.forEach(d=>{s.includes(d)||s.push(d)})}})),Promise.resolve({result:e,transferList:s})}clipTile(r){const t=i.fromJSON(r.pixelBlock),s=a(w({...r,pixelBlock:t}));return Promise.resolve(s)}async mosaicAndTransform(r){const t=r.srcPixelBlocks.map(c=>c?new i(c):null),s=z(t,r.srcMosaicSize,{blockWidths:r.blockWidths,alignmentInfo:r.alignmentInfo,clipOffset:r.clipOffset,clipSize:r.clipSize});let e,o=s;r.coefs&&(o=T(s,r.destDimension,r.coefs,r.sampleSpacing,r.interpolation)),r.projectDirections&&r.gcsGrid&&(e=D(r.destDimension,r.gcsGrid),o=F(o,r.isUV?"vector-uv":"vector-magdir",e));const{result:l,transferList:p}=a(o);return{result:{pixelBlock:l,localNorthDirections:e},transferList:p}}async createFlowMesh(r,t){const s={data:new Float32Array(r.flowData.buffer),mask:new Uint8Array(r.flowData.maskBuffer),width:r.flowData.width,height:r.flowData.height},{vertexData:e,indexData:o}=await H(r.meshType,r.simulationSettings,s,t.signal);return{result:{vertexBuffer:e.buffer,indexBuffer:o.buffer},transferList:[e.buffer,o.buffer]}}async getProjectionOffsetGrid(r){var l;const t=m.fromJSON(r.projectedExtent),s=m.fromJSON(r.srcBufferExtent);let e=null;(l=r.datumTransformationSteps)!=null&&l.length&&(e=new O({steps:r.datumTransformationSteps})),await I();const o=r.rasterTransform?G(r.rasterTransform):null;return j({...r,projectedExtent:t,srcBufferExtent:s,datumTransformation:e,rasterTransform:o})}}export{lr as default};
