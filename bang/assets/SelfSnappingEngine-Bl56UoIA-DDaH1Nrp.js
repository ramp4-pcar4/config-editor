import{aj as X,a7 as Y,fc as b,eq as M,ab as N,ae as $,ic as B,i8 as K,ig as W,ba as j,a4 as ee,m as L,E as R,n as te}from"./index-BeTPrQ6f.js";import{u as ie,c as A}from"./Cyclical-Bzwh_QaL-CXh-hbnA.js";import{o as Z,t as z}from"./quantityUtils-v7kjLywD-Cq6IoGLM.js";import{E as v}from"./elevationInfoUtils-DFX5QvG8-DWLx2t7K.js";import{Q as se,H as S,p as m,Z as f,v as k,F as O,C as d,i as P,A as q,D as H,E as T,G as re,J,K as ne,P as oe,r as ae,R as he,S as le,T as pe}from"./SketchViewModel-BCVIeloG-Cwmt4M0t.js";import{x as C,V as Q}from"./angularMeasurementUtils-CVK8K4WU-C6RO-Ta3.js";import{o as I}from"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{L as ce,q as de,_ as ge}from"./vec32-CI1xtKog-DFVYRcgb.js";import"./ElevationInfo-tlrAM5SV-D86C1F9d.js";import"./lengthUtils-CopeXEyE-DjCEitlq.js";import"./UpdatingHandles-XotKWqvb-CyHJIoZx.js";import"./projectionUtils-CsX1UTBu-DsZaU4xz.js";import"./projectBuffer-CMNsPBq1-CMpE7Jo3.js";import"./zscale-PLuFqpaL-BIEnWBsg.js";import"./GraphicsLayer-DPoztXf7-DWF8RDJT.js";import"./GraphicsCollection-CT-y6p3H-4XYPvC_j.js";import"./BlendLayer-D8oJmNCO-A0sTzbOF.js";import"./layerContainerType-CJrPp4UB-BIF7XAYP.js";import"./jsonUtils-Bl9MVnOR-Be8hf0yA.js";import"./parser-CXoJuqeV-C7irlk5U.js";import"./mat4f32-BdRMyjXW-CWt6U0BP.js";import"./mat4-R0VY9B_E-DoEP887i.js";import"./ScaleRangeLayer-DkZwCH6_-C95kTMqN.js";import"./editableLayers-BTZOOiKD-ByJ-Oydo.js";import"./utils-DqlCEhl6-DBO0-7VG.js";import"./Queue-CK6TduSr-C-T211SM.js";import"./signal-DHxLvooI-Bin-tnuW.js";import"./Version-DSJSGSLA-Cg87msWM.js";import"./asyncUtils-Cu__bxqs-ecCTUaGV.js";import"./projectVectorToVector-OCoJKalB-CQIDHzSm.js";import"./projectPointToVector-BHS0gJJf-DOVZH8Fn.js";import"./Query-DKLDaFaA-I4zhlfzt.js";import"./Field-Dn1Bgq7n-CJCGLoNR.js";import"./fieldType-DvW5hpfa-DYUbIy_X.js";import"./vec42-DHp-FUwt-Br7hmYJs.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./geodesicUtils-DHDMXkUY-CP5HeHA5.js";import"./plane-wUwHaY3K-ZwGBF7HQ.js";import"./vectorStacks-B2ngxq6F-myhPBoPk.js";import"./quatf64-C16JxGFv-BKWK1F8U.js";import"./sphere-CIGsF4vz-C3zVQu9y.js";import"./geodeticLengthOperator-CMi-Z1ZN-WUImro4E.js";import"./geodeticCurveType-D_etKnbP-CirnHLSB.js";import"./earcut-C6NeZYSh-P2HUZ781.js";import"./triangle-DA_o7I-u-CHbj6sRJ.js";import"./lineSegment-D8lwRkdT-CnWWOaLb.js";import"./spatialReferenceEllipsoidUtils-Ty3j4VoE-BUAsRqCF.js";class F{constructor(i,e){this.view=i,this.options=e,this.squaredShortLineThreshold=P.shortLineThreshold*P.shortLineThreshold}snap(i,e){return e.vertexHandle!=null?e.vertexHandle.type!=="vertex"?[]:this.snapExistingVertex(i,e):this.snapNewVertex(i,e)}edgeExceedsShortLineThreshold(i,e){return this.exceedsShortLineThreshold(f(i.leftVertex.pos,this.view,e),f(i.rightVertex.pos,this.view,e),e)}exceedsShortLineThreshold(i,e,{spatialReference:t}){return this.squaredShortLineThreshold===0||T(S(e,t,v,this.view),S(i,t,v,this.view))>this.squaredShortLineThreshold}isVertical(i,e,{spatialReference:t}){const s=ee(t);return j(d(i),d(e))*s<P.verticalLineThresholdMeters}squaredProximityThreshold(i){return i==="touch"?this._squaredTouchProximityThreshold:this._squaredMouseProximityThreshold}get _squaredMouseProximityThreshold(){return this.options.distance*this.options.distance}get _squaredTouchProximityThreshold(){const{distance:i,touchSensitivityMultiplier:e}=this.options,t=i*e;return t*t}}class me extends F{constructor(i,e,t){super(i,e),this._geodesicLengthMeasurementUtils=t}snapNewVertex(i,e){const t=e.editGeometryOperations.data.parts[0],s=t.segments.length,n=[];if(s<1)return n;const{spatialReference:o}=e,a=S(i,o,v,this.view),{view:r}=this,h=t.segments[s-1];let l=h;do{if(m(l)&&this.edgeExceedsShortLineThreshold(l,e)){const c=k(l,r,e);this._processCandidateProposal(c.left,c.right,i,a,e,n)}l=l.leftVertex.leftSegment}while(l&&l!==h);return n}snapExistingVertex(i,e){const t=[],s=e.vertexHandle,n=s.part;if(n.segments.length<2)return t;const{view:o}=this,{spatialReference:a}=e,r=S(i,a,v,o),h=s.leftSegment,l=s.rightSegment;m(h)&&m(l)&&this.edgeExceedsShortLineThreshold(h,e)&&this.edgeExceedsShortLineThreshold(l,e)&&this._processCandidateProposal(f(h.leftVertex.pos,o,e),f(l.rightVertex.pos,o,e),i,r,e,t);const c=n.segments[0];let g=c;do{if(m(g)&&g!==s.leftSegment&&g!==s.rightSegment&&this.edgeExceedsShortLineThreshold(g,e)){const u=k(g,o,e);this._processCandidateProposal(u.left,u.right,i,r,e,t)}g=g.rightVertex.rightSegment}while(g&&g!==c);return t}_processCandidateProposal(i,e,t,s,n,o){var c;const{spatialReference:a,pointer:r}=n,h=M();fe(h,i,e,t,n,this._geodesicLengthMeasurementUtils);const l=q(J(h));T(s,S(l,a,v,this.view))<this.squaredProximityThreshold(r)&&o.push(new ne({lineStart:i,lineEnd:e,targetPoint:l,isDraped:((c=n.elevationInfo)==null?void 0:c.mode)==="on-the-ground"}))}}function fe(p,i,e,t,s,n){ue(p,i,e,t,s,n)||xe(p,t,i,e)}function ue(p,i,e,t,{spatialReference:s},n){const o=C(i,e,s,s);if(o==null)return!1;const a=C(e,t,s,s);if(a==null)return!1;const r=n.geodesicDistance(e,t,s);if(r==null)return!1;const h=Math.abs(ie.shortestSignedDiff(o,a))>Math.PI/2?A.normalize(o+Math.PI):o;return Q(p,e,s,Z(r,"meters"),z(h,"radians","geographic"),"geodesic"),p[2]=t[2],!0}function xe(p,i,e,t){pe(i,{start:e,end:t,type:1},p),p[2]=i[2]}class ve extends F{snapNewVertex(i,e){const t=e.editGeometryOperations.data.parts[0],s=t.segments.length,n=t.vertices.length,o=[];if(s<2)return o;const{view:a}=this,r=S(i,e.spatialReference,v,a),h=t.vertices[0],l=t.vertices[n-1],c=m(l.leftSegment)?f(l.pos,a,e):null,g=m(h.rightSegment)?f(h.pos,a,e):null,u=t.segments[s-1];let x=u;do{if(m(x)&&this.edgeExceedsShortLineThreshold(x,e)){const V=k(x,a,e);c&&this._checkEdgeForParallelLines(V,c,i,r,e,o),g&&this._checkEdgeForParallelLines(V,g,i,r,e,o)}x=x.leftVertex.leftSegment}while(x&&x!==u);return o}snapExistingVertex(i,e){const t=[],s=e.vertexHandle,n=s.part;if(n.segments.length<3)return t;const{view:o}=this,a=S(i,e.spatialReference,v,o),r=s.leftSegment,h=s.rightSegment,l=n.vertices[0],c=f(l.pos,o,e),g=n.vertices.length,u=n.vertices[g-1],x=f(u.pos,o,e),V=n.segments[0];let w=V;do{if(m(w)&&w!==r&&w!==h&&this.edgeExceedsShortLineThreshold(w,e)){const E=k(w,o,e);m(r)&&this._checkEdgeForParallelLines(E,f(r.leftVertex.pos,o,e),i,a,e,t),m(h)&&this._checkEdgeForParallelLines(E,f(h.rightVertex.pos,o,e),i,a,e,t),s===l?this._checkEdgeForParallelLines(E,x,i,a,e,t):s===u&&this._checkEdgeForParallelLines(E,c,i,a,e,t)}w=w.rightVertex.rightSegment}while(w&&w!==V);return t}_checkEdgeForParallelLines(i,e,t,s,n,o){var g;const a=i.left,r=i.right;if(O(y,d(e),d(a),d(r)),b(y,d(e))<P.parallelLineThreshold)return;O(y,d(t),d(a),d(r),d(e));const{spatialReference:h,pointer:l}=n,c=q(H(y[0],y[1],t[2]));if(T(s,S(c,h,v,this.view))<this.squaredProximityThreshold(l)){if(this.isVertical(c,e,n)||this.isVertical(a,r,n)||Se(i,o))return;o.push(new re({referenceLine:i,lineStart:e,targetPoint:c,isDraped:((g=n.elevationInfo)==null?void 0:g.mode)==="on-the-ground"}))}}}function Se(p,i){const e=p.left,t=p.right;for(const s of i)if(O(y,d(t),d(s.constraint.start),d(s.constraint.end),d(e)),b(y,d(t))<P.parallelLineThreshold)return s.addReferenceLine(p),!0;return!1}const y=I();class we extends F{constructor(i,e,t){super(i,e),this._geodesicLengthMeasurementUtils=t}snapNewVertex(i,e){const t=e.editGeometryOperations.data.parts[0],s=[];if(t.vertices.length<2)return s;const{view:n}=this,o=S(i,e.spatialReference,v,n),a=t.vertices.at(-1);m(a.leftSegment)&&this._checkForSnappingCandidate(1,s,a.leftSegment,a,a.leftSegment.leftVertex,i,o,e);const r=t.vertices[0];return m(r.rightSegment)&&this._checkForSnappingCandidate(2,s,r.rightSegment,r,r.rightSegment.rightVertex,i,o,e),s}snapExistingVertex(i,e){const t=[],s=e.vertexHandle;if(s.part.vertices.length<3)return t;const{view:n}=this,o=S(i,e.spatialReference,v,n),a=s.leftSegment,r=s.rightSegment;if(m(a==null?void 0:a.leftVertex.leftSegment)){const h=a.leftVertex.leftSegment;this._checkForSnappingCandidate(3,t,h,h.rightVertex,h.leftVertex,i,o,e)}if(m(r)&&m(r.rightVertex.rightSegment)){const h=r.rightVertex.rightSegment;this._checkForSnappingCandidate(3,t,h,h.leftVertex,h.rightVertex,i,o,e)}return t}_checkForSnappingCandidate(i,e,t,s,n,o,a,r){if(!m(t)||!this.edgeExceedsShortLineThreshold(t,r))return;const h=this.view,l=f(s.pos,h,r),c=f(n.pos,h,r);Ve(G,c,l,o,r,this._geodesicLengthMeasurementUtils),this._checkForSnappingCandidateAlongProjectedRay(i,e,c,l,G,o,a,r)}_checkForSnappingCandidateAlongProjectedRay(i,e,t,s,n,o,a,r){var w;const{spatialReference:h,pointer:l}=r,c=N(D,d(o),d(s)),g=$(n,c)/B(n),u=K(D,d(s),n,g),x=q(H(u[0],u[1],o[2]));if(T(a,S(x,h,v,this.view))>this.squaredProximityThreshold(l)||this.isVertical(x,s,r)||this.isVertical(s,t,r))return;const V=ce(M(),s,n,Math.sign(g));e.push(new oe({targetPoint:x,constraint:new ae(s,J(V)),previousVertex:t,otherVertex:s,otherVertexType:1,selfSnappingType:i,isDraped:((w=r.elevationInfo)==null?void 0:w.mode)==="on-the-ground"}))}}function Ve(p,i,e,t,s,n){ye(p,i,e,t,s,n)||_e(p,i,e)}function ye(p,i,e,t,{spatialReference:s},n){const o=C(i,e,s,s);if(o==null)return!1;const a=C(e,t,s,s);if(a==null)return!1;const r=Math.sign(A.shortestSignedDiff(o,a))*Math.PI*.5,h=z(o+r,"radians","geographic"),l=M(),c=n.geodesicDistance(e,t,s);return c!=null&&(Q(l,e,s,Z(c,"meters"),h,"geodesic"),de(p,l,e),!0)}function _e(p,i,e){const t=N(D,d(e),d(i));ge(p,t[1],-t[0],0)}const D=I(),G=M();class Le extends F{snapNewVertex(i,e){const t=e.editGeometryOperations.data.parts[0],s=[],n=t.vertices.length;if(e.editGeometryOperations.data.type!=="polygon"||n<2)return s;const{view:o}=this,a=t.vertices[0],r=t.vertices[n-1];if(r.leftSegment&&r.leftSegment.type!=="line"||r.rightSegment&&r.rightSegment.type!=="line")return s;const h=f(a.pos,o,e),l=f(r.pos,o,e);return this._processCandidateProposal(h,l,i,e,s),s}snapExistingVertex(i,e){var h,l;const t=[],s=e.vertexHandle,n=s.part;if(n.segments.length<2||e.editGeometryOperations.data.type==="polyline"&&(s.index===0||s.index===n.vertices.length-1)||((h=s.leftSegment)==null?void 0:h.type)!=="line"||((l=s.rightSegment)==null?void 0:l.type)!=="line")return t;const{view:o}=this,a=f(s.leftSegment.leftVertex.pos,o,e),r=f(s.rightSegment.rightVertex.pos,o,e);return this._processCandidateProposal(a,r,i,e,t),t}_processCandidateProposal(i,e,t,s,n){var u;if(!this.exceedsShortLineThreshold(i,e,s))return;const o=W(U,d(i),d(e),.5),a=.5*j(d(i),d(e)),r=he(U,d(t),o,a),h=q(H(r[0],r[1],t[2])),{spatialReference:l,pointer:c}=s,g=S(t,l,v,this.view);if(T(g,S(h,l,v,this.view))<this.squaredProximityThreshold(c)){if(this.isVertical(i,h,s)||this.isVertical(h,e,s))return;n.push(new le({targetPoint:h,point1:i,point2:e,isDraped:((u=s.elevationInfo)==null?void 0:u.mode)==="on-the-ground"}))}}}const U=I();let _=class extends X{constructor(p){super(p),this.updating=!1,this._snappers=new Y,this._domain=2}initialize(){this._snappers.push(new ve(this.view,this.options),new me(this.view,this.options,this.geodesicLengthMeasurementUtils),new we(this.view,this.options,this.geodesicLengthMeasurementUtils),new Le(this.view,this.options))}set options(p){this._set("options",p);for(const i of this._snappers)i.options=p}async fetchCandidates(p,i,e){if(!(i&this._domain&&this.options.effectiveSelfEnabled))return[];const t=[];for(const s of this._snappers.items)for(const n of s.snap(p,e))t.push(n);return se(p,t),t}};L([R({readOnly:!0})],_.prototype,"updating",void 0),L([R({constructOnly:!0})],_.prototype,"view",void 0),L([R({constructOnly:!0})],_.prototype,"geodesicLengthMeasurementUtils",void 0),L([R()],_.prototype,"options",null),_=L([te("esri.views.interactive.snapping.SelfSnappingEngine")],_);export{_ as SelfSnappingEngine};
