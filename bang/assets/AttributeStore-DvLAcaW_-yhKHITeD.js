import{W as $,N as K,E as k}from"./Utils-CYY0kXyb-BZKnUtTY.js";import{kL as P,ah as b,P as A,l as y,dC as Y,aM as q,kp as J,fK as Q,kW as X,dF as Z,cQ as tt,k8 as et,dG as rt}from"./index-BeTPrQ6f.js";import{j as x,u as l,B as it}from"./UpdateTracking2D-CIKx7GWt-CEE8vGb9.js";import{A as st,$ as nt}from"./ArcadeExpression-BGPPS6z--7N6gsB31.js";import{u as ot,T as at,G as ht,H as N,q as G}from"./FeatureStoreQueryAdapter-Bcw-trC6-Qchy735n.js";import{R as ut}from"./messages-DQ10DjvF-6kk0dzjG.js";import"./UnknownTimeZone-DzO8gKMe-d6rtFXqm.js";import{i as ct}from"./labelUtils-BLNYRrPe-Cv1ZZjAO.js";import{J as lt,Q as W}from"./utils-CIm5uQvO-CtKf129F.js";import{C as dt}from"./diffUtils-D3O4EfgX-CznKxD4n.js";import{W as _t,v as E}from"./definitions-DVO21zOC-BwakNu1s.js";import{i as ft}from"./constants-CWFGCPkc-B_3x8_48.js";import{c as j}from"./memoryEstimations-C_GUL8g_-JniNFd5l.js";import{A as pt}from"./queryUtils-BwthgOFW-CkUF_Za8.js";import{r as yt,o as mt}from"./timeSupport-BnWHpO95-DqCdiJEC.js";import{b as gt}from"./Query-DKLDaFaA-I4zhlfzt.js";import{N as w}from"./enums-DDJfd4_p-D3z9tmVA.js";const xt=1.25;let T=class{get length(){return this._pos}constructor(t,e){this._pos=0;const r=e?this._roundToNearest(e,t.BYTES_PER_ELEMENT):40;this._array=new ArrayBuffer(r),this._buffer=new t(this._array),this._ctor=t,this._i16View=new Int16Array(this._array)}_roundToNearest(t,e){const r=Math.round(t);return e===1?r:r+(e-r%e)}_ensureSize(t){if(this._pos+t>=this._buffer.length){const e=this._roundToNearest((this._array.byteLength+t*this._buffer.BYTES_PER_ELEMENT)*xt,this._buffer.BYTES_PER_ELEMENT),r=new ArrayBuffer(e),i=new this._ctor(r);i.set(this._buffer,0),this._array=r,this._buffer=i,this._i16View=new Int16Array(this._array)}}ensureSize(t){this._ensureSize(t)}writeF32(t){this._ensureSize(1);const e=this._pos;return new Float32Array(this._array,4*this._pos,1)[0]=t,this._pos++,e}push(t){this._ensureSize(1);const e=this._pos;return this._buffer[this._pos++]=t,e}writeFixed(t){this._buffer[this._pos++]=t}setValue(t,e){this._buffer[t]=e}i1616Add(t,e,r){this._i16View[2*t]+=e,this._i16View[2*t+1]+=r}getValue(t){return this._buffer[t]}getValueF32(t){return new Float32Array(this._array,4*t,1)[0]}incr(t){if(this._buffer.length<t)throw new Error("Increment index overflows the target buffer");this._buffer[t]++}decr(t){this._buffer[t]--}writeRegion(t){this._ensureSize(t.length);const e=this._pos;return this._buffer.set(t,this._pos),this._pos+=t.length,e}writeManyFrom(t,e,r){this._ensureSize(r-e);for(let i=e;i!==r;i++)this.writeFixed(t._buffer[i])}buffer(){const t=this._array.slice(0,4*this._pos);return this.destroy(),t}toArray(){return[...this._buffer]}seek(t){this._pos=t}destroy(){this._array=null,this._buffer=null}};const It=6,wt=4;let bt=class{constructor(t,e,r=0){const i=It*r*Uint32Array.BYTES_PER_ELEMENT,s=wt*r*e.stride,n=e.stride/4,o=e.attributes.find(a=>a.name==="pos"||a.name==="position");if(!o)throw new Error("InternalError: Unable to find position attribute");this.layout={...e,position:o},this._indices=new T(Uint32Array,i),this._vertices=new T(Uint32Array,s),this._metrics=new T(Uint32Array,0),this._metricCountOffset=this._metrics.push(0),this._strideInt=n,this._instanceId=t}serialize(t){const e=this._indices.buffer(),r=this._vertices.buffer(),i=this._metrics.length?this._metrics.buffer():null;return t.push(e,r),{instanceId:this._instanceId,layout:this.layout,indices:e,vertices:r,metrics:i}}get strideInt(){return this._strideInt}get vertexCount(){return this._vertices.length/this._strideInt}get indexCount(){return this._indices.length}get indexWriter(){return this._indices}get vertexWriter(){return this._vertices}get metricWriter(){return this._metrics}vertexEnsureSize(t){this._vertices.ensureSize(t)}indexEnsureSize(t){this._indices.ensureSize(t)}writeIndex(t){this._indices.push(t)}writeVertex(t){this._vertices.push(t)}writeVertexRegion(t){this._vertices.writeRegion(t)}writeVertexF32(t){this._vertices.writeF32(t)}writeMetric(t){this._metrics.incr(this._metricCountOffset),t.serialize(this._metrics)}},re=class{constructor(t,e=0){this._id=t,this._sizeHint=e,this._entityRecordCountOffset=0,this._entityCountOffset=0,this._entityIdIndex=0,this._entitySortKeyIndex=0,this._didEntityStart=!1,this._instanceIdToVertexData=new Map,this._recordIndexStart=0,this._recordIndexCount=0,this._recordVertexStart=0,this._recordVertexCount=0,this._current={metric:null,writer:null,start:0,sortKey:0,instanceId:0,layoutHash:0,indexStart:0,vertexStart:0,textureKey:0,metricBoxLenPointer:0},this._entities=new T(Uint32Array,this._sizeHint*K.byteSizeHint),this._entityCountOffset=this._entities.push(0)}get id(){return this._id}serialize(){const t=new Array,e=[],r=this._entities.buffer();for(const i of this._instanceIdToVertexData.values())e.push(i.serialize(t));return{message:{data:e,entities:r},transferList:t}}vertexStart(){return this._current.vertexStart??0}vertexCount(){var t;return((t=this._current.writer)==null?void 0:t.vertexCount)??0}indexCount(){var t;return((t=this._current.writer)==null?void 0:t.indexCount)??0}vertexEnsureSize(t){this._current.writer.vertexEnsureSize(t)}indexEnsureSize(t){this._current.writer.indexEnsureSize(t)}vertexWrite(t){this._current.writer.writeVertex(t)}vertexWriteRegion(t){this._current.writer.writeVertexRegion(t)}vertexWriteF32(t){this._current.writer.writeVertexF32(t)}recordBounds(t,e,r,i){}indexWrite(t){this._current.writer.writeIndex(t)}metricStart(t){this._current.metric=t,this._current.metric.recordStart=this.recordCount()}metricEnd(){var e,r;const t=this._current.writer;this._current.metric&&(this._current.metric.recordCount=this.recordCount()-this._current.metric.recordStart),(e=this._current.metric)!=null&&e.bounds.length&&((r=this._current.metric)!=null&&r.recordCount)?(t.writeMetric(this._current.metric),this._current.metric=null):this._current.metric=null}metricBoxWrite(t){this._current.metric.bounds.push(t)}entityStart(t,e=t){this._entityIdIndex=this._entities.push(t),this._entitySortKeyIndex=this._entities.writeF32(e),this._entityRecordCountOffset=this._entities.push(0),this._didEntityStart=!0}entityRecordCount(){return this._entities.getValue(this._entityRecordCountOffset)}entityEnd(){this._didEntityStart&&(this.entityRecordCount()===0?this._entities.seek(this._entityIdIndex):this._entities.incr(this._entityCountOffset),this._didEntityStart=!1)}recordCount(){return this._entities.getValue(this._entityRecordCountOffset)}recordStart(t,e,r=0){this._current.writer=this._getVertexWriter(t,e),this._current.indexStart=this._current.writer.indexCount,this._current.vertexStart=this._current.writer.vertexCount,this._current.instanceId=t,this._current.layoutHash=e.hash,this._current.textureKey=r}recordEnd(t=0){const e=this._current.vertexStart,r=this._current.writer.vertexCount-e;if(!r)return!1;const i=this._current.indexStart,s=this._current.writer.indexCount-i;return this._recordIndexStart=i,this._recordIndexCount=s,this._recordVertexStart=e,this._recordVertexCount=r,this._entities.incr(this._entityRecordCountOffset),k.write(this._entities,this._current.instanceId,this._current.textureKey,i,s,e,r,t),!0}copyLast(t,e){const r=this._recordVertexStart+this._recordVertexCount;this._entities.incr(this._entityRecordCountOffset),k.write(this._entities,this._current.instanceId,this._current.textureKey,this._recordIndexStart+this._recordIndexCount,this._recordIndexCount,r,this._recordVertexCount,0);const i=this._current.writer.indexWriter,s=this._current.writer.vertexWriter,n=this._recordIndexStart+this._recordIndexCount,o=this._recordVertexCount;for(let c=this._recordIndexStart;c!==n;c++){const u=i.getValue(c);i.push(u+o)}const a=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,h=this._recordVertexStart*a,_=(this._recordVertexStart+this._recordVertexCount)*a;for(let c=h;c!==_;c++){const u=s.getValue(c);s.push(u)}const f=this._current.writer.layout.position,p=f.packPrecisionFactor??1,m=f.offset/Uint32Array.BYTES_PER_ELEMENT,I=t*p,d=e*p;for(let c=r*a;c<=s.length;c+=a)s.i1616Add(c+m,I,d)}copyLastFrom(t,e,r){const i=t._entities.getValue(t._entityIdIndex);if(i!==this._entities.getValue(this._entityIdIndex)){const u=t._entities.getValueF32(t._entitySortKeyIndex);this.entityStart(i,u)}this.recordStart(t._current.instanceId,t._current.writer.layout,t._current.textureKey);const s=this._current.writer.layout.stride/Uint32Array.BYTES_PER_ELEMENT,n=this._current.vertexStart,o=t._current.vertexStart-n,a=this._current.writer.indexWriter,h=this._current.writer.vertexWriter,_=t._current.writer.indexWriter,f=t._current.writer.vertexWriter;for(let u=t._current.indexStart;u!==_.length;u++){const v=_.getValue(u);a.push(v-o)}for(let u=t._current.vertexStart*s;u!==f.length;u++){const v=f.getValue(u);h.push(v)}const p=this._current.writer.layout.position,m=p.packPrecisionFactor??1,I=p.offset/Uint32Array.BYTES_PER_ELEMENT,d=e*m,c=r*m;for(let u=n*s;u<=h.length;u+=s)h.i1616Add(u+I,d,c);this.recordEnd()}_getVertexWriter(t,e){const r=this._instanceIdToVertexData;return r.has(t)||r.set(t,new bt(t,e,this._sizeHint)),r.get(t)}};function St(t){return"url"in t&&"urlHash"in t?{...t,url:""}:t}let Et=class{},ie=class extends Et{constructor(t){super(),this._fetcher=t,this._controller=new AbortController,this._pendingIds=new Set,this._pendingRequests=[],this._resourceIdToResource=new Map}destroy(){this._controller.abort()}get _abortOptions(){return{signal:this._controller.signal}}enqueueRequest(t){const e=St(t.resource),r=P(JSON.stringify(e));return this._pendingIds.has(r)||(this._pendingIds.add(r),this._pendingRequests.push({...t,resourceId:r})),r}async fetchEnqueuedResources(){const t=this._pendingRequests;if(this._pendingIds.clear(),this._pendingRequests=[],t.length===0)return;const e=await this._fetcher.fetch(t,this._abortOptions);for(let r=0;r<e.length;r++){const i=t[r].resourceId;this._resourceIdToResource.set(i,e[r])}}async fetchResourceImmediate(t){const e=await this._fetcher.fetch([t]);if(e.length!==1)throw new Error("FeaturePipelineResourceProxy: failed to fetch resources");return e[0]}async fetchDictionaryResourceImmediate(t){const e=await this._fetcher.fetchDictionary([t]);if(e.length!==1)throw new Error("FeaturePipelineResourceProxy: failed to fetch dictionary resources");return e[0]}getResource(t){return this._resourceIdToResource.get(t)}},S=class{destroy(){}},Ct=class extends S{constructor(t){super(),this._field=t}resize(t){throw new Error("Method not implemented.")}read(t,e){return t.readAttribute(this._field)}readWithDefault(t,e){return t.readAttribute(this._field)}hasArcadeDependency(t){return!1}};function Tt(t,e){const r=43758.5453*Math.sin(12.9898*t+78.233*e);return r-Math.floor(r)}class B extends S{static async create(e,r){const i=await nt(e,r.spatialReference),s=P(e);return new B(i,s)}constructor(e,r){super(),this._compiled=e,this._cacheKey=r}resize(e){}read(e,r){return this.hasArcadeDependency("scale")||r.$view.timeZone!=="system"?N(this._compiled,e,r):this._readCached(e,r)}readWithDefault(e,r,i){return this.hasArcadeDependency("scale")||r.$view.timeZone!=="system"?G(this._compiled,e,r,i):this._readWithDefaultCached(e,r,i)}hasArcadeDependency(e){var r;return((r=this._compiled)==null?void 0:r.references(e))??!1}_getCacheKey(e){var s;if(!((s=this._compiled)!=null&&s.references("timeProperties")))return this._cacheKey;const{currentStart:r,currentEnd:i}=e.$view.timeProperties;return this._cacheKey+Tt(r??1,i??1)}_readCached(e,r){if(e.setCache(this._getCacheKey(r)),e.hasCachedValue())return e.getCachedValue();const i=N(this._compiled,e,r);return e.setCachedValue(i),i}_readWithDefaultCached(e,r,i){if(e.setCache(this._getCacheKey(r)),e.hasCachedValue())return e.getCachedValue();const s=G(this._compiled,e,r,i);return e.setCachedValue(s),s}}function zt(t,e){if(t==null)return"";const r=e.domain;if(r){if(r.type==="codedValue"||r.type==="coded-value"){const s=t;for(const n of r.codedValues)if(n.code===s)return n.name}else if(r.type==="range"){const{max:s,min:n}=X(e),o=+t;if(n!=null&&s!=null&&n<=o&&o<=s)return r.name}}let i=t;return Z(e)?i=tt(i,et("short-date")):rt(e)&&(i=ut(+i)),i||""}let At=class U extends S{static async create(e,r){const i=ct(e);return new U(s=>i.replaceAll(/{[^}]*}/g,n=>{const o=n.slice(1,-1),a=s.metadata.fieldsIndex.get(o);if(a==null)return n;const h=s.readAttribute(o);return h==null?"":zt(h,a)}))}constructor(e){super(),this._evaluator=e}resize(e){}read(e,r){return this._evaluator(e)}readWithDefault(e,r,i){const s=this._evaluator(e);return ht(s)?i:s}hasArcadeDependency(e){return!1}},vt=class extends S{constructor(t,e){super(),this._template=t,this._parts=lt(t.template,e)}resize(t){}read(t,e){return W(t,this._parts,this._template.textCase)}readWithDefault(t,e,r){return W(t,this._parts,this._template.textCase)}hasArcadeDependency(t){return!1}},Ft=class extends S{constructor(t,e){super(),this._field=t,this._normalizationInfo=e}resize(t){throw new Error("Method not implemented.")}read(t,e){return this._readNormalized(t)}readWithDefault(t,e){return this._readNormalized(t)}hasArcadeDependency(t){return!1}_readNormalized(t){const e=t.readAttribute(this._field);if(e==null)return null;const{normalizationField:r,normalizationTotal:i,normalizationType:s}=this._normalizationInfo,n=t.readAttribute(r);switch(s??"esriNormalizeByField"){case"esriNormalizeByField":return n?n?e/n:void 0:null;case"esriNormalizeByLog":return Math.log(e)*Math.LOG10E;case"esriNormalizeByPercentOfTotal":return i?e/i*100:null}}};const F=()=>A.getLogger("esri.views.2d.layers.FeatureLayerView2D"),Dt={getAttribute:(t,e)=>t.readAttribute(e)};async function H(t,e){try{const r=await Q(t,e);return r.isStandardized||F().error(new y("sql-parse-error","expression is not standardized",{where:t})),(i,s)=>{const n=i.readArcadeFeature();try{return r.testFeatureCompiled(n,Dt,s.currentUser)}catch(o){return F().warn(new y("sql-runtime-error","Encountered an error when evaluating where clause",{where:t,error:o})),!0}}}catch(r){return F().warn(new y("sql-runtime-error","Encountered an error when evaluating where clause",{where:t,error:r})),i=>!0}}const L=()=>A.getLogger("esri.views.2d.layers.features.support.ComputedAttributeStorage"),g=4294967295;function C(t,e,r){if(!(t.length>e))for(;t.length<=e;)t.push(r)}let se=class{constructor(t){this._numerics=[],this._strings=[],this._allocatedSize=256,this._bitsets=[],this._instanceIds=[],this._bounds=[],this._dirtyBitset=this.getBitset(this.createBitset()),this.compilationOptions=t}createBitset(){const t=this._bitsets.length;return this._bitsets.push(ot.create(this._allocatedSize,l)),t+1}createDictionaryTemplateField(t,e){return new vt(t,e)}async createComputedField(t,e=!1){if(t.expression)try{if(!this.compilationOptions)throw new Error("InternalError: Compilation options not defined");return e?await At.create(t.expression,this.compilationOptions):await B.create(t.expression,this.compilationOptions)}catch(i){const s=new y("featurelayer","Failed to compile arcade expression",{error:i,expression:t.expression});return L().error(s),null}if(t.normalizationType||t.normalizationField)return new Ft(t.field,t);if(t.field)return new Ct(t.field);const r=new y("featurelayer","Unable to create computed field. No expression or field found",{info:t});return L().error(r),null}async createWhereClause(t){return t?H(t,this.compilationOptions.fields):null}getBitset(t){return this._bitsets[t-1]}getComputedNumeric(t,e){return this.getComputedNumericAtIndex(t&l,0)}setComputedNumeric(t,e,r){return this.setComputedNumericAtIndex(t&l,r,0)}getComputedString(t,e){return this.getComputedStringAtIndex(t&l,0)}setComputedString(t,e,r){return this.setComputedStringAtIndex(t&l,0,r)}getComputedNumericAtIndex(t,e){const r=t&l;return this._ensureNumeric(e,r),this._numerics[e][r]}setComputedNumericAtIndex(t,e,r){const i=t&l;this._ensureNumeric(e,i),this._numerics[e][i]=r}getPackedChunkId(t){const e=t&l;return this._ensureInstanceId(e),this._instanceIds[e]}setPackedChunkId(t,e){const r=t&l;this._ensureInstanceId(r),this._instanceIds[r]=e}getComputedStringAtIndex(t,e){const r=t&l;return this._ensureString(e,r),this._strings[e][r]}setComputedStringAtIndex(t,e,r){const i=t&l;this._ensureString(e,i),this._strings[e][i]=r}getXMin(t){return this._bounds[4*(t&l)]}getYMin(t){return this._bounds[4*(t&l)+1]}getXMax(t){return this._bounds[4*(t&l)+2]}getYMax(t){return this._bounds[4*(t&l)+3]}setBounds(t,e,r=!1){const i=t&l;if(!r&&!this._dirtyBitset.has(t))return this._bounds[4*i]!==g;this._dirtyBitset.unset(t);const s=e.readGeometryWorldSpace();if(C(this._bounds,4*i+4,0),!s||!s.coords.length)return this._bounds[4*i]=g,this._bounds[4*i+1]=g,this._bounds[4*i+2]=g,this._bounds[4*i+3]=g,!1;let n=1/0,o=1/0,a=-1/0,h=-1/0;return s.forEachVertex((_,f)=>{n=Math.min(n,_),o=Math.min(o,f),a=Math.max(a,_),h=Math.max(h,f)}),this._bounds[4*i]=n,this._bounds[4*i+1]=o,this._bounds[4*i+2]=a,this._bounds[4*i+3]=h,!0}getBounds(t,e){const r=this.getXMin(e),i=this.getYMin(e),s=this.getXMax(e),n=this.getYMax(e);return Y(t,r,i,s,n),r!==g}_ensureNumeric(t,e){this._numerics[t]||(this._numerics[t]=[]),C(this._numerics[t],e,0)}_ensureInstanceId(t){C(this._instanceIds,t,0)}_ensureString(t,e){this._strings[t]||(this._strings[t]=[]),C(this._strings[t],e,null)}};const D=1,Mt=2;class R{constructor(e){this._geometryBounds=q(),this._idToVisibility=new Map,this._serviceInfo=e}static async create(e){const r=new R(e);return await r.update(e.filterJSON,e.spatialReference),r}get hash(){return this._hash}check(e,r){return this._applyFilter(e,r)}invalidate(){this._idToVisibility.forEach((e,r)=>{this._idToVisibility.set(r,0)})}setKnownIds(e){for(const r of e)this._idToVisibility.set(r,D)}setTrue(e){const r=[],i=[],s=new Set(e);return this._idToVisibility.forEach((n,o)=>{const a=!!(this._idToVisibility.get(o)&D),h=s.has(o);!a&&h?r.push(o):a&&!h&&i.push(o),this._idToVisibility.set(o,h?D|Mt:0)}),{show:r,hide:i}}createQuery(){const{geometry:e,spatialRel:r,where:i,timeExtent:s,objectIds:n}=this;return gt.fromJSON({geometry:e,spatialRel:r,where:i,timeExtent:s,objectIds:n})}async update(e,r){this._hash=JSON.stringify(e);const i=await pt(e,null,r);await Promise.all([this._setGeometryFilter(i),this._setIdFilter(i),this._setAttributeFilter(i),this._setTimeFilter(i)])}async _setAttributeFilter(e){if(!(e!=null&&e.where))return this._clause=null,void(this.where=null);this._clause=await H(e.where,this._serviceInfo.fieldsIndex),this.where=e.where}_setIdFilter(e){this._idsToShow=(e==null?void 0:e.objectIds)&&new Set(e.objectIds),this._idsToHide=(e==null?void 0:e.hiddenIds)&&new Set(e.hiddenIds),this.objectIds=e==null?void 0:e.objectIds}async _setGeometryFilter(e){if(!(e!=null&&e.geometry))return this._spatialQueryOperator=null,this.geometry=null,void(this.spatialRel=null);const r=e.geometry,i=e.spatialRel??"esriSpatialRelIntersects",s=await yt(i,r,this._serviceInfo.geometryType,this._serviceInfo.hasZ,this._serviceInfo.hasM);J(this._geometryBounds,r),this._spatialQueryOperator=s,this.geometry=r,this.spatialRel=i}_setTimeFilter(e){if(this.timeExtent=this._timeOperator=null,e==null?void 0:e.timeExtent){if(!this._serviceInfo.timeInfo){const r=new y("feature-layer-view:time-filter-not-available","Unable to apply time filter, as layer doesn't have time metadata.",e.timeExtent);return void A.getLogger("esri.views.2d.layers.features.controllers.FeatureFilter").error(r)}this.timeExtent=e.timeExtent,this._timeOperator=mt(this._serviceInfo.timeInfo,e.timeExtent,at.Shared)}}_applyFilter(e,r){return this._filterByGeometry(e)&&this._filterById(e)&&this._filterByTime(e)&&this._filterByExpression(e,r)}_filterByExpression(e,r){return!this.where||this._clause(e,r)}_filterById(e){var r,i;return(!((r=this._idsToHide)!=null&&r.size)||!this._idsToHide.has(e.getObjectId()))&&(!((i=this._idsToShow)!=null&&i.size)||this._idsToShow.has(e.getObjectId()))}_filterByGeometry(e){if(!this.geometry)return!0;const r=e.readGeometryWorldSpace();return!!r&&this._spatialQueryOperator(r)}_filterByTime(e){return this._timeOperator==null||this._timeOperator(e)}}const Bt=(t,e)=>t&&((...r)=>e.warn("DEBUG:",...r))||(()=>null),Rt=!1,O=class O{constructor(e){this.data=e,this._referenceCount=0}increment(){this._referenceCount+=1}decrement(){this._referenceCount-=1}empty(){return this._referenceCount===0}};O.estimatedMemory=20;let z=O;class Vt{constructor(){this._freeIdsGenerationA=[],this._freeIdsGenerationB=[],this._idCounter=1,this._freeIds=this._freeIdsGenerationA,this._objectIdToDisplayId=new Map}get usedMemory(){let e=0;return e+=j(this._freeIdsGenerationA),e+=j(this._freeIdsGenerationB),e+=this._objectIdToDisplayId.size*(z.estimatedMemory+8),e}createIdForObjectId(e){let r=this._objectIdToDisplayId.get(e);return r?r.increment():(r=new z(it(this._getFreeId(),!1)),r.increment(),this._objectIdToDisplayId.set(e,r)),r.data}releaseIdForObjectId(e){const r=this._objectIdToDisplayId.get(e);r&&(r.decrement(),r.empty()&&(this._objectIdToDisplayId.delete(e),this._freeIds.push(r.data)))}getDisplayIdForObjectId(e){const r=this._objectIdToDisplayId.get(e);return r!=null?r.data:null}releaseAll(){for(const e of this._objectIdToDisplayId.values())this._freeIds.push(e.data);this._objectIdToDisplayId.clear()}incrementGeneration(){this._freeIds=this._freeIds===this._freeIdsGenerationA?this._freeIdsGenerationB:this._freeIdsGenerationA}_getFreeId(){return this._freeIds.length?this._freeIds.pop():this._idCounter++}}function Ot(t,e){if(!t||!e)return t;switch(e){case"radius":case"distance":return 2*t;case"diameter":case"width":return t;case"area":return Math.sqrt(t)}return t}const V=()=>A.getLogger("esri.views.layers.2d.features.support.AttributeStore"),M=Bt(Rt,V()),kt={sharedArrayBuffer:b("esri-shared-array-buffer"),atomics:b("esri-atomics")};class Nt{constructor(e,r,i){this.size=0,this.texelSize=4,this.dirtyStart=0,this.dirtyEnd=0;const{pixelType:s,layout:n,textureOnly:o}=r;this.textureOnly=o||!1,this.pixelType=s,this.layout=n,this._resetRange(),this.size=e,this.isLocal=i,o||(this.data=this._initData(s,e))}get usedMemory(){var e;return((e=this.data)==null?void 0:e.byteLength)??0}get buffer(){var e;return(e=this.data)==null?void 0:e.buffer}unsetComponentAllTexels(e,r){const i=this.data;for(let s=0;s<this.size*this.size;s++)i[s*this.texelSize+e]&=~r;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponentAllTexels(e,r){const i=this.data;for(let s=0;s<this.size*this.size;s++)i[s*this.texelSize+e]|=255&r;this.dirtyStart=0,this.dirtyEnd=this.size*this.size-1}setComponent(e,r,i){const s=this.data;for(const n of i)s[n*this.texelSize+e]|=r,this.dirtyStart=Math.min(this.dirtyStart,n),this.dirtyEnd=Math.max(this.dirtyEnd,n)}setComponentTexel(e,r,i){this.data[i*this.texelSize+e]|=r,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}unsetComponentTexel(e,r,i){this.data[i*this.texelSize+e]&=~r,this.dirtyStart=Math.min(this.dirtyStart,i),this.dirtyEnd=Math.max(this.dirtyEnd,i)}getData(e,r){const i=x(e);return this.data[i*this.texelSize+r]}setData(e,r,i){const s=x(e),n=1<<r;this.layout&n?this.data!=null&&(this.data[s*this.texelSize+r]=i,this.dirtyStart=Math.min(this.dirtyStart,s),this.dirtyEnd=Math.max(this.dirtyEnd,s)):V().error("mapview-attributes-store","Tried to set a value for a texel's readonly component")}expand(e){if(this.size=e,!this.textureOnly){const r=this._initData(this.pixelType,e),i=this.data;r.set(i),this.data=r}}toMessage(){const e=this.dirtyStart,r=this.dirtyEnd,i=this.texelSize;if(e>r)return null;this._resetRange();const s=!this.isLocal,n=this.pixelType,o=this.layout,a=this.data;return{start:e,end:r,data:s&&a.slice(e*i,(r+1)*i)||null,pixelType:n,layout:o}}_initData(e,r){const i=ArrayBuffer,s=$(e),n=new s(new i(r*r*4*s.BYTES_PER_ELEMENT));for(let o=0;o<n.length;o+=4)n[o+1]=255;return n}_resetRange(){this.dirtyStart=2147483647,this.dirtyEnd=0}}let ne=class{constructor(t){this._client=t,this._filters=[],this._blocks=new Array,this._attributeComputeInfo=null,this._abortController=new AbortController,this._size=_t,this._idsToHighlight=new Map,this._arcadeDependencies=new Set,this._initialized=!1,this.version=0,this._idGenerator=new Vt,this._epoch=1}destroy(){this._abortController.abort()}_initialize(){if(this._blockDescriptors!=null)return;const t=w.FLOAT;M(`Creating AttributeStore ${kt.sharedArrayBuffer?"with":"without"} shared memory`),this._blockDescriptors=[{pixelType:w.UNSIGNED_BYTE,layout:1},{pixelType:w.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:w.UNSIGNED_BYTE,layout:15,textureOnly:!0},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:t,layout:15},{pixelType:w.FLOAT,layout:15}],this._blocks=this._blockDescriptors.map(()=>null)}get usedMemory(){let t=0;for(const e of this._blocks)e&&(t+=e.usedMemory);return t+=this._idGenerator.usedMemory,t}get hasHighlight(){return this._idsToHighlight.size>0}createDisplayIdForObjectId(t){return this._idGenerator.createIdForObjectId(t)}releaseDisplayIdForObjectId(t){return this._idGenerator.releaseIdForObjectId(t)}getDisplayIdForObjectId(t){return this._idGenerator.getDisplayIdForObjectId(t)}incrementDisplayIdGeneration(){this._idGenerator.incrementGeneration()}hasArcadeDependency(t){return this._arcadeDependencies.has(t)}releaseAllIds(){this._idGenerator.releaseAll()}async update(t,e,r,i=0){const s=dt(this._schema,t);if(this.version=i,s&&(b("esri-2d-update-debug")&&console.debug(`Version[${i}] AttributeStore.update`,{changed:s}),this._schema=t,this._attributeComputeInfo=null,this._initialize(),t!=null))if(r&&(this._filters=await Promise.all(t.filters.map(n=>n?R.create({geometryType:r.geometryType,hasM:!1,hasZ:!1,timeInfo:r.timeInfo,fieldsIndex:r.fieldsIndex,spatialReference:r.outSpatialReference,filterJSON:n}):null))),t.type!=="multi")this._attributeComputeInfo={type:"feature",map:new Map},await Promise.all(t.bindings.map(async n=>{const o=await this._bind(e,n);this._updateReferences(o)}));else{this._attributeComputeInfo={type:"multi",keyField:t.keyField,map:new Map};for(const n in t.bindings){const o=t.bindings[n];await Promise.all(o.map(async a=>{const h=await this._bind(e,a,parseInt(n,10));this._updateReferences(h)}))}}}setHighlight(t,e){let r=null;t.length===0&&e.length===0&&(r=this._getBlock(0),r.unsetComponentAllTexels(0,(1<<E)-1));for(const{displayId:i,highlightFlags:s}of t){if(i==null||i===-1)continue;r||(r=this._getBlock(0),r.unsetComponentAllTexels(0,(1<<E)-1));const n=x(i);r.setComponent(0,s,[n])}this._idsToHighlight.clear();for(const{objectId:i,highlightFlags:s}of t)this._idsToHighlight.set(i,s);for(const{objectId:i,highlightFlags:s}of e)this._idsToHighlight.set(i,s)}setData(t,e,r,i){const s=x(t);this._ensureSizeForTexel(s),this._getBlock(e).setData(t,r,i)}getData(t,e,r){return this._getBlock(e).getData(t,r)}getHighlightFlags(t){return this._idsToHighlight.get(t)||0}unsetAttributeData(t){const e=x(t);this._getBlock(0).setData(e,0,0)}referencesScale(){const t=this._attributeComputeInfo;if(!t)return!1;if(t.type==="multi"){for(const e of t.map.values())for(const{field:r}of e.values())if(r!=null&&r.hasArcadeDependency("scale"))return!0}else for(const{field:e}of t.map.values())if(e!=null&&e.hasArcadeDependency("scale"))return!0;return!1}setAttributeData(t,e,r,i){const s=x(t);this._ensureSizeForTexel(s),this._getBlock(0).setData(s,0,this.getFilterFlags(e,i));const n=this._attributeComputeInfo,o=1,a=4;let h=null;n&&(h=n.type==="multi"?n.map.get(e.readAttribute(n.keyField)):n.map,h!=null&&h.size&&h.forEach((_,f)=>{var c;const p=f*o%a,m=Math.floor(f*o/a),I=this._getBlock(m+3);let d=(c=_.field)==null?void 0:c.read(e,r);_.valueRepresentation&&(d=Ot(d,_.valueRepresentation)),(d===null||isNaN(d)||d===1/0||d===-1/0)&&(d=ft),I.setData(s,p,d)}))}get epoch(){return this._epoch}sendUpdates(){const t=this._blocks.map(r=>r!=null?r.toMessage():null),e=this._getInitArgs();b("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.start"),this._client.update({initArgs:e,blockData:t,version:this.version,sendUpdateEpoch:this._epoch}),this._epoch+=1,b("esri-2d-log-updating")&&console.log("AttributeStore: _doSendUpdate.end")}_ensureSizeForTexel(t){for(;t>=this._size*this._size;)if(this._expand())return}async _bind(t,e,r){const i=await t.createComputedField(e),{valueRepresentation:s}=e,n=this._attributeComputeInfo;if(n.type==="multi"){const o=n.map.get(r)??new Map;o.set(e.binding,{field:i,valueRepresentation:s}),n.map.set(r,o)}else n.map.set(e.binding,{field:i,valueRepresentation:s});return i}_getInitArgs(){return this._initialized?null:(this._initialized=!0,this._getBlock(1),this._getBlock(2),this._getBlock(7),{blockSize:this._size,blockDescriptors:this._blocks.map(t=>t!=null?{textureOnly:t.textureOnly,buffer:t.buffer,pixelType:t.pixelType}:null)})}_getBlock(t){const e=this._blocks[t];if(e!=null)return e;M(`Initializing AttributeBlock at index ${t}`);const r=new Nt(this._size,this._blockDescriptors[t],this._client.isLocal);return this._blocks[t]=r,this._initialized=!1,r}_expand(){if(this._size<this._schema.capabilities.maxTextureSize){const t=this._size<<=1;M("Expanding block size to",t,this._blocks);for(const e of this._blocks)e==null||e.expand(t);return this._initialized=!1,this._size=t,0}return V().error(new y("mapview-limitations","Maximum number of onscreen features exceeded.")),-1}_updateReferences(t){st(this._arcadeDependencies,t)}isVisible(t){return!!(this._getBlock(0).getData(t,0)&1<<E)}getFilterFlags(t,e){let r=0;for(let s=0;s<this._filters.length;s++){const n=!!(1<<s),o=this._filters[s];r|=(!n||o==null||o.check(t,e)?1:0)<<s}let i=0;if(this._idsToHighlight.size){const s=t.getObjectId();i=this.getHighlightFlags(s)}return r<<E|i}};export{R as A,ie as C,ne as L,se as M,re as S,St as a,S as x};
