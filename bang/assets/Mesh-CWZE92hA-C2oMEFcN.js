const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["./loadGLTFMesh-D51AmJU4-DE4--Qpr.js","./index-BeTPrQ6f.js","./index-BlWAJbpo.css","./vec4f64-DD-nkcCV-CSNWKRqG.js","./MeshComponent-BEAtZpvD-CC9545AO.js","./imageUtils-DITyjHV4-jEv5aA2D.js","./meshProperties-CXB3HhQQ-DyV7lL-U.js","./MeshVertexAttributes-SXUaA7ll-eeFzs1Wm.js","./meshVertexSpaceUtils-EbHpWZGf-CmRuaT8m.js","./vec32-CI1xtKog-DFVYRcgb.js","./MeshLocalVertexSpace-CxmyTFZH-DhgfYuby.js","./BufferView-B6RYETl3-CMoUTBv6.js","./vec42-DHp-FUwt-Br7hmYJs.js","./vec2f64-CkowXrDb-3zFQ3LNH.js","./vec3-DXB2oTmo-oxnUpQ4G.js","./vec4-Dua3dSaz-Cy3KWGYf.js","./types-l27bT09Q-DE0QfIFp.js","./loader-DBZkumMs-DVPW5nve.js","./Version-DSJSGSLA-Cg87msWM.js","./mat4-R0VY9B_E-DoEP887i.js","./quat-B6H0knG8-DtO1-hlf.js","./quatf64-C16JxGFv-BKWK1F8U.js","./resourceUtils-DV37Keuk-D9tOd5yM.js","./enums-DDJfd4_p-D3z9tmVA.js","./indexUtils-BOzySSm0-n6TMq205.js","./asyncUtils-Cu__bxqs-ecCTUaGV.js","./Indices-CAn-HCVv-hWNN5onC.js","./vertexSpaceConversion-okU9QrPr-BoK2nOGp.js","./spatialReferenceEllipsoidUtils-Ty3j4VoE-BUAsRqCF.js","./computeTranslationToOriginAndRotation-CsOb5S2S-CE5ZgVBy.js","./projectBuffer-CMNsPBq1-CMpE7Jo3.js","./projectPointToVector-BHS0gJJf-DOVZH8Fn.js","./projectionUtils-CsX1UTBu-DsZaU4xz.js","./zscale-PLuFqpaL-BIEnWBsg.js","./gltfexport-CqOJ7XCw-AjUCc5yW.js"])))=>i.map(i=>d[i]);
import{bo as nt,fn as it,cI as at,b5 as lt,as as ct,kg as ut,ny as ie,nz as pt,B as O,P as _,i4 as ae,_ as le,N as oe,C as ft,aS as Me,l as z,bJ as ht,a7 as mt,bc as dt,nA as gt,mn as ge,F as xt,d8 as yt,eq as w,lH as vt,cF as wt,is as se,kF as bt,ir as Le,lg as ne,cq as At,dU as St,gx as Rt,aL as _t,i as Ft,V as Mt,m as d,E as g,n as Ee}from"./index-BeTPrQ6f.js";import{E as Lt,i as Oe,F as K,D as Pe,o as De}from"./axisAngleDegrees-StGk9lM5-YzC5iFyo.js";import{p as q}from"./MeshComponent-BEAtZpvD-CC9545AO.js";import{t as X,o as ce}from"./MeshLocalVertexSpace-CxmyTFZH-DhgfYuby.js";import{o as Y}from"./MeshTransform-DfLVYScT-Cq2gdNT7.js";import{o as Q}from"./MeshVertexAttributes-SXUaA7ll-eeFzs1Wm.js";import{m as Et,t as Z,x as ee,p as Ce}from"./meshVertexSpaceUtils-EbHpWZGf-CmRuaT8m.js";import{E as Ot}from"./triangulationUtils-BIEW4TIq-CnOT_xJp.js";import{_ as ue,O as $e,Y as pe,q as Pt,j as Dt,l as Ct,X as $t,E as Tt}from"./vec32-CI1xtKog-DFVYRcgb.js";import{n as E}from"./projectPointToVector-BHS0gJJf-DOVZH8Fn.js";import{L as fe,q as Te,y as x,o as ze,r as Ie,l as ke,a as Ue,e as je,u as Be,C as zt,P as D}from"./vertexSpaceConversion-okU9QrPr-BoK2nOGp.js";import{J as It}from"./projectionUtils-CsX1UTBu-DsZaU4xz.js";import{M as me}from"./spatialReferenceEllipsoidUtils-Ty3j4VoE-BUAsRqCF.js";import{T as Ge}from"./computeTranslationToOriginAndRotation-CsOb5S2S-CE5ZgVBy.js";import{o as kt}from"./projectBuffer-CMNsPBq1-CMpE7Jo3.js";import{b as xe,v as Ut}from"./vec3-DXB2oTmo-oxnUpQ4G.js";import{d as jt,x as Bt,f as J}from"./meshProperties-CXB3HhQQ-DyV7lL-U.js";import{N as ye,w as Gt,T as qt}from"./External-Dm_9qsZE-WC8_5qS7.js";import{u as qe,k as Ve,r as Ne,V as Ye,n as He,o as Vt}from"./mat4-R0VY9B_E-DoEP887i.js";import{A as Nt}from"./quat-B6H0knG8-DtO1-hlf.js";import{e as Yt,n as Ht}from"./quatf64-C16JxGFv-BKWK1F8U.js";import"./imageUtils-DITyjHV4-jEv5aA2D.js";import"./earcut-C6NeZYSh-P2HUZ781.js";import"./Indices-CAn-HCVv-hWNN5onC.js";import"./plane-wUwHaY3K-ZwGBF7HQ.js";import"./vec42-DHp-FUwt-Br7hmYJs.js";import"./vectorStacks-B2ngxq6F-myhPBoPk.js";import"./vec2f64-CkowXrDb-3zFQ3LNH.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./deduplicate-Cqg-F-nU-CWiUqVRS.js";import"./BufferView-B6RYETl3-CMoUTBv6.js";import"./vec4-Dua3dSaz-Cy3KWGYf.js";import"./zscale-PLuFqpaL-BIEnWBsg.js";import"./infoFor3D-BeWnZejW-CnXQECJx.js";const Zt="Mesh must be loaded before applying operations",Jt="Provided component is not part of the list of components",Wt="Expected polygon to be a Polygon instance",N="Expected location to be a Point instance";class Kt extends z{constructor(){super("invalid-input:location",N)}}function de(e,t,r,o){if(o!==void 0){wt(e(),"option: geographic",{replacement:"Use mesh `vertexSpace` and spatial reference to control how operations are performed instead.",version:"4.30",warnOnce:!0});const s=t.type==="local";if(!Z(t)||o===s)return r.isGeographic||r.isWebMercator&&o;e().warnOnce(`Specifying the 'geographic' parameter (${o}) for a Mesh vertex space of type "${t.type}" is not supported. This parameter will be ignored.`)}switch(t.type){case"georeferenced":return r.isGeographic;case"local":return r.isGeographic||r.isWebMercator}}const H=()=>_.getLogger("esri.geometry.support.meshUtils.centerAt");function Xt(e,t,r){var i;if(!((i=e.vertexAttributes)!=null&&i.position))return;const{vertexSpace:o}=e,s=(r==null?void 0:r.origin)??e.origin,n=de(H,o,s.spatialReference,r==null?void 0:r.geographic);Z(o)?Qt(e,t,s):n?er(e,t,s):tr(e,t,s)}function Qt(e,t,r){const{vertexSpace:o}=e;if(!Z(o))return;const s=Je,n=Ze;if(!E(t,n,e.spatialReference))return void x(H(),t.spatialReference,e.spatialReference,D);if(!E(r,s,e.spatialReference)){const a=e.origin;return s[0]=a.x,s[1]=a.y,s[2]=a.z,void x(H(),r.spatialReference,e.spatialReference,D)}const i=Pt(or,n,s);o.origin=Dt(w(),o.origin,i)}function er(e,t,r){const o=ae(r.x,r.y,r.z??0),s=fe(e,new ce({origin:o}));if(!s)return;const n=ae(t.x,t.y,t.z??0),i=fe({vertexAttributes:s,spatialReference:e.spatialReference,vertexSpace:new ce({origin:n})},X.absolute);if(!i)return;const{position:a,normal:l,tangent:p}=i;e.vertexAttributes.position=a,e.vertexAttributes.normal=l,e.vertexAttributes.tangent=p,e.vertexAttributesChanged()}function tr(e,t,r){const o=Je,s=Ze;if(E(t,s,e.spatialReference)){if(!E(r,o,e.spatialReference)){const n=e.origin;return o[0]=n.x,o[1]=n.y,o[2]=n.z,void x(H(),r.spatialReference,e.spatialReference,D)}rr(e.vertexAttributes.position,s,o),e.vertexAttributesChanged()}else x(H(),t.spatialReference,e.spatialReference,D)}function rr(e,t,r){if(e)for(let o=0;o<e.length;o+=3)for(let s=0;s<3;s++)e[o+s]+=t[s]-r[s]}const Ze=w(),Je=w(),or=w();function sr(e){const{spatialReference:t,vertexSpace:r,untransformedBounds:o}=e,s=gt(o,nr);if(Z(r)&&e.transform&&xe(s,s,e.transform.localMatrix),r.type==="georeferenced"){const a=r.origin;return a&&Ut(s,s,a),ge(ie(s),t)}const n=me(t),i=r.origin;if(!It(n,t)){const[a,l,p]=i;return new xt({xmin:a,ymin:l,zmin:p,xmax:a,ymax:l,zmax:p,spatialReference:t})}return Ge(t,i,ve,n),xe(s,s,ve),kt(s,n,0,s,t,0),ge(ie(s),t)}const ve=se(),nr=vt(24);async function ir(e,t,r){switch(t.source.type){case"client":case"service":return ar(e,t,r);case"loadable":return t.source.load(e,r);default:yt(t.source)}}async function ar(e,t,r){const{source:o}=t,{loadGLTFMesh:s}=await Me(le(()=>import("./loadGLTFMesh-D51AmJU4-DE4--Qpr.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]),import.meta.url),r),n=await cr(o,r);oe(r);const i=s(new O({x:0,y:0,z:0,spatialReference:e.spatialReference}),n.url,{resolveFile:lr(n),signal:r==null?void 0:r.signal,expectedType:n.type,unitConversionDisabled:t.unitConversionDisabled});i.then(()=>n.dispose(),()=>n.dispose());const{mesh:{vertexAttributes:a,components:l},meta:{isDracoDecompressed:p}}=await i;if(p)throw new z("mesh-load-external:draco-not-supported","The provided mesh uses Draco compression which is not supported.");e.vertexAttributes=a,e.components=l}function lr(e){const t=At(e.url);return r=>{const o=St(r,t,t),s=o?o.replace(/^ *\.\//,""):null;return(s?e.files.get(s):null)??r}}async function cr(e,t){switch(e.type){case"client":return Array.isArray(e.files)?pr(e.files):We(e.files);case"service":return fr(e.assets,t);default:throw new z("mesh-load-external:invalid-source","Invalid source type")}}async function ur(e,t){const{parts:r,assetMimeType:o,assetName:s}=e;if(r.length===1)return new te(r[0].partUrl);const n=await e.toBlob(t);return oe(t),te.fromBlob(n,tt(s,o))}function We(e){return te.fromBlob(e,tt(e.name,e.type))}function pr(e){if(!e.length)throw new z("mesh-load-external:missing-assets","There must be at least one file to load");return Qe(e.map(t=>({name:t.name,mimeType:t.type,source:We(t)})))}async function fr(e,t){if(!e.length)throw new z("mesh-load-external:missing-assets","There must be at least one file to load");const r=await _t(e.map(async o=>{const s=await ur(o);return oe(t),{name:o.assetName,mimeType:o.assetMimeType,source:s}}));if(Ft(t))throw r.forEach(o=>o.source.dispose()),Mt();return Qe(r)}const Ke=/^model\/gltf\+json$/,Xe=/^model\/gltf-binary$/,he=/\.gltf$/i,hr=/\.glb$/i;function we({mimeType:e,source:t,name:r}){return Ke.test(e)||he.test(r)?{url:t.url,type:"gltf"}:Xe.test(e)||hr.test(r)?{url:t.url,type:"glb"}:null}function Qe(e){const t=new Map;let r=null,o=null;for(const n of e){const{source:i,name:a}=n;r??(r=we(n)),a==="ESRI3DO_NORM.glb"&&(o=we(n)),t.set(a,i.url),i.files.forEach((l,p)=>t.set(p,l))}const s=o??r;if(s==null)throw new z("mesh-load-external:missing-files","Missing files to load external mesh source");return new te(s.url,()=>e.forEach(({source:n})=>n.dispose()),t,s.type)}let te=class et{constructor(t,r=()=>{},o=new Map,s){this.url=t,this.dispose=r,this.files=o,this.type=s}static fromBlob(t,r){const o=URL.createObjectURL(t);return new et(o,()=>URL.revokeObjectURL(o),void 0,r)}};function tt(e,t){return Ke.test(t)||he.test(e)?"gltf":Xe.test(t)||he.test(e)?"glb":void 0}let L=class extends ht{constructor(e){super(e),this.externalSources=new mt,this._explicitDisplaySource=null,this.georeferenced=!1,this.addHandles(dt(()=>this.externalSources,"after-remove",({item:t})=>{t===this._explicitDisplaySource&&(this._explicitDisplaySource=null)},{sync:!0,onListenerRemove:()=>this._explicitDisplaySource=null}))}get displaySource(){return this._explicitDisplaySource??this._implicitDisplaySource}set displaySource(e){if(e!=null&&!ye(e))throw new Error("Cannot use this source for display: it is not in a supported format.");this._explicitDisplaySource=e,e&&this.externalSources.every(t=>!Gt(t,e))&&this.externalSources.add(e)}clearSources(){this.externalSources.removeAll()}getExternalSourcesOnService(e){return this.externalSources.items.filter(t=>qt(t,e))}get _implicitDisplaySource(){return this.externalSources.find(ye)}};d([g()],L.prototype,"externalSources",void 0),d([g()],L.prototype,"displaySource",null),d([g()],L.prototype,"_implicitDisplaySource",null),d([g()],L.prototype,"_explicitDisplaySource",void 0),d([g()],L.prototype,"georeferenced",void 0),L=d([Ee("esri.geometry.support.meshUtils.Metadata")],L);function mr(){const{faceDescriptions:e,faceVertexOffsets:t,uvScales:r}=Sr,o=4*e.length,s=new Float64Array(3*o),n=new Float32Array(3*o),i=new Float32Array(2*o),a=new Uint32Array(2*e.length*3);let l=0,p=0,c=0,f=0;for(let u=0;u<e.length;u++){const h=e[u],y=l/3;for(const b of t)a[f++]=y+b;const C=h.corners;for(let b=0;b<4;b++){const F=C[b];let M=0;i[c++]=.25*r[b][0]+h.uvOrigin[0],i[c++]=h.uvOrigin[1]-.25*r[b][1];for(let A=0;A<3;A++)h.axis[A]!==0?(s[l++]=.5*h.axis[A],n[p++]=h.axis[A]):(s[l++]=.5*F[M++],n[p++]=0)}}return{position:s,normal:n,uv:i,faces:a}}function dr(e,t){const r=e.components[0],o=r.faces,s=Rr[t],n=6*s,i=new Array(6),a=new Array(o.length-6);let l=0,p=0;for(let c=0;c<o.length;c++)c>=n&&c<n+6?i[l++]=o[c]:a[p++]=o[c];if(e.vertexAttributes.uv!=null){const c=new Float32Array(e.vertexAttributes.uv),f=4*s*2,u=[0,1,1,1,1,0,0,0];for(let h=0;h<u.length;h++)c[f+h]=u[h];e.vertexAttributes.uv=c}return e.components=[new q({faces:i,material:r.material}),new q({faces:a})],e}function gr(e=0){const t=Math.round(8*2**e),r=2*t,o=(t-1)*(r+1)+2*r,s=new Float64Array(3*o),n=new Float32Array(3*o),i=new Float32Array(2*o),a=new Uint32Array(3*((t-1)*r*2));let l=0,p=0,c=0,f=0;for(let u=0;u<=t;u++){const h=u/t*Math.PI+.5*Math.PI,y=Math.cos(h),C=Math.sin(h);m[2]=C;const b=u===0||u===t,F=b?r-1:r;for(let M=0;M<=F;M++){const A=M/F*2*Math.PI;m[0]=-Math.sin(A)*y,m[1]=Math.cos(A)*y;for(let S=0;S<3;S++)s[l]=.5*m[S],n[l]=m[S],++l;i[p++]=(M+(b?.5:0))/r,i[p++]=u/t,u!==0&&M!==r&&(u!==t&&(a[c++]=f,a[c++]=f+1,a[c++]=f-r),u!==1&&(a[c++]=f,a[c++]=f-r,a[c++]=f-r-1)),f++}}return{position:s,normal:n,uv:i,faces:a}}function xr(e=0){const t=Math.round(16*2**e),r=4*(t+1)+2*t,o=new Float64Array(3*r),s=new Float32Array(3*r),n=new Float32Array(2*r),i=new Uint32Array(3*(4*t));let a=0,l=0,p=0,c=0,f=0;for(let u=0;u<=5;u++){const h=u===0||u===5,y=u<=1||u>=4,C=u===2||u===4,b=h?t-1:t;for(let F=0;F<=b;F++){const M=F/b*2*Math.PI,A=h?0:.5;m[0]=A*Math.sin(M),m[1]=A*-Math.cos(M),m[2]=u<=2?.5:-.5;for(let S=0;S<3;S++)o[a++]=m[S],s[l++]=y?S===2?u<=1?1:-1:0:S===2?0:m[S]/A;n[p++]=(F+(h?.5:0))/t,n[p++]=u<=1?1*u/3:u<=3?1*(u-2)/3+1/3:1*(u-4)/3+2/3,C||u===0||F===t||(u!==5&&(i[c++]=f,i[c++]=f+1,i[c++]=f-t),u!==1&&(i[c++]=f,i[c++]=f-t,i[c++]=f-t-1)),f++}}return{position:o,normal:s,uv:n,faces:i}}function yr(e,t){const r=typeof t=="number"?t:t!=null?t.width:1,o=typeof t=="number"?t:t!=null?t.height:1;switch(e){case"up":case"down":return{width:r,depth:o};case"north":case"south":return{width:r,height:o};case"east":case"west":return{depth:r,height:o}}}function vr(e){const t=V.facingAxisOrderSwap[e],r=V.position,o=V.normal,s=new Float64Array(r.length),n=new Float32Array(o.length);let i=0;for(let a=0;a<4;a++){const l=i;for(let p=0;p<3;p++){const c=t[p],f=Math.abs(c)-1,u=c>=0?1:-1;s[i]=r[l+f]*u,n[i]=o[l+f]*u,i++}}return{position:s,normal:n,uv:new Float32Array(V.uv),faces:new Uint32Array(V.faces),isPlane:!0}}const I=1,k=2,U=3,V={position:[-.5,-.5,0,.5,-.5,0,.5,.5,0,-.5,.5,0],normal:[0,0,1,0,0,1,0,0,1,0,0,1],uv:[0,1,1,1,1,0,0,0],faces:[0,1,2,0,2,3],facingAxisOrderSwap:{east:[U,I,k],west:[-U,-I,k],north:[-I,U,k],south:[I,-U,k],up:[I,k,U],down:[I,-k,-U]}};function W(e,t,r){e.isPlane||wr(e),Ar(e,br(r==null?void 0:r.size,r==null?void 0:r.unit,t.spatialReference));const o=ee(t,r),s=t.spatialReference.isGeographic?ee(t):o,n=fe({vertexAttributes:e,vertexSpace:s,spatialReference:t.spatialReference},o,{allowBufferReuse:!0});return{vertexAttributes:new Q({...n,uv:e.uv}),vertexSpace:o,components:[new q({faces:e.faces,material:(r==null?void 0:r.material)||null})],spatialReference:t.spatialReference}}function wr(e){for(let t=0;t<e.position.length;t+=3)e.position[t+2]+=.5}function br(e,t,r){const o=zt(t,r);if(e==null&&o===1)return null;if(e==null)return[o,o,o];if(typeof e=="number"){const s=e*o;return[s,s,s]}return[e.width!=null?e.width*o:o,e.depth!=null?e.depth*o:o,e.height!=null?e.height*o:o]}function Ar(e,t){if(t!=null){P[0]=t[0],P[4]=t[1],P[8]=t[2];for(let r=0;r<e.position.length;r+=3){for(let o=0;o<3;o++)m[o]=e.position[r+o];pe(m,m,P);for(let o=0;o<3;o++)e.position[r+o]=m[o]}if(t[0]!==t[1]||t[1]!==t[2]){P[0]=1/t[0],P[4]=1/t[1],P[8]=1/t[2];for(let r=0;r<e.normal.length;r+=3){for(let o=0;o<3;o++)m[o]=e.normal[r+o];pe(m,m,P),Ct(m,m);for(let o=0;o<3;o++)e.normal[r+o]=m[o]}}}}const Sr={faceDescriptions:[{axis:[0,-1,0],uvOrigin:[0,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[1,0,0],uvOrigin:[.25,.625],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,1,0],uvOrigin:[.5,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[-1,0,0],uvOrigin:[.75,.625],corners:[[1,-1],[-1,-1],[-1,1],[1,1]]},{axis:[0,0,1],uvOrigin:[0,.375],corners:[[-1,-1],[1,-1],[1,1],[-1,1]]},{axis:[0,0,-1],uvOrigin:[0,.875],corners:[[-1,1],[1,1],[1,-1],[-1,-1]]}],uvScales:[[0,0],[1,0],[1,1],[0,1]],faceVertexOffsets:[0,1,2,0,2,3]},Rr={south:0,east:1,north:2,west:3,up:4,down:5},m=w(),P=Le(),$=()=>_.getLogger("esri.geometry.support.meshUtils.rotate");function _r(e,t,r){var l;if(!((l=e.vertexAttributes)!=null&&l.position)||t[3]===0)return;const{spatialReference:o,vertexSpace:s}=e,n=(r==null?void 0:r.origin)??e.origin,i=r==null?void 0:r.geographic,a=de($,s,o,i);Ce(e)?Fr(e,t,n):a?Mr(e,t,n):Lr(e,t,n)}function Fr(e,t,r){e.transform??(e.transform=new Y);const{vertexSpace:o,transform:s,spatialReference:n}=e,[i,a,l]=o.origin,p=new O({x:i,y:a,z:l,spatialReference:n}),c=j;if(p.equals(r))ue(c,0,0,0);else if(!Te(c,r,e))return void x($(),r.spatialReference,n,D);Nt(Re,K(t),Oe(t));const f=qe(be,Re,ne,Rt,c),{localMatrix:u}=s,h=Ve(be,f,u);s.scale=Ne(w(),h),Ye(h,h,$e(j,s.scale));const y=s.rotationAxis;s.rotation=Pe(h),s.rotationAngle===0&&(s.rotationAxis=y),s.translation=He(w(),h)}function Mr(e,t,r){const o=e.spatialReference,s=me(o),n=rt;if(!E(r,n,s)&&(x($(),r.spatialReference,s,"Falling back to mesh origin"),!E(e.origin,n,s)))return void x($(),e.origin.spatialReference,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,p=new Float64Array(i.length),c=a!=null?new Float32Array(a.length):null,f=l!=null?new Float32Array(l.length):null;Ge(s,n,re,s),bt(Se,re);const u=Ae;pe(K(Ae),K(t),Se),u[3]=t[3],ze(i,o,p,s)&&(a==null||c==null||Ie(a,i,o,p,s,c))&&(l==null||f==null||ke(l,i,o,p,s,f))?(G(p,u,3,n),Ue(p,s,i,o)&&(a==null||c==null||(G(c,u,3),je(c,i,o,p,s,a)))&&(l==null||f==null||(G(f,u,4),Be(f,i,o,p,s,l)))?e.vertexAttributesChanged():x($(),s,o)):x($(),o,s)}function Lr(e,t,r){const o=rt;if(!E(r,o,e.spatialReference)){const s=e.origin;return o[0]=s.x,o[1]=s.y,o[2]=s.z,void x($(),r.spatialReference,e.spatialReference,D)}G(e.vertexAttributes.position,t,3,o),G(e.vertexAttributes.normal,t,3),G(e.vertexAttributes.tangent,t,4),e.vertexAttributesChanged()}function G(e,t,r,o=ne){if(e!=null){Vt(re,Oe(t),K(t));for(let s=0;s<e.length;s+=r){for(let n=0;n<3;n++)j[n]=e[s+n]-o[n];$t(j,j,re);for(let n=0;n<3;n++)e[s+n]=j[n]+o[n]}}}const j=w(),be=se(),Ae=De(),re=se(),Se=Le(),rt=w(),Re=Yt(),T=()=>_.getLogger("esri.geometry.support.meshUtils.scale");function Er(e,t,r){var l;if(!((l=e.vertexAttributes)!=null&&l.position))return;const{vertexSpace:o,spatialReference:s}=e,n=(r==null?void 0:r.origin)??e.origin,i=r==null?void 0:r.geographic,a=de(T,o,s,i);Ce(e)?Or(e,t,n):a?Pr(e,t,n):Dr(e,t,n)}function Or(e,t,r){e.transform??(e.transform=new Y);const{vertexSpace:o,transform:s,spatialReference:n}=e,[i,a,l]=o.origin,p=new O({x:i,y:a,z:l,spatialReference:n}),c=B;if(p.equals(r))ue(c,0,0,0);else if(!Te(c,r,e))return void x(T(),r.spatialReference,n,D);const f=ue(Cr,t,t,t),u=qe(_e,Ht,ne,f,c),{localMatrix:h}=s,y=Ve(_e,u,h);s.scale=Ne(w(),y),Ye(y,y,$e(B,s.scale));const C=s.rotationAxis;s.rotation=Pe(y),s.rotationAngle===0&&(s.rotationAxis=C),s.translation=He(w(),y)}function Pr(e,t,r){const o=e.spatialReference,s=me(o),n=st;if(!E(r,n,s)&&(x(T(),r.spatialReference,s,"Falling back to mesh origin"),!E(e.origin,n,s)))return void x(T(),e.origin.spatialReference,s);const i=e.vertexAttributes.position,a=e.vertexAttributes.normal,l=e.vertexAttributes.tangent,p=new Float64Array(i.length),c=a!=null?new Float32Array(a.length):null,f=l!=null?new Float32Array(l.length):null;ze(i,o,p,s)&&(a==null||c==null||Ie(a,i,o,p,s,c))&&(l==null||f==null||ke(l,i,o,p,s,f))?(ot(p,t,n),Ue(p,s,i,o)&&(a==null||c==null||je(c,i,o,p,s,a))&&(l==null||f==null||Be(f,i,o,p,s,l))?e.vertexAttributesChanged():x(T(),s,o)):x(T(),o,s)}function Dr(e,t,r){const o=st;if(!E(r,o,e.spatialReference)){const s=e.origin;return o[0]=s.x,o[1]=s.y,o[2]=s.z,void x(T(),r.spatialReference,e.spatialReference,D)}ot(e.vertexAttributes.position,t,o),e.vertexAttributesChanged()}function ot(e,t,r=ne){if(e)for(let o=0;o<e.length;o+=3){for(let s=0;s<3;s++)B[s]=e[o+s]-r[s];Tt(B,B,t);for(let s=0;s<3;s++)e[o+s]=B[s]+r[s]}}const B=w(),Cr=w(),_e=se(),st=w();var R;const $r={base:null,key:"type",defaultKeyValue:"georeferenced",typeMap:{georeferenced:X,local:ce}};let v=R=class extends nt(it(at(lt))){constructor(e){super(e),this.components=null,this.vertexSpace=new X,this.transform=null,this.metadata=new L,this.hasZ=!0,this.hasM=!1,this.vertexAttributes=new Q,this.type="mesh"}initialize(){(this.metadata.externalSources.length===0||this.vertexAttributes.position.length)&&(this.loadStatus="loaded"),this.when(()=>{this.addHandles(ct(()=>{var e;return{vertexAttributes:this.vertexAttributes,components:(e=this.components)==null?void 0:e.map(t=>t.clone())}},()=>this._clearSources(),{once:!0,sync:!0}))})}get hasExtent(){var e;return this.loaded?this.vertexAttributes.position.length>0&&(!this.components||this.components.length>0):((e=this.metadata.displaySource)==null?void 0:e.extent)!=null}get _transformedExtent(){const{spatialReference:e,vertexSpace:t}=this,r=this;return sr({get transform(){return r.transform},vertexSpace:t,spatialReference:e,untransformedBounds:this._untransformedBounds})}get _untransformedBounds(){const{vertexAttributes:{position:e},components:t}=this;return e.length===0||(t==null?void 0:t.length)===0?ut(pt):ie(e)}get origin(){const e=Et(this.vertexSpace,this.spatialReference);if(e!=null)return e;const{center:t,zmin:r}=this._transformedExtent;return new O({x:t.x,y:t.y,z:r,spatialReference:this.spatialReference})}get extent(){var e,t;return this.loaded||((t=(e=this.metadata)==null?void 0:e.displaySource)==null?void 0:t.extent)==null?this._transformedExtent:this.metadata.displaySource.extent.clone()}addComponent(e){this._checkIfLoaded("addComponent()")&&(this.components||(this.components=[]),this.components.push(q.from(e)),this.notifyChange("components"))}removeComponent(e){if(this._checkIfLoaded("removeComponent()")){if(this.components){const t=this.components.indexOf(e);if(t!==-1)return this.components.splice(t,1),void this.notifyChange("components")}_.getLogger(this).error("removeComponent()",Jt)}}rotate(e,t,r,o){return Lt(e,t,r,Fe),_r(this,Fe,o),this}offset(e,t,r){if(!this._checkIfLoaded("offset()"))return this;const{vertexSpace:o,vertexAttributes:s}=this,n=s==null?void 0:s.position;if(!n)return this;if(Z(o)){const[i,a,l]=o.origin;o.origin=ae(i+e,a+t,l+r)}else{for(let i=0;i<n.length;i+=3)n[i]+=e,n[i+1]+=t,n[i+2]+=r;this.vertexAttributesChanged()}return this}scale(e,t){return this._checkIfLoaded("scale()")?(Er(this,e,t),this):this}centerAt(e,t){return this._checkIfLoaded("centerAt()")?(Xt(this,e,t),this):this}load(e){const{metadata:{displaySource:t}}=this;return t&&this.addResolvingPromise(ir(this,t,e)),Promise.resolve(this)}addExternalSources(e){this.metadata.externalSources.addMany(e)}updateDisplaySource(e){this.metadata.displaySource=e}clone(e){return super.clone(jt(Bt(e)))}cloneShallow(){return new R({components:this.components,spatialReference:this.spatialReference,vertexAttributes:this.vertexAttributes,vertexSpace:this.vertexSpace.clone(),transform:this.transform,metadata:this.metadata})}vertexAttributesChanged(){this.notifyChange("vertexAttributes")}async toBinaryGLTF(e){const[{toBinaryGLTF:t}]=await Promise.all([le(()=>import("./gltfexport-CqOJ7XCw-AjUCc5yW.js"),__vite__mapDeps([34,1,2,20,21,9,12,4,5,6,27,19,28,29,30,31,32,33,8,10,14,11,13,3,15,23,22]),import.meta.url),this.load(e)]);return oe(e),await t(this,e)}get usedMemory(){return this.components?this.components.reduce((e,t)=>e+t.memoryUsage,this.vertexAttributes.usedMemory):this.vertexAttributes.usedMemory}_clearSources(){this.metadata.clearSources()}_checkIfLoaded(e){return!!this.loaded||(_.getLogger(this).error(e,Zt),!1)}static createBox(e,t){if(!(e instanceof O))return _.getLogger(this.prototype).error(".createBox()",N),null;const r=new R(W(mr(),e,t));return t!=null&&t.imageFace&&t.imageFace!=="all"?dr(r,t.imageFace):r}static createSphere(e,t){return e instanceof O?new R(W(gr((t==null?void 0:t.densificationFactor)||0),e,t)):(_.getLogger(this.prototype).error(".createSphere()",N),null)}static createCylinder(e,t){return e instanceof O?new R(W(xr((t==null?void 0:t.densificationFactor)||0),e,t)):(_.getLogger(this.prototype).error(".createCylinder()",N),null)}static createPlane(e,t){if(!(e instanceof O))return _.getLogger(this.prototype).error(".createPlane()",N),null;const r=(t==null?void 0:t.facing)??"up",o=yr(r,t==null?void 0:t.size);return new R(W(vr(r),e,{...t,size:o}))}static createFromPolygon(e,t){if(!(e instanceof ft))return _.getLogger(this.prototype).error(".createFromPolygon()",Wt),null;const r=Ot(e);return new R({vertexAttributes:new Q({position:r.position}),components:[new q({faces:r.faces,shading:"flat",material:(t==null?void 0:t.material)??null})],spatialReference:e.spatialReference,vertexSpace:new X})}static async createFromGLTF(e,t,r){if(!(e instanceof O)){const s=new Kt;throw _.getLogger(this.prototype).error(".createfromGLTF()",s.message),s}const{loadGLTFMesh:o}=await Me(le(()=>import("./loadGLTFMesh-D51AmJU4-DE4--Qpr.js"),__vite__mapDeps([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33]),import.meta.url),r);return new R((await o(e,t,r)).mesh)}static createWithExternalSource(e,t,r){var c;const o=(r==null?void 0:r.extent)??null,{spatialReference:s}=e,n=((c=r==null?void 0:r.transform)==null?void 0:c.clone())??new Y,i=ee(e,r),a=r==null?void 0:r.unitConversionDisabled,l={source:t,extent:o,unitConversionDisabled:a},p=new L;return p.externalSources.push(l),new R({metadata:p,transform:n,vertexSpace:i,spatialReference:s})}static createIncomplete(e,t){var i;const{spatialReference:r}=e,o=((i=t==null?void 0:t.transform)==null?void 0:i.clone())??new Y,s=ee(e,t),n=new R({transform:o,vertexSpace:s,spatialReference:r});return n.addResolvingPromise(Promise.reject(new z("mesh-incomplete","Mesh resources are not complete"))),n}};d([g({type:[q],json:{write:!0}})],v.prototype,"components",void 0),d([g({nonNullable:!0,types:$r,constructOnly:!0,json:{write:!0},clonable:(e,t)=>{var r;return((r=J(t))==null?void 0:r.vertexSpace)??e.clone(t)}})],v.prototype,"vertexSpace",void 0),d([g({type:Y,clonable:(e,t)=>{const r=J(t);return r&&"transform"in r?r.transform:(e==null?void 0:e.clone())??e},json:{write:!0}})],v.prototype,"transform",void 0),d([g({constructOnly:!0,type:L,clonable:(e,t)=>{var r;return((r=J(t))==null?void 0:r.metadata)??e.clone()}})],v.prototype,"metadata",void 0),d([g()],v.prototype,"hasExtent",null),d([g()],v.prototype,"_transformedExtent",null),d([g()],v.prototype,"_untransformedBounds",null),d([g()],v.prototype,"origin",null),d([g({readOnly:!0,json:{read:!1}})],v.prototype,"extent",null),d([g({readOnly:!0,json:{read:!1,write:!0,default:!0}})],v.prototype,"hasZ",void 0),d([g({readOnly:!0,json:{read:!1,write:!0,default:!1}})],v.prototype,"hasM",void 0),d([g({type:Q,nonNullable:!0,json:{write:!0},clonable:(e,t)=>{var r;return((r=J(t))==null?void 0:r.vertexAttributes)??e.clone(t)}})],v.prototype,"vertexAttributes",void 0),v=R=d([Ee("esri.geometry.Mesh")],v);const Fe=De();export{v as default};
