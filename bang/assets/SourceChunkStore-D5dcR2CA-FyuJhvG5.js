import{ak as be,ah as P,kg as se,fK as Te,C as Me,f8 as ke,be as v,b8 as R,em as H,a4 as We,ca as Se}from"./index-BeTPrQ6f.js";import{n as S,o as q}from"./memoryEstimations-C_GUL8g_-JniNFd5l.js";import{c as x}from"./OptimizedGeometry-BYxlP_oK-DvAqrgO1.js";import{f as Ce}from"./parquet-BKuoy8EM-tvadAp3d.js";import{O as re,T as Fe,z as Oe,G as Ge}from"./FeatureStoreQueryAdapter-Bcw-trC6-Qchy735n.js";import{p as Ae,y as je}from"./arcadeUtils-BkvNBhzm-KzAaTYHA.js";import"./vec2f64-CkowXrDb-3zFQ3LNH.js";import{u as ze,j as ie,d as Ee,e as De,H as W,o as Ue}from"./featureConversionUtils-CZmIxyv5-DHwRSztU.js";import{h as G}from"./queryUtils-BwthgOFW-CkUF_Za8.js";import{a as V}from"./definitions-DVO21zOC-BwakNu1s.js";import{w as Y,p as Z,M as J}from"./quantizationUtils-Ba9rpy9D-8ijlY328.js";let ne=class{constructor(n){this._statistics=n}get statistics(){return this._statistics}};const K=Math.PI/180;let B=class ${static create(e){return new $(e.map(t=>Xe(t)))}constructor(e){this._statistics=e}static get estimatedMemory(){return S+4*S}values(){return this._statistics.values()}insert(e,t){for(const s of this._statistics)s.insert(e,t)}merge(e){for(let t=0;t<this._statistics.length;t++){const s=this._statistics[t],r=e._statistics[t];if(s.field.name!==r.field.name)throw new Error("InternalError: Tried to merge incompatible statistics");s.merge(r)}}clone(){return new $(this._statistics.map(e=>e.clone()))}};function Xe(n){switch(n.statisticType){case"min":return new N(n);case"max":return new Pe(n);case"avg":return new Be(n);case"avg_angle":return new $e(n);case"sum":case"count":return new Ye(n);case"mode":return new Le(n)}}let T=class{constructor(n){this.field=n}insert(n,e){if(!this.field.computed)return;const t=this.field.computed.read(n,e);Ge(t)||this._insertValue(t)}};class N extends T{constructor(){super(...arguments),this.type="min",this.value=Number.MAX_VALUE}_insertValue(e){this.value=Math.min(this.value,e)}merge(e){this.value=Math.min(this.value,e.value)}clone(){const e=new N(this.field);return e.value=this.value,e}}let Pe=class oe extends T{constructor(){super(...arguments),this.type="max",this.value=Number.MIN_VALUE}_insertValue(e){this.value=Math.max(this.value,e)}merge(e){this.value=Math.max(this.value,e.value)}clone(){const e=new oe(this.field);return e.value=this.value,e}},Ye=class ae extends T{constructor(){super(...arguments),this.type="sum",this.value=0}_insertValue(e){this.value+=e}merge(e){this.value+=e.value}clone(){const e=new ae(this.field);return e.value=this.value,e}},Be=class he extends T{constructor(){super(...arguments),this.type="avg",this._total=0,this._count=0}get value(){return this._total/this._count}_insertValue(e){this._total+=e,this._count+=1}merge(e){this._total+=e._total,this._count+=e._count}clone(){const e=new he(this.field);return e._total=this._total,e._count=this._count,e}},$e=class de extends T{constructor(){super(...arguments),this.type="avg_angle",this._x=0,this._y=0,this._count=0}get value(){const e=this._x/this._count,t=this._y/this._count,s=180/Math.PI;return Math.atan2(t,e)*s}_insertValue(e){this._x=this._x+Math.cos(e*K),this._y=this._y+Math.sin(e*K),this._count+=1}merge(e){this._x+=e._x,this._y+=e._y,this._count+=e._count}clone(){const e=new de(this.field);return e._x=this._x,e._y=this._y,e._count=this._count,e}},Le=class le extends T{constructor(){super(...arguments),this._frequencies=new Map}get value(){let e,t=0;for(const[s,r]of this._frequencies.entries())r>t&&(t=r,e=s);return e}_insertValue(e){const t=this._frequencies.get(e);t!=null?this._frequencies.set(e,t+1):this._frequencies.set(e,1)}merge(e){for(const[t,s]of e._frequencies.entries()){const r=this._frequencies.get(t);r!=null?this._frequencies.set(t,r+s):this._frequencies.set(t,s)}}clone(){const e=new le(this.field);return e._frequencies=new Map(this._frequencies),e}};class w extends ne{static createId(e,t){return`${e}.${t}`}static create(e,t,s,r){return new w(e,t,B.create(s),r)}constructor(e,t,s,r){super(s),this.gridX=e,this.gridY=t,this._worldUnitsPerCell=r,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._objectIds=new Set}get id(){return w.createId(this.gridX,this.gridY)}get containedObjectIds(){return this._objectIds}get count(){return this._count}get firstObjectId(){return this._objectIds.values().next().value}get centroidXWorld(){return this._xWorldTotal/this._count}get centroidYWorld(){return this._yWorldTotal/this._count}get usedMemory(){return 48}clone(){const e=new w(this.gridX,this.gridY,this._statistics.clone(),this._worldUnitsPerCell);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._firstFeatureAttributes=this._firstFeatureAttributes,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r){this._count===0?this._firstFeatureAttributes=e.readAttributes():this._firstFeatureAttributes=null,this._count+=1,this._xWorldTotal+=s,this._yWorldTotal+=r,this._statistics.insert(e,t),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._firstFeatureAttributes=e._firstFeatureAttributes,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroidX(e){return e==null?this.centroidXWorld:Ee(e,this.centroidXWorld)}getCentroidY(e){return e==null?this.centroidYWorld:De(e,this.centroidYWorld)}getGeometry(e,t){const s=this.gridX*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell,i=new x([4],[s,r,s+this._worldUnitsPerCell,r,s+this._worldUnitsPerCell,r+this._worldUnitsPerCell,s,r+this._worldUnitsPerCell]);if(t!=null){const o=new x;return W(o,i,!1,!1,"esriGeometryPolygon",t)}return i}getCentroid(e){const t=new x([],[this.centroidXWorld,this.centroidYWorld]);if(e!=null){const s=new x;return W(s,t,!1,!1,"esriGeometryPoint",e)}return t}getGeometricCentroid(e,t){const s=this.gridX*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,r=this.gridY*this._worldUnitsPerCell+.5*this._worldUnitsPerCell,i=new x([],[s,r]);if(t!=null){const o=new x;return W(o,i,!1,!1,"esriGeometryPoint",t)}return i}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return this._firstFeatureAttributes!=null?{...e,...this._firstFeatureAttributes}:e}}let ue=class{constructor(n){this._options=n}insert(n,e){const t=n.getCursor(),{arcadeContextInfo:s,scale:r}=this._options,i=je(r,s);for(;t.next();)this._insertFeature(t,i,this._options.sqlOptions,e)}_insertFeature(n,e,t,s){const{featureFilter:r}=this._options;if(r!==null&&!r.check(n,t))return;let i=0,o=0;if(n.geometryType==="esriGeometryPoint")i=n.readXWorldSpace(),o=n.readYWorldSpace();else{if(s){const d=n.readCentroidForDisplay();if(d==null)return;const[a,h]=d.coords;if(a<0||a>V||h<0||h>V)return}const l=n.readCentroidWorldSpace();if(l==null)return;i=l.coords[0],o=l.coords[1]}this._insert(n,i,o,e)}};const qe=96;function Ne(n,e){return We(n)*Se*qe/e}let Re=class extends ue{constructor(n){super(n),this._cells=new Map,this._pixelsPerMapUnit=Ne(n.spatialReference,n.scale)}get usedMemory(){const n=this._cells.values().next().value;return n?(q+n.usedMemory)*this._cells.size:0}put(n){for(const e of this._cells.values()){const t=n.get(e.id);t?t.merge(e):n.set(e.id,e.clone())}}putBounded(n,e,t){const s=[e.xmin,e.ymin,e.xmax,e.ymax],[r,i,o,l]=s,d=Math.floor(r*this._pixelsPerMapUnit/this._options.cellSize),a=Math.floor(i*this._pixelsPerMapUnit/this._options.cellSize),h=Math.ceil(o*this._pixelsPerMapUnit/this._options.cellSize),c=Math.ceil(l*this._pixelsPerMapUnit/this._options.cellSize);for(let f=a;f<=c;f++)for(let _=d;_<=h;_++){const u=`${_}.${f}`,g=this._cells.get(u);if(!g)continue;const y=n.get(g.id);y?g&&!n.has(g.id)&&y.merge(g):n.set(g.id,g.clone())}}_insert(n,e,t,s){const r=e*this._pixelsPerMapUnit,i=t*this._pixelsPerMapUnit,o=Math.floor(r/this._options.cellSize),l=Math.floor(i/this._options.cellSize);this._getCellOrCreate(o,l).insert(n,s,e,t)}_getCellOrCreate(n,e){const t=w.createId(n,e);let s=this._cells.get(t);if(!s){const r=1*this._options.cellSize/this._pixelsPerMapUnit;s=w.create(n,e,this._options.fields,r),this._cells.set(t,s)}return s}},He=class ce{static fromReader(e){const t=[],s=e.copy(),r=se();for(;s.next();)s.getBounds(r)&&t.push(s.getIndex());const i=Ae(9,o=>(s.setIndex(o),{minX:s.getBoundsXMin(),minY:s.getBoundsYMin(),maxX:s.getBoundsXMax(),maxY:s.getBoundsYMax()}));return i.load(t),new ce(i,t.length)}constructor(e,t){this._index=e,this._size=t}get usedMemory(){return this._size*q}search(e){const t={minX:e[0],minY:e[1],maxX:e[2],maxY:e[3]};return this._index.search(t)}};const Ve=64;function Ze(n,e,t,s){const r=[n.xmin,n.ymin,n.xmax,n.ymax],i=Me.fromExtent(ke(r,s)),o=G(i,s,v.WGS84,{extendedParams:{densificationStep:e*Ve}});if(!o)return null;const l=ie(new x,o,!1,!1),d=l.coords.filter((y,p)=>!(p%2)),a=l.coords.filter((y,p)=>p%2),h=Math.min(...d),c=Math.min(...a),f=Math.max(...d),_=Math.max(...a),u=L(h,c,t,v.WGS84),g=L(f,_,t,v.WGS84);return u&&g?{bounds:r,geohashBounds:{xLL:u[0],yLL:u[1],xTR:g[0],yTR:g[1]},level:t}:null}function L(n,e,t,s){if(s.isWebMercator){const o=R(n/H.radius),l=o-360*Math.floor((o+180)/360),d=[0,0];return Q(d,0,R(Math.PI/2-2*Math.atan(Math.exp(-e/H.radius))),l,t),d}const r=G({x:n,y:e},s,v.WGS84);if(!r)return null;const i=[0,0];return Q(i,0,r.y,r.x,t),i}function Je(n,e){let t=-90,s=90,r=-180,i=180;for(let o=0;o<e;o++){const l=Math.ceil((o+1)/2),d=Math.floor((o+1)/2),a=1-o%2,h=30-(3*l+2*d),c=30-(2*l+3*d),f=3*a+2*(1-a),_=2*a+3*(1-a),u=3*a+7*(1-a)<<c,g=(7*a+3*(1-a)<<h&n.geohashX)>>h,y=(u&n.geohashY)>>c;for(let p=f-1;p>=0;p--){const I=(r+i)/2,m=g&1<<p?1:0;r=(1-m)*r+m*I,i=(1-m)*I+m*i}for(let p=_-1;p>=0;p--){const I=(t+s)/2,m=y&1<<p?1:0;t=(1-m)*t+m*I,s=(1-m)*I+m*s}}return[r,t,i,s]}function Q(n,e,t,s,r){r%2&&(r+=1);let i=0,o=0,l=-90,d=90,a=-180,h=180;for(let c=0;c<r/2;c++){for(let f=0;f<5;f++){const _=(a+h)/2,u=s>_?1:0;i|=u<<29-(f+5*c),a=(1-u)*a+u*_,h=(1-u)*_+u*h}for(let f=0;f<5;f++){const _=(l+d)/2,u=t>_?1:0;o|=u<<29-(f+5*c),l=(1-u)*l+u*_,d=(1-u)*_+u*d}}n[2*e]=i,n[2*e+1]=o}const ee=32;class b extends ne{static create(e,t,s,r){const i=B.create(e),o=new Array(ee);for(let l=0;l<o.length;l++)o[l]=null;return new b(i,t,s,r,o)}constructor(e,t,s,r,i){super(e),this.xNode=t,this.yNode=s,this.depth=r,this.children=i,this._objectIds=new Set,this._count=0,this._xWorldTotal=0,this._yWorldTotal=0,this._xGeohashTotal=0,this._yGeohashTotal=0,this.next=null}static get estimatedMemory(){let e=0;return e+=2*S,e+=q*ee,e+=B.estimatedMemory,e}get id(){return`${this.xNode}.${this.yNode}`}get containedObjectIds(){return this._objectIds}get count(){return this._count}clone(){const e=new b(this._statistics.clone(),this.xNode,this.yNode,this.depth,this.children);return e._count=this._count,e._xWorldTotal=this._xWorldTotal,e._yWorldTotal=this._yWorldTotal,e._xGeohashTotal=this._xGeohashTotal,e._yGeohashTotal=this._yGeohashTotal,e.next=this.next,e._objectIds=new Set(this._objectIds),e}insert(e,t,s,r,i,o){this._count+=1,this._xWorldTotal+=t,this._yWorldTotal+=s,this._xGeohashTotal+=r,this._yGeohashTotal+=i,this._statistics.insert(e,o),this._objectIds.add(e.getObjectId())}merge(e){if(e._count!==0){this._count+=e._count,this._xWorldTotal+=e._xWorldTotal,this._yWorldTotal+=e._yWorldTotal,this._xGeohashTotal+=e._xWorldTotal,this._yGeohashTotal+=e._yWorldTotal,this._statistics.merge(e._statistics);for(const t of e._objectIds.values())this._objectIds.add(t)}}getCentroid(e){throw new Error("getCentroid not supported for GeohashNode")}getGeometry(e,t){const s=this._getLngLatBounds(),[r,i,o,l]=s,d=G({rings:[[[r,i],[r,l],[o,l],[o,i],[r,i]]]},v.WGS84,e),a=ie(new x,d,!1,!1);return t!=null?W(new x,a,!1,!1,"esriGeometryPolygon",t,!1,!1):a}getGeometricCentroid(e,t){const s=this._getLngLatBounds(),[r,i,o,l]=s,d=G({x:(r+o)/2,y:(i+l)/2},v.WGS84,e),a=Ue(new x,d);return t!=null?W(new x,a,!1,!1,"esriGeometryPoint",t,!1,!1):a}getAttributes(){const e={aggregateId:this.id};for(const t of this._statistics.values())e[t.field.name]=t.value;return e.aggregateCount=this._count,e}find(e,t,s,r,i,o){if(r>=s)return this;const l=1-r%2,d=3*l+2*(1-l),a=2*l+3*(1-l),h=30-i-d,c=30-o-a,f=((e&7*l+3*(1-l)<<h)>>h)+((t&3*l+7*(1-l)<<c)>>c)*(8*l+4*(1-l)),_=this.children[f];return _==null?null:_.find(e,t,s,r+1,i+d,o+a)}_getLngLatBounds(){const e=this.depth,t=Math.ceil(e/2),s=Math.floor(e/2),r=30-(3*t+2*s),i=30-(2*t+3*s),o=this.xNode<<r,l=this.yNode<<i;return Je({geohashX:o,geohashY:l},this.depth)}}class Ke{constructor(e){this._fields=e,this._size=0,this._depth=0,this._root=b.create(this._fields,0,0,0)}destroy(){}get size(){return this._size}get depth(){return this._depth}get usedMemory(){return this._size*b.estimatedMemory}find(e,t,s){return this._root.find(e,t,s,0,0,0)}insert(e,t,s,r,i,o,l){let d=this._root,a=0,h=0,c=0;for(;d!==null;){if(d.insert(e,t,s,r,i,l),a>=o)return;const f=Math.ceil((a+1)/2),_=Math.floor((a+1)/2),u=1-a%2,g=30-(3*f+2*_),y=30-(2*f+3*_),p=(r&7*u+3*(1-u)<<g)>>g,I=(i&3*u+7*(1-u)<<y)>>y,m=p+I*(8*u+4*(1-u));h=h<<3*u+2*(1-u)|p,c=c<<2*u+3*(1-u)|I,d.children[m]==null&&(d.children[m]=b.create(this._fields,h,c,a+1),this._depth=Math.max(this._depth,a+1),this._size+=1),a+=1,d=d.children[m]}}putBins(e,t){for(const s of this.getNodes(t)){const r=e.get(s.id);r?r.merge(s):e.set(s.id,s.clone())}}getNodes(e){const t=[],{geohashBounds:s,level:r}=e;let i=this._root;for(;i!==null;){const o=i.depth,l=i.xNode,d=i.yNode;if(o>=r){t.push(i),i=i.next;continue}const a=Math.ceil((o+1)/2),h=Math.floor((o+1)/2),c=1-o%2,f=30-(3*a+2*h),_=30-(2*a+3*h),u=~((1<<f)-1),g=~((1<<_)-1),y=(s.xLL&u)>>f,p=(s.yLL&g)>>_,I=(s.xTR&u)>>f,m=(s.yTR&g)>>_,z=l<<3*c+2*(1-c),E=d<<2*c+3*(1-c),pe=z+8*c+4*(1-c),me=E+4*c+8*(1-c),ye=Math.max(z,y),xe=Math.max(E,p),Ie=Math.min(pe,I),ve=Math.min(me,m);let C=null,D=null;for(let U=xe;U<=ve;U++)for(let X=ye;X<=Ie;X++){const we=X-z+(U-E)*(8*c+4*(1-c)),M=i.children[we];M&&(C||(C=M,C.next=i.next),D&&(D.next=M),D=M,M.next=i.next)}i=C||i.next}return t}}let Qe=class extends ue{constructor(n){super(n),this._tree=new Ke(this._options.fields)}get usedMemory(){return this._tree.usedMemory}put(n){throw new Error("Geohash tree does not support put")}putBounded(n,e,t){const{geohashLevel:s,spatialReference:r}=this._options,i=Ze(e,t,s,r);i!=null&&this._tree.putBins(n,i)}_insert(n,e,t,s){const{geohashLevel:r,spatialReference:i}=this._options,o=L(e,t,r,i);o&&this._tree.insert(n,e,t,o[0],o[1],r,s)}},et=class O extends re{static from(e,t){if(e instanceof this){const s=new Set(t),r=e._indices.filter(i=>s.has(i));return new O(e._reader,r)}return new O(e.copy(),t)}constructor(e,t){super(e.metadata),this._currentIndex=-1,this._displayTransform=null,this._reader=e,this._indices=t}setTransformForDisplay(e){const t=this._reader.getInTransform();if(t==null)return void(this._displayTransform=Y(e));const s=Y(t),r=Y(e),[i,o]=s.scale,[l,d]=s.translate,[a,h]=r.scale,[c,f]=r.translate,_=i/a,u=o/h,g=(l-c)/a,y=(d-f)/h;this._displayTransform={originPosition:"lowerLeft",scale:[1/_,1/u,1,1],translate:[-g/_,-y/u,0,0]}}getInTransform(){return this._reader.getInTransform()}get fields(){return this._reader.fields}get hasNext(){return this._currentIndex+1<this._indices.length}getSize(){return this._indices.length}getCursor(){return this.copy()}copy(){const e=new O(this._reader.copy(),this._indices);return e._currentIndex=this._currentIndex,e._displayTransform=this._displayTransform,e._processorAttributes=this._processorAttributes,e}get contextTimeZone(){return this._reader.contextTimeZone}set contextTimeZone(e){this._reader.contextTimeZone=e}get usedMemory(){return S+this._reader.usedMemory}setProcessorAttributes(e){this._processorAttributes=Object.assign(this._processorAttributes??{},e)}_nextIndex(){return++this._currentIndex<this._indices.length&&(this._reader.setIndex(this._indices[this._currentIndex]),!0)}next(){for(;this._nextIndex()&&!this._reader._getExists(););return this._currentIndex<this._indices.length}readXForDisplay(){return this._displayTransform?Z(this._displayTransform,this._reader.readXForDisplay()):this._reader.readXForDisplay()}readYForDisplay(){return this._displayTransform?J(this._displayTransform,this._reader.readYForDisplay()):this._reader.readYForDisplay()}readGeometryForDisplay(){return this._displayTransform?this._reader.readGeometryForDisplayTransformed(this._displayTransform):this._reader.readGeometryForDisplay()}readCentroidForDisplay(){var t;const e=(t=this._reader.readCentroidForDisplay())==null?void 0:t.clone();if(e){const[s,r]=e.coords;this._displayTransform?(e.coords[0]=Z(this._displayTransform,s),e.coords[1]=J(this._displayTransform,r)):(e.coords[0]=s,e.coords[1]=r)}return e}get geometryType(){return this._reader.geometryType}get hasFeatures(){return this._reader.hasFeatures}get exceededTransferLimit(){return this._reader.exceededTransferLimit}get hasZ(){return this._reader.hasZ}get hasM(){return this._reader.hasM}readAttribute(e,t=!1){const s=this._reader.readAttribute(e,t);return s==null&&this._processorAttributes?this._processorAttributes[e]:s}readAttributes(){return{...this._processorAttributes,...this._reader.readAttributes()}}joinAttributes(e){return this._reader.joinAttributes(e)}getBounds(e){return this._reader.getBounds(e)}getAttributeHash(){return this._reader.getAttributeHash()}getObjectId(){return this._reader.getObjectId()}getDisplayId(){return this._reader.getDisplayId()}setDisplayId(e){return this._reader.setDisplayId(e)}setIndex(e){return this._reader.setIndex(e)}getIndex(){return this._reader.getIndex()}readXWorldSpace(){return this._reader.readXWorldSpace()}readYWorldSpace(){return this._reader.readYWorldSpace()}_readX(){return this._reader.readXForDisplay()}_readY(){return this._reader.readYForDisplay()}_readServerCentroid(){return this._reader._readServerCentroid()}readLegacyFeatureForDisplay(){const e=this.readCentroidForDisplay();return{attributes:this.readAttributes(),geometry:this.readLegacyGeometryForDisplay(),centroid:(e&&{x:e.coords[0],y:e.coords[1]})??null}}readLegacyGeometryForDisplay(){const e=this.readGeometryForDisplay();return ze(e,this.geometryType,!1,!1)}readGeometryArea(){var e;return this._displayTransform?((e=this._reader.readGeometryForDisplayTransformed(this._displayTransform))==null?void 0:e.area())??0:this._reader.readGeometryArea()}readGeometryWorldSpace(){return this._reader.readGeometryWorldSpace()}_readGeometry(){return this._reader._readGeometry()}_readAttribute(e,t){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}_readAttributes(){throw new Error("Error: Should not be called. Underlying _reader should be used instead")}readArcadeFeature(){return this._reader.readArcadeFeature()}geometry(){return this._reader.geometry()}field(e){return this._reader.field(e)}hasField(e){return this._reader.hasField(e)}setField(e,t){return this._reader.setField(e,t)}keys(){return this._reader.keys()}castToText(e=!1){return this._reader.castToText(e)}},_e=class{size(){return this.reader.getSize()}get fields(){return this.reader.fields}invalidate(){this._aggregateIndex=null,this._aggregateIndexHash=null,this._spatialIndex=null}get usedMemory(){let n=0;return n+=this.reader.underlyingMemory,this._aggregateIndex&&(n+=this._aggregateIndex.usedMemory),this._spatialIndex&&(n+=this._spatialIndex.usedMemory),n}registerOverrides(n){this.reader.registerOverrides(n),this.invalidate()}queryFeaturesInBounds(n){const e=this._getSpatialIndex().search(n);return et.from(this.reader,e)}getAggregateIndex(n){const e=JSON.stringify(n);if(e!==this._aggregateIndexHash){switch(this._aggregateIndexHash=e,n.type){case"grid":this._aggregateIndex=new Re(n);break;case"geohash":this._aggregateIndex=new Qe(n)}this._aggregateIndex.insert(this.reader,this.isTiled)}return this._aggregateIndex}_getSpatialIndex(){return this._spatialIndex||(this._spatialIndex=He.fromReader(this.reader)),this._spatialIndex}};const te=1e4,tt=1e3;class A{static async create(e){const{metadata:t,definitionExpression:s}=e,r=s?await Te(s,t.fieldsIndex):null;return new A(t,r,s)}constructor(e,t,s){this.metadata=e,this._clause=t,this._definitionExpression=s}get hash(){return this._definitionExpression}testFeature(e){return this._clause==null||this._clause.testFeature(e)}}class j{constructor(){this.modified=new Map,this.removed=new Set}modify(e){this.modified.set(e.objectId,e),this.removed.has(e.objectId)&&this.removed.delete(e.objectId)}remove(e){this.modified.delete(e),this.removed.add(e)}get isEmpty(){return this.modified.size===0&&this.removed.size===0}applyWhereClause(e){const t=new j;for(const[s,r]of this.modified)e.testFeature(r)?t.modified.set(s,r):t.removed.add(r.objectId);for(const s of this.removed)t.removed.add(s);return t}}let st=class fe extends _e{constructor(e){super(),this._reader=e,this.chunkId="override",this.normalizedChunkId="override"}static fromFeatures(e,t){const s=Oe.fromOptimizedFeatures(e,t);return new fe(s)}get reader(){return this._reader}get queryInfo(){return{}}get first(){return!1}get end(){return!1}get isTiled(){return!1}getTileReader(e){if(!this._reader.getSize())return null;const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}};class F{constructor(e,t){this.inner=e,this.isWeak=t,this.lastWeak=null}get isStrong(){return!this.isWeak}}class rt{constructor(e){this._parameters=e,this._overrides=new Map,this._update=new j,this._lastCleanup=0}update(e){this._parameters=e}hasOverride(e){return this._overrides.has(e)}onChunkInsert(e){var t;if(this._overrides.size){const s=e.reader.getCursor();for(;s.next();){const r=s.getObjectId(),i=this._overrides.get(r);if(i!=null&&i.lastWeak&&(i.lastWeak=null),i==null?void 0:i.isWeak){const o=s.readOptimizedFeatureWorldSpace(),l=((t=i.inner)==null?void 0:t.attributes)??{};o.attributes={...l,...o.attributes},i.inner=o,this._update.modify(o),this.invalidate()}}}e.registerOverrides(this)}apply(e,t){const{updateWeak:s,removeWeak:r,update:i,remove:o,release:l}=e.commands;this.invalidate();for(const d of s){const a=new F(d,!0),h=this._overrides.get(d.objectId);h!=null&&h.isStrong?h.lastWeak=a:(this._overrides.set(d.objectId,a),this._update.modify(d))}for(const d of i){const a=new F(d,!1),h=this._overrides.get(d.objectId);a.lastWeak=h!=null&&h.isWeak?h:(h==null?void 0:h.lastWeak)??null,this._overrides.set(d.objectId,a),this._update.modify(d)}for(const d of r){const a=new F(null,!0),h=this._overrides.get(d);h!=null&&h.isStrong?h.lastWeak=a:(this._overrides.set(d,a),this._update.remove(d))}for(const d of o){const a=new F(null,!1),h=this._overrides.get(d);a.lastWeak=h!=null&&h.isWeak?h:(h==null?void 0:h.lastWeak)??null,this._overrides.set(d,a),this._update.remove(d)}if(l.length){const d=new Set;for(const a of l){const h=this._overrides.get(a);h!=null&&h.lastWeak?(this._overrides.set(a,h.lastWeak),h.lastWeak.inner==null?this._update.remove(a):this._update.modify(h.lastWeak.inner)):h&&!h.isWeak&&(this._overrides.delete(a),d.add(a))}t.forEachUnsafe(a=>{const h=a.getObjectId();d.has(h)&&(this._update.modify(a.readOptimizedFeatureWorldSpace()),d.delete(h))});for(const a of d.values())this._update.remove(a)}}clearWeakOverrides(){for(const[e,t]of this._overrides.entries())t.isWeak&&this._overrides.delete(e);this.invalidate()}cleanup(e){if(this._overrides.size<te)return;const t=performance.now();if(t-this._lastCleanup<tt)return;this._lastCleanup=t;const s=this._getWeakDeletions();if(!(s.size<te)){for(const r of e){const i=r.reader.withoutOverrides().getCursor();for(;i.next();){const o=i.getObjectId();s.delete(o)}}for(const r of s)this._overrides.delete(r);s.size&&this.invalidate()}}takeOverrideUpdate(){const e=this._update;return e.isEmpty?null:(this._update=new j,e.applyWhereClause(this._parameters))}asChunk(){const e=this._parameters;if(this._lastOverrideParametersHash!==e.hash&&(this._lastOverrideParametersHash=e.hash,this._chunk=null),!this._chunk){const t=[];for(const s of this._overrides.values())s.inner!=null&&e.testFeature(s.inner)&&t.push(s.inner);this._chunk=st.fromFeatures(t,e.metadata)}return this._chunk}invalidate(){this._chunk=null}putWeakObjectIdsFromGlobalIds(e,t,s){for(const[r,i]of this._overrides.entries()){if(i.isWeak&&i.inner!=null){const o=i.inner.attributes[s];o&&t.has(o)&&!e.has(o)&&e.set(o,r);continue}if(i.lastWeak!=null&&i.lastWeak.inner!=null){const o=i.lastWeak.inner.attributes[s];o&&t.has(o)&&!e.has(o)&&e.set(o,r)}}}_getWeakDeletions(){const e=new Set;for(const[t,s]of this._overrides.entries())s.isWeak&&s.inner==null&&e.add(t);return e}}class gt extends _e{constructor(e,t,s,r,i=0){super(),this._reader=e,this._queryJSON=t,this._page=s,this._end=r,this._fileIndex=i,this.chunkId=`${this._fileIndex}.${this._page}${this.end?"e":""}`,this.normalizedChunkId=this.chunkId}get reader(){return this._reader}get first(){return this._page===0}get end(){return this._end}get queryInfo(){return{type:"snapshot",chunkId:this.chunkId,queryJSON:this._queryJSON,page:this._page,size:this.size(),end:this.end}}get isTiled(){return!1}getTileReader(e){const t=this.queryFeaturesInBounds(e.bounds);return t.setTransformForDisplay(e.transform),t}}let k;class ge extends re{constructor(e,t,s,r,i,o=new Uint32Array(s.size())){super(e),this._fields=t,this._inner=s,this._chunkId=r,this._fileIndex=i,this._displayIds=o,this._index=-1,this.usedMemory=S,this._size=this._inner.size(),e.featureIdInfo.type,this._chunkId>65535&&console.error("Exceeded max allowed parquet reader size")}destroy(){super.destroy(),this._inner.free()}get fields(){return this._fields}get geometryType(){return this.metadata.geometryType}get hasFeatures(){return!0}get hasNext(){throw new Error("Method not implemented.")}get exceededTransferLimit(){return!1}get hasZ(){return!1}get hasM(){return!1}getInTransform(){return null}getSize(){return this._size}getCursor(){return this.copy()}getAttributeHash(){let e="";for(const t of this.fields.fields)e+=this._readAttribute(t.name,!1)+".";return e}getObjectId(){return this._fileIndex<<24|this._inner.rowId(this._index)}getDisplayId(){return this._displayIds[this._index]}setDisplayId(e){this._displayIds[this._index]=e}setIndex(e){this._index=e}getBoundsXMin(){return this._inner.boundsXMin(this._index)}getBoundsYMin(){return this._inner.boundsYMin(this._index)}getBoundsXMax(){return this._inner.boundsXMax(this._index)}getBoundsYMax(){return this._inner.boundsYMax(this._index)}setBoundsXMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMin(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsXMax(e){throw new Error("InternalError: Setting bounds is unsupported")}setBoundsYMax(e){throw new Error("InternalError: Setting bounds is unsupported")}getIndex(){return this._index}next(){for(;++this._index<this._size&&!this._getExists(););return this._index<this._size}readGeometryArea(){var e;return((e=this.readGeometryForDisplay())==null?void 0:e.area())??0}copy(){const e=new ge(this.metadata,this._fields,this._inner,this._chunkId,this._fileIndex,this._displayIds);return this.copyInto(e),e}copyInto(e){super.copyInto(e),e._index=this._index}readGeometryForDisplayTransformed(e){const[t,s]=e.translate,[r,i]=e.scale;return k||(k=Ce.new()),this._inner.transformGeometry(k,t,s,r,i,this._index)?new x(k.readLengthsUnsafe(),k.readCoordsUnsafe()):null}_readGeometry(e){const t=this._inner.readCoords(this._index),s=this._inner.readLengths(this._index);return t&&s?new x(s,t):null}_readX(){return this._inner.readX(this._index)}_readY(){return this._inner.readY(this._index)}_readServerCentroid(){return null}_readAttribute(e,t){const s=this.fields.get(e);if(!s)return;if(s.column==null)return this.getObjectId();const r=this._inner.readAttribute(this._index,s.column);if(r==null)return r;const i=this.fields.isDateField(s.name);return t?r==null?r:i?new Date(r):r:r}_readAttributes(){const e={};for(const t of this._fields.fields)t.column!=null&&(this._inner.isEmpty(t.column)||(e[t.name]=this._readAttribute(t.name,!1)));return e.__OBJECTID=this.getObjectId(),e}}class pt{constructor(){this._chunks=new Map,this._chunksToRemove=[],this.events=new be,this.featureAdapter=new Fe}destroy(){this.clear()}clear(){var e;for(const t of this._chunks.values())this._chunksToRemove.push(t);this._chunks.clear(),(e=this._overrides)==null||e.clearWeakOverrides()}get usedMemory(){let e=0;for(const t of this._chunks.values())e+=t.usedMemory;return e}async update(e){if(this._overrides){const t=await A.create(e);this._overrides.update(t)}this._schema=e}*chunks(){this._overrides&&(yield this._overrides.asChunk()),yield*this._chunks.values()}insert(e){var t;P("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.insert`),(t=this._overrides)==null||t.onChunkInsert(e),this._chunks.set(e.chunkId,e),this.events.emit("changed")}remove(e){P("esri-2d-update-debug")&&console.debug(`Chunk[${e.chunkId}] SourceChunkStore.remove`),this._chunks.delete(e.chunkId),this._chunksToRemove.push(e)}removeById(e){P("esri-2d-update-debug")&&console.debug(`Chunk[${e}] SourceChunkStore.remove`);const t=this._chunks.get(e);this._chunks.delete(e),t&&this._chunksToRemove.push(t)}cleanup(){var t;const e=this._chunksToRemove;return this._chunksToRemove=[],(t=this._overrides)==null||t.cleanup(this._chunks.values()),e}async applyOverride(e){if(this._overrides==null){const t=await A.create(this._schema);this._overrides=new rt(t);for(const s of this._chunks.values())this._overrides.onChunkInsert(s)}this._overrides.apply(e,this),this.events.emit("changed");for(const t of this._chunks.values())t.invalidate()}takeOverrideUpdate(){var e;return(e=this._overrides)==null?void 0:e.takeOverrideUpdate()}refresh(){this.events.emit("refresh")}forEach(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r.copy()),t.add(i))}}}forEachUnsafe(e){const t=new Set;for(const s of this.chunks()){const r=s.reader.getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}mapObjectIdsFromGlobalIds(e,t){var i;const s=new Map,r=new Set(e);return(i=this._overrides)==null||i.putWeakObjectIdsFromGlobalIds(s,r,t),this._forEachUnsafeIgnoreOverrides(o=>{const l=o.readAttribute(t);if(l&&r.has(l)&&!s.has(l)){const d=o.getObjectId();s.set(l,d)}}),s}forEachInBounds(e,t){const s=new Set;for(const r of this.chunks()){const i=r.queryFeaturesInBounds(e);for(;i.next();){const o=i.getObjectId();s.has(o)||(t(i.copy()),s.add(o))}}}forEachBounds(e,t){const s=se();for(const r of e)r.getBounds(s)&&t(s)}_forEachUnsafeIgnoreOverrides(e){const t=new Set;for(const s of this._chunks.values()){const r=s.reader.withoutOverrides().getCursor();for(;r.next();){const i=r.getObjectId();t.has(i)||(e(r),t.add(i))}}}}export{B as A,ge as H,et as d,gt as i,pt as n,Ne as o,_e as q,st as u,w as v};
