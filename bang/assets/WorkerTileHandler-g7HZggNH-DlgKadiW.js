import{bD as Ce,i as Ee,aI as Me,kL as be,ao as Ne}from"./index-BeTPrQ6f.js";import{p as L,L as me,I as ie,q as X,b as Pe,B as Oe,D as Ke,N as qe,C as ze,E as Be,O as Y,F as fe}from"./GeometryUtils-C8-DjR3I-DcNL1Jc6.js";import{s as re,t as ne}from"./constants-t42rMCzy-Dlzs1Z4p.js";import{a as De}from"./Rect-DD6XS68q-D_hsV3ag.js";import{s as Ve}from"./config-C6w0VpIP-CfPhyZfw.js";import{h as Ge}from"./pbf-42TrGguk-Dw0lh_Mv.js";import{k as je,E as He,P as We}from"./TurboLine-CvWJ2xTB-C5q-5bd9.js";import{p as Ye,h as $e}from"./SourceLayerData-Bj7ibB9F-B3LOrUgP.js";import{q as Je,a as C,H as Ze,C as Qe}from"./StyleRepository-BkGEVTu--C5HgoPSx.js";import{m as Le}from"./earcut-C6NeZYSh-P2HUZ781.js";import{d as Xe}from"./BidiEngine-DXDmu_WZ-DxL95DSc.js";import"./memoryEstimations-C_GUL8g_-JniNFd5l.js";import"./definitions-DVO21zOC-BwakNu1s.js";import"./enums-DDJfd4_p-D3z9tmVA.js";import"./VertexAttributeLocations-DBgVVQz--D3wovAvC.js";import"./VertexElementDescriptor-DLvjNrmQ-Cuvx5w94.js";import"./colorUtils-DlmOacVt-BnN0T6wa.js";import"./vec42-DHp-FUwt-Br7hmYJs.js";import"./vec4f64-DD-nkcCV-CSNWKRqG.js";import"./unitBezier-DhyPAQO8-B9kUb8N6.js";function et(u){return u===746||u===747||!(u<4352)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103&&!(u>=65097&&u<=65103)||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351&&!(u>=12296&&u<=12305||u>=12308&&u<=12319||u===12336)||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=12592&&u<=12687||u>=43360&&u<=43391||u>=55216&&u<=55295||u>=4352&&u<=4607||u>=44032&&u<=55215||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12688&&u<=12703||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543&&u!==12540||u>=65280&&u<=65519&&!(u===65288||u===65289||u===65293||u>=65306&&u<=65310||u===65339||u===65341||u===65343||u>=65371&&u<=65503||u===65507||u>=65512&&u<=65519)||u>=65104&&u<=65135&&!(u>=65112&&u<=65118||u>=65123&&u<=65126)||u>=5120&&u<=5759||u>=6320&&u<=6399||u>=65040&&u<=65055||u>=19904&&u<=19967||u>=40960&&u<=42127||u>=42128&&u<=42191)}function tt(u){return!(u<11904)&&(u>=12704&&u<=12735||u>=12544&&u<=12591||u>=65072&&u<=65103||u>=63744&&u<=64255||u>=13056&&u<=13311||u>=11904&&u<=12031||u>=12736&&u<=12783||u>=12288&&u<=12351||u>=13312&&u<=19903||u>=19968&&u<=40959||u>=12800&&u<=13055||u>=65280&&u<=65519||u>=12352&&u<=12447||u>=12272&&u<=12287||u>=12032&&u<=12255||u>=12784&&u<=12799||u>=12448&&u<=12543||u>=65040&&u<=65055||u>=42128&&u<=42191||u>=40960&&u<=42127)}function st(u){switch(u){case 10:case 32:case 38:case 40:case 41:case 43:case 45:case 47:case 173:case 183:case 8203:case 8208:case 8211:case 8231:return!0}return!1}function ke(u){switch(u){case 9:case 10:case 11:case 12:case 13:case 32:return!0}return!1}const G=24,Fe=17;class Ue{constructor(t,e,i,s,a,n,r){this._glyphItems=t,this._maxWidth=e,this._lineHeight=i,this._letterSpacing=s,this._hAnchor=a,this._vAnchor=n,this._justify=r}getShaping(t,e,i){const s=this._letterSpacing,a=this._lineHeight,n=this._justify,r=this._maxWidth,o=[];let l=0,c=0;for(const p of t){const I=p.codePointAt(0);if(I==null)continue;const b=i&&et(I);let m;for(const M of this._glyphItems)if(m=M[I],m)break;o.push({codePoint:I,x:l,y:c,vertical:b,glyphMosaicItem:m}),m&&(l+=m.metrics.advance+s)}let d=l;r>0&&(d=l/Math.max(1,Math.ceil(l/r)));const f=t.includes("â€‹"),h=[],x=o.length;for(let p=0;p<x-1;p++){const I=o[p].codePoint,b=tt(I);if(st(I)||b){let m=0;if(I===10)m-=1e4;else if(b&&f)m+=150;else{I!==40&&I!==65288||(m+=50);const M=o[p+1].codePoint;M!==41&&M!==65289||(m+=50)}h.push(this._buildBreak(p+1,o[p].x,d,h,m,!1))}}const g=this._optimalBreaks(this._buildBreak(x,l,d,h,0,!0));let w=0;const y=e?-a:a;let _=0;for(let p=0;p<g.length;p++){const I=g[p];let b=_;for(;b<I&&ke(o[b].codePoint);)o[b].glyphMosaicItem=null,++b;let m=I-1;for(;m>b&&ke(o[m].codePoint);)o[m].glyphMosaicItem=null,--m;if(b<=m){const M=o[b].x;for(let P=b;P<=m;P++)o[P].x-=M,o[P].y=c;let D=o[m].x;o[m].glyphMosaicItem&&(D+=o[m].glyphMosaicItem.metrics.advance),w=Math.max(D,w),n&&this._applyJustification(o,b,m)}_=I,c+=y}if(o.length>0){const p=g.length-1,I=(n-this._hAnchor)*w;let b=(-this._vAnchor*(p+1)+.5)*a;e&&p&&(b+=p*a);for(const m of o)m.x+=I,m.y+=b}return o.filter(p=>p.glyphMosaicItem)}static getTextBox(t,e){if(!t.length)return null;let i=1/0,s=1/0,a=0,n=0;for(const r of t){const o=r.glyphMosaicItem.metrics.advance,l=r.x,c=r.y-Fe,d=l+o,f=c+e;i=Math.min(i,l),a=Math.max(a,d),s=Math.min(s,c),n=Math.max(n,f)}return{x:i,y:s,width:a-i,height:n-s}}static getBox(t){if(!t.length)return null;let e=1/0,i=1/0,s=0,a=0;for(const n of t){const{height:r,left:o,top:l,width:c}=n.glyphMosaicItem.metrics,d=n.x,f=n.y-(r-Math.abs(l)),h=d+c+o,x=f+r;e=Math.min(e,d),s=Math.max(s,h),i=Math.min(i,f),a=Math.max(a,x)}return{x:e,y:i,width:s-e,height:a-i}}static addDecoration(t,e){const i=t.length;if(i===0)return;const s=3;let a=t[0].x+t[0].glyphMosaicItem.metrics.left,n=t[0].y;for(let o=1;o<i;o++){const l=t[o];if(l.y!==n){const c=t[o-1].x+t[o-1].glyphMosaicItem.metrics.left+t[o-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:a,y:n+e-s,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new De(4,0,4,8),metrics:{width:c-a,height:2+2*s,left:0,top:0,advance:0},page:0,code:0}}),n=l.y,a=l.x+l.glyphMosaicItem.metrics.left}}const r=t[i-1].x+t[i-1].glyphMosaicItem.metrics.left+t[i-1].glyphMosaicItem.metrics.width;t.push({codePoint:0,x:a,y:n+e-s,vertical:!1,glyphMosaicItem:{sdf:!0,rect:new De(4,0,4,8),metrics:{width:r-a,height:2+2*s,left:0,top:0,advance:0},page:0,code:0}})}_breakScore(t,e,i,s){const a=(t-e)*(t-e);return s?t<e?a/2:2*a:a+Math.abs(i)*i}_buildBreak(t,e,i,s,a,n){let r=null,o=this._breakScore(e,i,a,n);for(const l of s){const c=e-l.x,d=this._breakScore(c,i,a,n)+l.score;d<=o&&(r=l,o=d)}return{index:t,x:e,score:o,previousBreak:r}}_optimalBreaks(t){return t?this._optimalBreaks(t.previousBreak).concat(t.index):[]}_applyJustification(t,e,i){const s=t[i],a=s.vertical?G:s.glyphMosaicItem?s.glyphMosaicItem.metrics.advance:0,n=(s.x+a)*this._justify;for(let r=e;r<=i;r++)t[r].x-=n}}const Z=.5,ge=2;class de{constructor(t,e,i=0,s=-1,a=Z){this.x=t,this.y=e,this.angle=i,this.segment=s,this.minzoom=a}}class xe{constructor(t,e,i,s,a,n=Z,r=X){this.anchor=t,this.labelAngle=e,this.glyphAngle=i,this.page=s,this.alternateVerticalGlyph=a,this.minzoom=n,this.maxzoom=r}}class Ae{constructor(t,e,i,s,a,n,r,o,l,c,d,f){this.tl=t,this.tr=e,this.bl=i,this.br=s,this.mosaicRect=a,this.labelAngle=n,this.minAngle=r,this.maxAngle=o,this.anchor=l,this.minzoom=c,this.maxzoom=d,this.page=f}}let ve=class{constructor(u){this.shapes=u}};class it{getIconPlacement(t,e,i){const s=new L(t.x,t.y),a=i.rotationAlignment===0,n=i.keepUpright;let r=i.rotate*me;a&&(r+=t.angle);const o=new ve([]);return i.allowOverlap&&i.ignorePlacement||!Ve||(o.iconColliders=[]),this._addIconPlacement(o,s,e,i,r),a&&n&&this._addIconPlacement(o,s,e,i,r+ie),o}_addIconPlacement(t,e,i,s,a){const n=i.rasterizationScale,r=i.width/n,o=i.height/n,l=s.offset;let c=l[0],d=l[1];switch(s.anchor){case 0:c-=r/2,d-=o/2;break;case 1:d-=o/2;break;case 2:c-=r,d-=o/2;break;case 3:c-=r/2;break;case 4:c-=r/2,d-=o;break;case 5:break;case 7:d-=o;break;case 6:c-=r;break;case 8:c-=r,d-=o}const f=i.rect,h=2/n,x=c-h,g=d-h,w=x+f.width/n,y=g+f.height/n,_=new L(x,g),p=new L(w,y),I=new L(x,y),b=new L(w,g);if(a!==0){const M=Math.cos(a),D=Math.sin(a);_.rotate(M,D),p.rotate(M,D),I.rotate(M,D),b.rotate(M,D)}const m=new Ae(_,b,I,p,f,a,0,256,e,Z,X,0);if(t.shapes.push(m),(!s.allowOverlap||!s.ignorePlacement)&&Ve){const M=s.size,D=s.padding,P={xTile:e.x,yTile:e.y,dxPixels:c*M-D,dyPixels:d*M-D,hard:!s.optional,partIndex:0,width:r*M+2*D,height:o*M+2*D,angle:a,minLod:Z,maxLod:X};t.iconColliders.push(P)}}getTextPlacement(t,e,i,s){const a=new L(t.x,t.y),n=s.rotate*me,r=s.rotationAlignment===0,o=s.keepUpright,l=s.padding;let c=Z;const d=r?t.angle:0,f=t.segment>=0&&r,h=s.allowOverlap&&s.ignorePlacement?null:[],x=[],g=4,w=!f;let y=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=y,I=_;const b=(f||r)&&o,m=s.size/G;let M=!1;for(const B of e)if(B.vertical){M=!0;break}let D,P=0,V=0;if(!f&&M){const B=Ue.getTextBox(e,s.lineHeight*G);switch(s.anchor){case 1:P=B.height/2,V=-B.width/2;break;case 2:P=-B.height/2,V=B.width/2;break;case 3:P=B.height/2,V=B.width/2;break;case 4:P=-B.height/2,V=-B.width/2;break;case 5:P=B.height;break;case 7:V=-B.width;break;case 6:V=B.width;break;case 8:P=-B.height}}P+=s.offset[0]*G,V+=s.offset[1]*G;for(const B of e){const k=B.glyphMosaicItem;if(!k||k.rect.isEmpty)continue;const A=k.rect,v=k.metrics,z=k.page;if(h&&w){if(D!==void 0&&D!==B.y){let S,U,R,E;M?(S=-I+P,U=y+V,R=I-p,E=_-y):(S=y+P,U=p+V,R=_-y,E=I-p);const O={xTile:t.x,yTile:t.y,dxPixels:S*m-l,dyPixels:U*m-l,hard:!s.optional,partIndex:1,width:R*m+2*l,height:E*m+2*l,angle:n,minLod:Z,maxLod:X};h.push(O),y=Number.POSITIVE_INFINITY,_=Number.NEGATIVE_INFINITY,p=y,I=_}D=B.y}const j=[];if(f){const S=.5*k.metrics.width,U=(B.x+v.left-g+S)*m*re;if(c=this._placeGlyph(t,c,U,i,t.segment,1,B.vertical,z,j),o&&(c=this._placeGlyph(t,c,U,i,t.segment,-1,B.vertical,z,j)),c>=ge)break}else j.push(new xe(a,d,d,z,!1)),r&&o&&j.push(new xe(a,d+ie,d+ie,z,!1));const K=B.x+v.left,H=B.y-Fe-v.top,$=K+v.width,ee=H+v.height;let F,q,ae,oe,J,le,Ie,we;if(!f&&M)if(B.vertical){const S=(K+$)/2-v.height/2,U=(H+ee)/2+v.width/2;F=new L(-U-g+P,S-g+V),q=new L(F.x+A.width,F.y+A.height),ae=new L(F.x,q.y),oe=new L(q.x,F.y)}else F=new L(-H+g+P,K-g+V),q=new L(F.x-A.height,F.y+A.width),ae=new L(q.x,F.y),oe=new L(F.x,q.y);else F=new L(K-g+P,H-g+V),q=new L(F.x+A.width,F.y+A.height),ae=new L(F.x,q.y),oe=new L(q.x,F.y);for(const S of j){let U,R,E,O;if(S.alternateVerticalGlyph){if(!J){const W=(H+ee)/2+V;J=new L((K+$)/2+P-v.height/2-g,W+v.width/2+g),le=new L(J.x+A.height,J.y-A.width),Ie=new L(le.x,J.y),we=new L(J.x,le.y)}U=J,R=Ie,E=we,O=le}else U=F,R=ae,E=oe,O=q;const he=H,pe=ee,ce=S.glyphAngle+n;if(ce!==0){const W=Math.cos(ce),ue=Math.sin(ce);U=U.clone(),R=R==null?void 0:R.clone(),E=E==null?void 0:E.clone(),O=O==null?void 0:O.clone(),U.rotate(W,ue),O==null||O.rotate(W,ue),R==null||R.rotate(W,ue),E==null||E.rotate(W,ue)}let te=0,se=256;if(f&&M?B.vertical?S.alternateVerticalGlyph?(te=32,se=96):(te=224,se=32):(te=224,se=96):(te=192,se=64),x.push(new Ae(U,E,R,O,A,S.labelAngle,te,se,S.anchor,S.minzoom,S.maxzoom,S.page)),h&&(!b||this._legible(S.labelAngle))){if(w)K<y&&(y=K),he<p&&(p=he),$>_&&(_=$),pe>I&&(I=pe);else if(S.minzoom<ge){const W={xTile:t.x,yTile:t.y,dxPixels:(K+P)*m-l,dyPixels:(he+P)*m-l,hard:!s.optional,partIndex:1,width:($-K)*m+2*l,height:(pe-he)*m+2*l,angle:ce,minLod:S.minzoom,maxLod:S.maxzoom};h.push(W)}}}}if(c>=ge)return null;if(h&&w){let B,k,A,v;M?(B=-I+P,k=y+V,A=I-p,v=_-y):(B=y+P,k=p+V,A=_-y,v=I-p);const z={xTile:t.x,yTile:t.y,dxPixels:B*m-l,dyPixels:k*m-l,hard:!s.optional,partIndex:1,width:A*m+2*l,height:v*m+2*l,angle:n,minLod:Z,maxLod:X};h.push(z)}const T=new ve(x);return h&&h.length>0&&(T.textColliders=h),T}_legible(t){const e=ze(t);return e<65||e>=193}_placeGlyph(t,e,i,s,a,n,r,o,l){let c=n;const d=c<0?Pe(t.angle+ie,Be):t.angle;let f=0;i<0&&(c*=-1,i*=-1,f=ie),c>0&&++a;let h=new L(t.x,t.y),x=s[a],g=X;if(s.length<=a)return g;for(;;){const w=x.x-h.x,y=x.y-h.y,_=Math.sqrt(w*w+y*y),p=Math.max(i/_,e),I=w/_,b=y/_,m=Pe(Math.atan2(b,I)+f,Be);if(l.push(new xe(h,d,m,o,!1,p,g)),r&&l.push(new xe(h,d,m,o,!0,p,g)),p<=e)return p;h=x.clone();do{if(a+=c,s.length<=a||a<0)return p;x=s[a]}while(h.isEqual(x));let M=x.x-h.x,D=x.y-h.y;const P=Math.sqrt(M*M+D*D);M*=_/P,D*=_/P,h.x-=M,h.y-=D,g=p}}}let Q=class extends C{constructor(){super(12)}add(u,t,e){const i=this.array;i.push(u),i.push(t),i.push(e)}},rt=class extends C{constructor(u){super(u)}add(u,t,e,i,s,a,n,r,o,l,c,d){const f=this.array;let h=C.i1616to32(u,t);f.push(h);const x=31;h=C.i8888to32(Math.round(x*e),Math.round(x*i),Math.round(x*s),Math.round(x*a)),f.push(h),h=C.i8888to32(Math.round(x*n),Math.round(x*r),Math.round(x*o),Math.round(x*l)),f.push(h),h=C.i1616to32(c,0),f.push(h),d&&f.push(...d)}},nt=class extends C{constructor(u){super(u)}add(u,t,e){const i=this.array;i.push(C.i1616to32(u,t)),e&&i.push(...e)}},at=class extends C{constructor(u){super(u)}add(u,t,e,i,s,a,n){const r=this.array,o=this.index;let l=C.i1616to32(u,t);r.push(l);const c=15;return l=C.i8888to32(Math.round(c*e),Math.round(c*i),s,a),r.push(l),n&&r.push(...n),o}};class Te extends C{constructor(t){super(t)}add(t,e,i,s,a,n,r,o,l,c,d,f){const h=this.array;let x=C.i1616to32(t,e);h.push(x),x=C.i1616to32(Math.round(8*i),Math.round(8*s)),h.push(x),x=C.i8888to32(a/4,n/4,o,l),h.push(x),x=C.i8888to32(0,ze(r),10*c,Math.min(10*d,255)),h.push(x),f&&h.push(...f)}}class ot extends C{constructor(t){super(t)}add(t,e,i,s,a){const n=this.array,r=C.i1616to32(2*t+i,2*e+s);n.push(r),a&&n.push(...a)}}class ye{constructor(t,e,i){this.layerExtent=ne,this._features=[],this.layer=t,this.zoom=e,this._spriteInfo=i,this._filter=t.getFeatureFilter()}pushFeature(t){this._filter&&!this._filter.filter(t,this.zoom)||this._features.push(t)}hasFeatures(){return this._features.length>0}getResources(t,e,i){}}class lt extends ye{constructor(t,e,i,s,a){super(t,e,i),this.type=4,this._circleVertexBuffer=s,this._circleIndexBuffer=a}get circleIndexStart(){return this._circleIndexStart}get circleIndexCount(){return this._circleIndexCount}processFeatures(t){const e=this._circleVertexBuffer,i=this._circleIndexBuffer;this._circleIndexStart=3*i.index,this._circleIndexCount=0;const s=this.layer,a=this.zoom;t&&t.setExtent(this.layerExtent);for(const n of this._features){const r=n.getGeometry(t);if(!r)continue;const o=s.circleMaterial.encodeAttributes(n,a,s);for(const l of r)if(l)for(const c of l){const d=e.index;e.add(c.x,c.y,0,0,o),e.add(c.x,c.y,0,1,o),e.add(c.x,c.y,1,0,o),e.add(c.x,c.y,1,1,o),i.add(d,d+1,d+2),i.add(d+1,d+2,d+3),this._circleIndexCount+=6}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this._circleVertexBuffer.array.length,t+=this._circleIndexBuffer.array.length;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let s=0;e[s++]=this.type,e[s++]=this.layerUIDs.length;for(let a=0;a<this.layerUIDs.length;a++)e[s++]=this.layerUIDs[a];e[s++]=this._circleIndexStart,e[s++]=this._circleIndexCount,e[s++]=this._circleVertexBuffer.array.length;for(let a=0;a<this._circleVertexBuffer.array.length;a++)i[s++]=this._circleVertexBuffer.array[a];e[s++]=this._circleIndexBuffer.array.length;for(let a=0;a<this._circleIndexBuffer.array.length;a++)e[s++]=this._circleIndexBuffer.array[a];return e.buffer}}let ht=class Re extends ye{constructor(t,e,i,s,a,n,r){super(t,e,i),this.type=1,this._patternMap=new Map,this._fillVertexBuffer=s,this._fillIndexBuffer=a,this._outlineVertexBuffer=n,this._outlineIndexBuffer=r}get fillIndexStart(){return this._fillIndexStart}get fillIndexCount(){return this._fillIndexCount}get outlineIndexStart(){return this._outlineIndexStart}get outlineIndexCount(){return this._outlineIndexCount}getResources(t,e,i){const s=this.layer,a=this.zoom,n=s.getPaintProperty("fill-pattern");if(n)if(n.isDataDriven)for(const r of this._features)e(n.getValue(a,r),!0);else e(n.getValue(a),!0)}processFeatures(t){this._fillIndexStart=3*this._fillIndexBuffer.index,this._fillIndexCount=0,this._outlineIndexStart=3*this._outlineIndexBuffer.index,this._outlineIndexCount=0;const e=this.layer,i=this.zoom,{fillMaterial:s,outlineMaterial:a,hasDataDrivenFill:n,hasDataDrivenOutline:r}=e;t&&t.setExtent(this.layerExtent);const o=e.getPaintProperty("fill-pattern"),l=o==null?void 0:o.isDataDriven;let c=!o&&e.getPaintValue("fill-antialias",i);if(e.outlineUsesFillColor){if(c&&!e.hasDataDrivenOpacity){const h=e.getPaintValue("fill-opacity",i),x=e.getPaintValue("fill-opacity",i+1);h<1&&x<1&&(c=!1)}if(c&&!e.hasDataDrivenColor){const h=e.getPaintValue("fill-color",i),x=e.getPaintValue("fill-color",i+1);h[3]<1&&x[3]<1&&(c=!1)}}const d=this._features,f=t==null?void 0:t.validateTessellation;if(l){const h=[];for(const x of d){const g=o.getValue(i,x),w=this._spriteInfo[g];if(!(w!=null&&w.rect))continue;const y=s.encodeAttributes(x,i,e,w),_=c&&r?a.encodeAttributes(x,i,e):[],p=x.getGeometry(t);h.push({ddFillAttributes:y,ddOutlineAttributes:_,page:w.page,geometry:p}),h.sort((I,b)=>I.page-b.page);for(const{ddFillAttributes:I,ddOutlineAttributes:b,page:m,geometry:M}of h)this._processFeature(M,c,e.outlineUsesFillColor,I,b,f,m)}}else for(const h of d){const x=n?s.encodeAttributes(h,i,e):null,g=c&&r?a.encodeAttributes(h,i,e):null,w=h.getGeometry(t);this._processFeature(w,c,e.outlineUsesFillColor,x,g,f)}}serialize(){let t=10;t+=this.layerUIDs.length,t+=this._fillVertexBuffer.array.length,t+=this._fillIndexBuffer.array.length,t+=this._outlineVertexBuffer.array.length,t+=this._outlineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let s=0;e[s++]=this.type,e[s++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)e[s++]=this.layerUIDs[r];e[s++]=this._fillIndexStart,e[s++]=this._fillIndexCount,e[s++]=this._outlineIndexStart,e[s++]=this._outlineIndexCount;const a=this._patternMap,n=a.size;if(e[s++]=n,n>0)for(const[r,[o,l]]of a)e[s++]=r,e[s++]=o,e[s++]=l;e[s++]=this._fillVertexBuffer.array.length;for(let r=0;r<this._fillVertexBuffer.array.length;r++)i[s++]=this._fillVertexBuffer.array[r];e[s++]=this._fillIndexBuffer.array.length;for(let r=0;r<this._fillIndexBuffer.array.length;r++)e[s++]=this._fillIndexBuffer.array[r];e[s++]=this._outlineVertexBuffer.array.length;for(let r=0;r<this._outlineVertexBuffer.array.length;r++)i[s++]=this._outlineVertexBuffer.array[r];e[s++]=this._outlineIndexBuffer.array.length;for(let r=0;r<this._outlineIndexBuffer.array.length;r++)e[s++]=this._outlineIndexBuffer.array[r];return e.buffer}_processFeature(t,e,i,s,a,n,r){if(!t)return;const o=t.length,l=!a||a.length===0;if(e&&(!i||l))for(let f=0;f<o;f++)this._processOutline(t[f],a);const c=32;let d;for(let f=0;f<o;f++){const h=Re._area(t[f]);h>c?(d!==void 0&&this._processFill(t,d,s,n,r),d=[f]):h<-c&&d!==void 0&&d.push(f)}d!==void 0&&this._processFill(t,d,s,n,r)}_processOutline(t,e){const i=this._outlineVertexBuffer,s=this._outlineIndexBuffer,a=s.index;let n,r,o;const l=new L(0,0),c=new L(0,0),d=new L(0,0);let f=-1,h=-1,x=-1,g=-1,w=-1,y=!1;const _=0;let p=t.length;if(p<2)return;const I=t[_];let b=t[p-1];for(;p&&b.isEqual(I);)--p,b=t[p-1];if(!(p-_<2)){for(let m=_;m<p;++m){m===_?(n=t[p-1],r=t[_],o=t[_+1],l.assignSub(r,n),l.normalize(),l.rightPerpendicular()):(n=r,r=o,o=m!==p-1?t[m+1]:t[_],l.assign(c));const M=this._isClipEdge(n,r);g===-1&&(y=M),c.assignSub(o,r),c.normalize(),c.rightPerpendicular();const D=l.x*c.y-l.y*c.x;d.assignAdd(l,c),d.normalize();const P=-d.x*-l.x+-d.y*-l.y;let V=Math.abs(P!==0?1/P:1);V>8&&(V=8),D>=0?(x=i.add(r.x,r.y,l.x,l.y,0,1,e),g===-1&&(g=x),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),h=i.add(r.x,r.y,V*-d.x,V*-d.y,0,-1,e),w===-1&&(w=h),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),f=h,h=x,x=i.add(r.x,r.y,d.x,d.y,0,1,e),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),h=i.add(r.x,r.y,c.x,c.y,0,1,e),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x)):(x=i.add(r.x,r.y,V*d.x,V*d.y,0,1,e),g===-1&&(g=x),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),h=i.add(r.x,r.y,-l.x,-l.y,0,-1,e),w===-1&&(w=h),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),f=h,h=x,x=i.add(r.x,r.y,-d.x,-d.y,0,-1,e),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x),f=i.add(r.x,r.y,-c.x,-c.y,0,-1,e),f>=0&&h>=0&&x>=0&&!M&&s.add(f,h,x))}f>=0&&h>=0&&g>=0&&!y&&s.add(f,h,g),f>=0&&g>=0&&w>=0&&!y&&s.add(f,w,g),this._outlineIndexCount+=3*(s.index-a)}}_processFill(t,e,i,s,a){s=!0;let n;e.length>1&&(n=[]);let r=0;for(const d of e)r!==0&&n.push(r),r+=t[d].length;const o=2*r,l=Me.acquire();for(const d of e){const f=t[d],h=f.length;for(let x=0;x<h;++x)l.push(f[x].x,f[x].y)}const c=Le(l,n,2);if(s&&Le.deviation(l,n,2,c)>0){const d=e.map(x=>t[x].length),{buffer:f,vertexCount:h}=He(l,d);if(h>0){const x=this._fillVertexBuffer.index;for(let g=0;g<h;g++)this._fillVertexBuffer.add(f[2*g],f[2*g+1],i);for(let g=0;g<h;g+=3){const w=x+g;this._fillIndexBuffer.add(w,w+1,w+2)}if(a!==void 0){const g=this._patternMap,w=g.get(a);w?w[1]+=h:g.set(a,[this._fillIndexStart+this._fillIndexCount,h])}this._fillIndexCount+=h}}else{const d=c.length;if(d>0){const f=this._fillVertexBuffer.index;let h=0;for(;h<o;)this._fillVertexBuffer.add(l[h++],l[h++],i);let x=0;for(;x<d;)this._fillIndexBuffer.add(f+c[x++],f+c[x++],f+c[x++]);if(a!==void 0){const g=this._patternMap,w=g.get(a);w?w[1]+=d:g.set(a,[this._fillIndexStart+this._fillIndexCount,d])}this._fillIndexCount+=d}}Me.release(l)}_isClipEdge(t,e){return t.x===e.x?t.x<=-64||t.x>=4160:t.y===e.y&&(t.y<=-64||t.y>=4160)}static _area(t){let e=0;const i=t.length-1;for(let s=0;s<i;s++)e+=(t[s].x-t[s+1].x)*(t[s].y+t[s+1].y);return e+=(t[i].x-t[0].x)*(t[i].y+t[0].y),.5*e}};const ct=65535;class ut extends ye{constructor(t,e,i,s,a){super(t,e,i),this.type=2,this._tessellationOptions={pixelCoordRatio:8,halfWidth:0,offset:0},this._patternMap=new Map,this.tessellationProperties={_lineVertexBuffer:null,_lineIndexBuffer:null,_ddValues:null},this.tessellationProperties._lineVertexBuffer=s,this.tessellationProperties._lineIndexBuffer=a,this._lineTessellator=new We(ft(this.tessellationProperties),dt(this.tessellationProperties),t.canUseThinTessellation)}get lineIndexStart(){return this._lineIndexStart}get lineIndexCount(){return this._lineIndexCount}getResources(t,e,i){const s=this.layer,a=this.zoom,n=s.getPaintProperty("line-pattern"),r=s.getPaintProperty("line-dasharray"),o=s.getLayoutProperty("line-cap");if(!n&&!r)return;const l=(o==null?void 0:o.getValue(a))||0,c=o==null?void 0:o.isDataDriven,d=n==null?void 0:n.isDataDriven,f=r==null?void 0:r.isDataDriven;if(d||f)for(const h of this._features)e(d?n.getValue(a,h):this._getDashArrayKey(h,a,s,r,c,o,l));else if(n)e(n.getValue(a));else if(r){const h=r.getValue(a);e(s.getDashKey(h,l))}}processFeatures(t){var T;this._lineIndexStart=3*this.tessellationProperties._lineIndexBuffer.index,this._lineIndexCount=0;const e=this.layer,i=this.zoom,s=this._features,a=this._tessellationOptions,{hasDataDrivenLine:n,lineMaterial:r}=e;t&&t.setExtent(this.layerExtent);const o=e.getPaintProperty("line-pattern"),l=e.getPaintProperty("line-dasharray"),c=o==null?void 0:o.isDataDriven,d=l==null?void 0:l.isDataDriven;let f;f=e.getLayoutProperty("line-cap");const h=f!=null&&f.isDataDriven?f:null,x=h?null:e.getLayoutValue("line-cap",i),g=x||0,w=!!h;f=e.getLayoutProperty("line-join");const y=f!=null&&f.isDataDriven?f:null,_=y?null:e.getLayoutValue("line-join",i);f=e.getLayoutProperty("line-miter-limit");const p=f!=null&&f.isDataDriven?f:null,I=p?null:e.getLayoutValue("line-miter-limit",i);f=e.getLayoutProperty("line-round-limit");const b=f!=null&&f.isDataDriven?f:null,m=b?null:e.getLayoutValue("line-round-limit",i);f=e.getPaintProperty("line-width");const M=f!=null&&f.isDataDriven?f:null,D=M?null:e.getPaintValue("line-width",i);f=e.getPaintProperty("line-offset");const P=f!=null&&f.isDataDriven?f:null,V=P?null:e.getPaintValue("line-offset",i);if(c||d){const B=[];for(const k of s){const A=c?o.getValue(i,k):this._getDashArrayKey(k,i,e,l,w,h,g),v=this._spriteInfo[A];if(!(v!=null&&v.rect))continue;const z=r.encodeAttributes(k,i,e,v),j=k.getGeometry(t);B.push({ddAttributes:z,page:v.page,cap:h?h.getValue(i,k):x,join:y?y.getValue(i,k):_,miterLimit:p?p.getValue(i,k):I,roundLimit:b?b.getValue(i,k):m,halfWidth:.5*(M?M.getValue(i,k):D),offset:P?P.getValue(i,k):V,geometry:j})}B.sort((k,A)=>k.page-A.page),a.textured=!0;for(const{ddAttributes:k,page:A,cap:v,join:z,miterLimit:j,roundLimit:K,halfWidth:H,offset:$,geometry:ee}of B)a.capType=v,a.joinType=z,a.miterLimit=j,a.roundLimit=K,a.halfWidth=H,a.offset=$,this._processFeature(ee,k,A)}else{if(o){const B=o.getValue(i);if(!((T=this._spriteInfo[B])!=null&&T.rect))return}a.textured=!(!o&&!l),a.capType=x,a.joinType=_,a.miterLimit=I,a.roundLimit=m,a.halfWidth=.5*D,a.offset=V;for(const B of s){const k=n?r.encodeAttributes(B,i,e):null;h&&(a.capType=h.getValue(i,B)),y&&(a.joinType=y.getValue(i,B)),p&&(a.miterLimit=p.getValue(i,B)),b&&(a.roundLimit=b.getValue(i,B)),M&&(a.halfWidth=.5*M.getValue(i,B)),P&&(a.offset=P.getValue(i,B));const A=B.getGeometry(t);this._processFeature(A,k)}}}serialize(){let t=6;t+=this.layerUIDs.length,t+=this.tessellationProperties._lineVertexBuffer.array.length,t+=this.tessellationProperties._lineIndexBuffer.array.length,t+=3*this._patternMap.size+1;const e=new Uint32Array(t),i=new Int32Array(e.buffer);let s=0;e[s++]=this.type,e[s++]=this.layerUIDs.length;for(let r=0;r<this.layerUIDs.length;r++)e[s++]=this.layerUIDs[r];e[s++]=this._lineIndexStart,e[s++]=this._lineIndexCount;const a=this._patternMap,n=a.size;if(e[s++]=n,n>0)for(const[r,[o,l]]of a)e[s++]=r,e[s++]=o,e[s++]=l;e[s++]=this.tessellationProperties._lineVertexBuffer.array.length;for(let r=0;r<this.tessellationProperties._lineVertexBuffer.array.length;r++)i[s++]=this.tessellationProperties._lineVertexBuffer.array[r];e[s++]=this.tessellationProperties._lineIndexBuffer.array.length;for(let r=0;r<this.tessellationProperties._lineIndexBuffer.array.length;r++)e[s++]=this.tessellationProperties._lineIndexBuffer.array[r];return e.buffer}_processFeature(t,e,i){if(!t)return;const s=t.length;for(let a=0;a<s;a++)this._processGeometry(t[a],e,i)}_processGeometry(t,e,i){if(t.length<2)return;const s=.001;let a,n,r=t[0],o=1;for(;o<t.length;)a=t[o].x-r.x,n=t[o].y-r.y,a*a+n*n<s*s?t.splice(o,1):(r=t[o],++o);if(t.length<2)return;const l=this.tessellationProperties._lineIndexBuffer,c=3*l.index;this._tessellationOptions.initialDistance=0,this._tessellationOptions.wrapDistance=ct,this.tessellationProperties._ddValues=e,this._lineTessellator.tessellate(t,this._tessellationOptions);const d=3*l.index-c;if(i!==void 0){const f=this._patternMap,h=f.get(i);h?h[1]+=d:f.set(i,[c+this._lineIndexCount,d])}this._lineIndexCount+=d}_getDashArrayKey(t,e,i,s,a,n,r){const o=a?n.getValue(e,t):r,l=s.getValue(e,t);return i.getDashKey(l,o)}}const ft=u=>(t,e,i,s,a,n,r,o,l,c,d)=>(u._lineVertexBuffer.add(t,e,r,o,i,s,a,n,l,c,d,u._ddValues),u._lineVertexBuffer.index-1),dt=u=>(t,e,i)=>{u._lineIndexBuffer.add(t,e,i)},Se=10;function xt(u,t){return u.iconMosaicItem&&t.iconMosaicItem?u.iconMosaicItem.page===t.iconMosaicItem.page?0:u.iconMosaicItem.page-t.iconMosaicItem.page:u.iconMosaicItem&&!t.iconMosaicItem?1:!u.iconMosaicItem&&t.iconMosaicItem?-1:0}const N=class N extends ye{constructor(t,e,i,s,a,n,r,o,l){super(e,i,l.getSpriteItems()),this.type=3,this._markerMap=new Map,this._glyphMap=new Map,this._glyphBufferDataStorage=new Map,this._isIconSDF=!1,this._sourceTileKey=t,this._iconVertexBuffer=s,this._iconIndexBuffer=a,this._textVertexBuffer=n,this._textIndexBuffer=r,this._placementEngine=o,this._workerTileHandler=l}get markerPageMap(){return this._markerMap}get glyphsPageMap(){return this._glyphMap}get symbolInstances(){return this._symbolInstances}getResources(t,e,i){const s=this.layer,a=this.zoom;t&&t.setExtent(this.layerExtent);const n=s.getLayoutProperty("icon-image"),r=s.getLayoutProperty("text-field");let o=s.getLayoutProperty("text-transform"),l=s.getLayoutProperty("text-font");const c=[];let d,f,h,x;n&&!n.isDataDriven&&(d=n.getValue(a)),r&&!r.isDataDriven&&(f=r.getValue(a)),o&&o.isDataDriven||(h=s.getLayoutValue("text-transform",a),o=null),l&&l.isDataDriven||(x=s.getLayoutValue("text-font",a),l=null);for(const g of this._features){const w=g.getGeometry(t);if(!w||w.length===0)continue;let y,_;n&&(y=n.isDataDriven?n.getValue(a,g):this._replaceKeys(d,g.values),y&&e(y));let p=!1;if(r&&(_=r.isDataDriven?r.getValue(a,g):this._replaceKeys(f,g.values),_)){switch(_=_.replaceAll("\\n",`
`),o&&(h=o.getValue(a,g)),h){case 2:_=_.toLowerCase();break;case 1:_=_.toUpperCase()}if(N._bidiEngine.hasBidiChar(_)){let m;m=N._bidiEngine.checkContextual(_)==="rtl"?"IDNNN":"ICNNN",_=N._bidiEngine.bidiTransform(_,m,"VLYSN"),p=!0}if(_.length>0){l&&(x=l.getValue(a,g));for(const m of x){let M=i[m];M||(M=i[m]=new Set);for(const D of _){const P=D.codePointAt(0);P!=null&&M.add(P)}}}}if(!y&&!_)continue;const I=s.getLayoutValue("symbol-sort-key",a,g),b={feature:g,sprite:y,label:_,rtl:p,geometry:w,hash:(_?be(_):0)^(y?be(y):0),priority:I,textFont:x};c.push(b)}this._symbolFeatures=c}processFeatures(t){t&&t.setExtent(this.layerExtent);const e=this.layer,i=this.zoom,s=e.getLayoutValue("symbol-placement",i),a=s!==0,n=e.getLayoutValue("symbol-spacing",i)*re,r=e.getLayoutProperty("icon-image"),o=e.getLayoutProperty("text-field"),l=r?new Ze(e,i,a):null,c=o?new Qe(e,i,a):null,d=this._workerTileHandler;let f;r&&(f=d.getSpriteItems()),this._iconIndexStart=3*this._iconIndexBuffer.index,this._textIndexStart=3*this._textIndexBuffer.index,this._iconIndexCount=0,this._textIndexCount=0,this._markerMap.clear(),this._glyphMap.clear();const h=[];let x=1;c!=null&&c.size&&(x=c.size/G);const g=c?c.maxAngle*me:0,w=c?c.size*re:0;for(const y of this._symbolFeatures){let _;l&&f&&y.sprite&&(_=f[y.sprite],_&&_.sdf&&(this._isIconSDF=!0));let p;_&&l.update(i,y.feature);let I=0;const b=y.label;if(b){Ne(c),c.update(i,y.feature);const m=a&&c.rotationAlignment===0?c.keepUpright:c.writingMode&&c.writingMode.includes(1);let M=.5;switch(c.anchor){case 5:case 1:case 7:M=0;break;case 6:case 2:case 8:M=1}let D=.5;switch(c.anchor){case 5:case 3:case 6:D=0;break;case 7:case 4:case 8:D=1}let P=.5;switch(c.justify){case 0:P=M;break;case 1:P=0;break;case 3:P=1}const V=c.letterSpacing*G,T=a?0:c.maxWidth*G,B=c.lineHeight*G,k=y.textFont.map(A=>d.getGlyphItems(A));if(p=new Ue(k,T,B,V,M,D,P).getShaping(b,y.rtl,m),p&&p.length>0){let A=1e30,v=-1e30;for(const z of p)A=Math.min(A,z.x),v=Math.max(v,z.x);I=(v-A+2*G)*x*re}}for(let m of y.geometry){const M=[];if(s===1){if(p!=null&&p.length&&(c!=null&&c.size)){const D=c.size*re*(2+Math.min(2,4*Math.abs(c.offset[1])));m=N._smoothVertices(m,D)}N._pushAnchors(M,m,n,I)}else s===2?N._pushCenterAnchor(M,m):y.feature.type===3?N._pushCentroid(M,m):M.push(new de(m[0].x,m[0].y));for(const D of M){if(D.x<0||D.x>ne||D.y<0||D.y>ne||a&&I>0&&(c==null?void 0:c.rotationAlignment)===0&&!N._honorsTextMaxAngle(m,D,I,g,w))continue;const P={shaping:p,line:m,iconMosaicItem:_,anchor:D,symbolFeature:y,textColliders:[],iconColliders:[],textVertexRanges:[],iconVertexRanges:[]};h.push(P),this._processFeature(P,l,c)}}}h.sort(xt),this._addPlacedGlyphs(),this._symbolInstances=h}serialize(){let t=14;t+=this.layerUIDs.length,t+=3*this.markerPageMap.size,t+=3*this.glyphsPageMap.size,t+=N._symbolsSerializationLength(this._symbolInstances),t+=this._iconVertexBuffer.array.length,t+=this._iconIndexBuffer.array.length,t+=this._textVertexBuffer.array.length,t+=this._textIndexBuffer.array.length;const e=new Uint32Array(t),i=new Int32Array(e.buffer),s=new Float32Array(e.buffer),[a,n,r]=this._sourceTileKey.split("/");let o=0;e[o++]=this.type,e[o++]=this.layerUIDs.length;for(let l=0;l<this.layerUIDs.length;l++)e[o++]=this.layerUIDs[l];e[o++]=this._isIconSDF?1:0,e[o++]=parseFloat(a),e[o++]=parseFloat(n),e[o++]=parseFloat(r),e[o++]=this.markerPageMap.size;for(const[l,[c,d]]of this.markerPageMap)e[o++]=l,e[o++]=c,e[o++]=d;e[o++]=this.glyphsPageMap.size;for(const[l,[c,d]]of this.glyphsPageMap)e[o++]=l,e[o++]=c,e[o++]=d;e[o++]=this._iconVertexBuffer.index/4,e[o++]=this._textVertexBuffer.index/4,o=N.serializeSymbols(e,i,s,o,this._symbolInstances),e[o++]=this._iconVertexBuffer.array.length;for(let l=0;l<this._iconVertexBuffer.array.length;l++)i[o++]=this._iconVertexBuffer.array[l];e[o++]=this._iconIndexBuffer.array.length;for(let l=0;l<this._iconIndexBuffer.array.length;l++)e[o++]=this._iconIndexBuffer.array[l];e[o++]=this._textVertexBuffer.array.length;for(let l=0;l<this._textVertexBuffer.array.length;l++)i[o++]=this._textVertexBuffer.array[l];e[o++]=this._textIndexBuffer.array.length;for(let l=0;l<this._textIndexBuffer.array.length;l++)e[o++]=this._textIndexBuffer.array[l];return e.buffer}static _symbolsSerializationLength(t){let e=0;e+=1;for(const i of t||[]){e+=5,e+=1;for(const s of i.textColliders)e+=Se;for(const s of i.iconColliders)e+=Se;e+=1,e+=2*i.textVertexRanges.length,e+=1,e+=2*i.iconVertexRanges.length}return e}static serializeSymbols(t,e,i,s,a){a=a||[],e[s++]=a.length;for(const n of a){e[s++]=n.anchor.x,e[s++]=n.anchor.y,e[s++]=n.symbolFeature.hash,e[s++]=n.symbolFeature.priority,e[s++]=n.symbolFeature.feature.featureIndex,e[s++]=n.textColliders.length+n.iconColliders.length;for(const r of n.textColliders)e[s++]=r.xTile,e[s++]=r.yTile,e[s++]=r.dxPixels,e[s++]=r.dyPixels,e[s++]=r.hard?1:0,e[s++]=r.partIndex,i[s++]=r.minLod,i[s++]=r.maxLod,e[s++]=r.width,e[s++]=r.height;for(const r of n.iconColliders)e[s++]=r.xTile,e[s++]=r.yTile,e[s++]=r.dxPixels,e[s++]=r.dyPixels,e[s++]=r.hard?1:0,e[s++]=r.partIndex,i[s++]=r.minLod,i[s++]=r.maxLod,e[s++]=r.width,e[s++]=r.height;e[s++]=n.textVertexRanges.length;for(const[r,o]of n.textVertexRanges)e[s++]=r,e[s++]=o;e[s++]=n.iconVertexRanges.length;for(const[r,o]of n.iconVertexRanges)e[s++]=r,e[s++]=o}return s}_replaceKeys(t,e){return t.replaceAll(/{([^{}]+)}/g,(i,s)=>s in e?e[s]:"")}_processFeature(t,e,i){const{line:s,iconMosaicItem:a,shaping:n,anchor:r}=t,o=this.zoom,l=this.layer,c=!!a;let d=!0;c&&(d=(e==null?void 0:e.optional)||!a);const f=n&&n.length>0,h=!f||(i==null?void 0:i.optional);let x,g;if(c&&(x=this._placementEngine.getIconPlacement(r,a,e)),(x||d)&&(f&&(g=this._placementEngine.getTextPlacement(r,n,s,i)),g||h)){if(x&&g||(h||d?h||g?d||x||(g=null):x=null:(x=null,g=null)),g){const w=l.hasDataDrivenText?l.textMaterial.encodeAttributes(t.symbolFeature.feature,o,l):null;if(this._storePlacedGlyphs(t,g.shapes,o,i.rotationAlignment,w),g.textColliders){t.textColliders=g.textColliders;for(const y of g.textColliders){y.minLod=Math.max(o+Y(y.minLod),0),y.maxLod=Math.min(o+Y(y.maxLod),25);const _=y.angle;if(_){const p=Math.cos(_),I=Math.sin(_),b=y.dxPixels*p-y.dyPixels*I,m=y.dxPixels*I+y.dyPixels*p,M=(y.dxPixels+y.width)*p-y.dyPixels*I,D=(y.dxPixels+y.width)*I+y.dyPixels*p,P=y.dxPixels*p-(y.dyPixels+y.height)*I,V=y.dxPixels*I+(y.dyPixels+y.height)*p,T=(y.dxPixels+y.width)*p-(y.dyPixels+y.height)*I,B=(y.dxPixels+y.width)*I+(y.dyPixels+y.height)*p,k=Math.min(b,M,P,T),A=Math.max(b,M,P,T),v=Math.min(m,D,V,B),z=Math.max(m,D,V,B);y.dxPixels=k,y.dyPixels=v,y.width=A-k,y.height=z-v}}}}if(x){const w=l.hasDataDrivenIcon?l.iconMaterial.encodeAttributes(t.symbolFeature.feature,o,l):null;if(this._addPlacedIcons(t,x.shapes,o,a.page,e.rotationAlignment===1,w),x.iconColliders){t.iconColliders=x.iconColliders;for(const y of x.iconColliders){y.minLod=Math.max(o+Y(y.minLod),0),y.maxLod=Math.min(o+Y(y.maxLod),25);const _=y.angle;if(_){const p=Math.cos(_),I=Math.sin(_),b=y.dxPixels*p-y.dyPixels*I,m=y.dxPixels*I+y.dyPixels*p,M=(y.dxPixels+y.width)*p-y.dyPixels*I,D=(y.dxPixels+y.width)*I+y.dyPixels*p,P=y.dxPixels*p-(y.dyPixels+y.height)*I,V=y.dxPixels*I+(y.dyPixels+y.height)*p,T=(y.dxPixels+y.width)*p-(y.dyPixels+y.height)*I,B=(y.dxPixels+y.width)*I+(y.dyPixels+y.height)*p,k=Math.min(b,M,P,T),A=Math.max(b,M,P,T),v=Math.min(m,D,V,B),z=Math.max(m,D,V,B);y.dxPixels=k,y.dyPixels=v,y.width=A-k,y.height=z-v}}}}}}_addPlacedIcons(t,e,i,s,a,n){const r=Math.max(i-1,0),o=this._iconVertexBuffer,l=this._iconIndexBuffer,c=this._markerMap;for(const d of e){const f=a?0:Math.max(i+Y(d.minzoom),r),h=a?25:Math.min(i+Y(d.maxzoom),25);if(h<=f)continue;const x=d.tl,g=d.tr,w=d.bl,y=d.br,_=d.mosaicRect,p=d.labelAngle,I=d.minAngle,b=d.maxAngle,m=d.anchor,M=o.index,D=_.x,P=_.y,V=D+_.width,T=P+_.height,B=o.index;o.add(m.x,m.y,x.x,x.y,D,P,p,I,b,f,h,n),o.add(m.x,m.y,g.x,g.y,V,P,p,I,b,f,h,n),o.add(m.x,m.y,w.x,w.y,D,T,p,I,b,f,h,n),o.add(m.x,m.y,y.x,y.y,V,T,p,I,b,f,h,n),t.iconVertexRanges.length>0&&t.iconVertexRanges[0][0]+t.iconVertexRanges[0][1]===B?t.iconVertexRanges[0][1]+=4:t.iconVertexRanges.push([B,4]),l.add(M,M+1,M+2),l.add(M+1,M+2,M+3),c.has(s)?c.get(s)[1]+=6:c.set(s,[this._iconIndexStart+this._iconIndexCount,6]),this._iconIndexCount+=6}}_addPlacedGlyphs(){const t=this._textVertexBuffer,e=this._textIndexBuffer,i=this._glyphMap;for(const[s,a]of this._glyphBufferDataStorage)for(const n of a){const r=t.index,o=n.symbolInstance,l=n.ddAttributes,c=t.index;t.add(n.glyphAnchor[0],n.glyphAnchor[1],n.tl[0],n.tl[1],n.xmin,n.ymin,n.labelAngle,n.minAngle,n.maxAngle,n.minLod,n.maxLod,l),t.add(n.glyphAnchor[0],n.glyphAnchor[1],n.tr[0],n.tr[1],n.xmax,n.ymin,n.labelAngle,n.minAngle,n.maxAngle,n.minLod,n.maxLod,l),t.add(n.glyphAnchor[0],n.glyphAnchor[1],n.bl[0],n.bl[1],n.xmin,n.ymax,n.labelAngle,n.minAngle,n.maxAngle,n.minLod,n.maxLod,l),t.add(n.glyphAnchor[0],n.glyphAnchor[1],n.br[0],n.br[1],n.xmax,n.ymax,n.labelAngle,n.minAngle,n.maxAngle,n.minLod,n.maxLod,l),o.textVertexRanges.length>0&&o.textVertexRanges[0][0]+o.textVertexRanges[0][1]===c?o.textVertexRanges[0][1]+=4:o.textVertexRanges.push([c,4]),e.add(r,r+1,r+2),e.add(r+1,r+2,r+3),i.has(s)?i.get(s)[1]+=6:i.set(s,[this._textIndexStart+this._textIndexCount,6]),this._textIndexCount+=6}this._glyphBufferDataStorage.clear()}_storePlacedGlyphs(t,e,i,s,a){const n=Math.max(i-1,0),r=s===1;let o,l,c,d,f,h,x,g,w,y,_;for(const p of e)o=r?0:Math.max(i+Y(p.minzoom),n),l=r?25:Math.min(i+Y(p.maxzoom),25),!(l<=o)&&(c=p.tl,d=p.tr,f=p.bl,h=p.br,x=p.labelAngle,g=p.minAngle,w=p.maxAngle,y=p.anchor,_=p.mosaicRect,this._glyphBufferDataStorage.has(p.page)||this._glyphBufferDataStorage.set(p.page,[]),this._glyphBufferDataStorage.get(p.page).push({glyphAnchor:[y.x,y.y],tl:[c.x,c.y],tr:[d.x,d.y],bl:[f.x,f.y],br:[h.x,h.y],xmin:_.x,ymin:_.y,xmax:_.x+_.width,ymax:_.y+_.height,labelAngle:x,minAngle:g,maxAngle:w,minLod:o,maxLod:l,placementLod:n,symbolInstance:t,ddAttributes:a}))}static _pushAnchors(t,e,i,s){i+=s;let a=0;const n=e.length-1;for(let f=0;f<n;f++)a+=L.distance(e[f],e[f+1]);let r=s||i;if(r*=.5,a<=r)return;const o=r/a;let l=0,c=-(i=a/Math.max(Math.round(a/i),1))/2;const d=e.length-1;for(let f=0;f<d;f++){const h=e[f],x=e[f+1],g=x.x-h.x,w=x.y-h.y,y=Math.sqrt(g*g+w*w);let _;for(;c+i<l+y;){c+=i;const p=(c-l)/y,I=fe(h.x,x.x,p),b=fe(h.y,x.y,p);_===void 0&&(_=Math.atan2(w,g)),t.push(new de(I,b,_,f,o))}l+=y}}static _pushCenterAnchor(t,e){let i=0;const s=e.length-1;for(let o=0;o<s;o++)i+=L.distance(e[o],e[o+1]);const a=i/2;let n=0;const r=e.length-1;for(let o=0;o<r;o++){const l=e[o],c=e[o+1],d=c.x-l.x,f=c.y-l.y,h=Math.sqrt(d*d+f*f);if(a<n+h){const x=(a-n)/h,g=fe(l.x,c.x,x),w=fe(l.y,c.y,x),y=Math.atan2(f,d);return void t.push(new de(g,w,y,o,0))}n+=h}}static _deviation(t,e,i){const s=(e.x-t.x)*(i.x-e.x)+(e.y-t.y)*(i.y-e.y),a=(e.x-t.x)*(i.y-e.y)-(e.y-t.y)*(i.x-e.x);return Math.atan2(a,s)}static _honorsTextMaxAngle(t,e,i,s,a){let n=0;const r=i/2;let o=new L(e.x,e.y),l=e.segment+1;for(;n>-r;){if(--l,l<0)return!1;n-=L.distance(t[l],o),o=t[l]}n+=L.distance(t[l],t[l+1]);const c=[];let d=0;const f=t.length;for(;n<r;){const h=t[l];let x,g=l;do{if(++g,g===f)return!1;x=t[g]}while(x.isEqual(h));let w,y=g;do{if(++y,y===f)return!1;w=t[y]}while(w.isEqual(x));const _=this._deviation(h,x,w);for(c.push({deviation:_,distToAnchor:n}),d+=_;n-c[0].distToAnchor>a;)d-=c.shift().deviation;if(Math.abs(d)>s)return!1;n+=L.distance(x,w),l=g}return!0}static _smoothVertices(t,e){if(e<=0)return t;let i=t.length;if(i<3)return t;const s=[];let a=0,n=0;s.push(0);for(let g=1;g<i;g++){const w=L.distance(t[g],t[g-1]);w>0&&(a+=w,s.push(a),n++,n!==g&&(t[n]=t[g]))}if(i=n+1,i<3)return t;e=Math.min(e,.2*a);const r=t[0].x,o=t[0].y,l=t[i-1].x,c=t[i-1].y,d=L.sub(t[0],t[1]);d.normalize(),t[0].x+=e*d.x,t[0].y+=e*d.y,d.assignSub(t[i-1],t[i-2]),d.normalize(),t[i-1].x+=e*d.x,t[i-1].y+=e*d.y,s[0]-=e,s[i-1]+=e;const f=[];f.push(new L(r,o));const h=1e-6,x=.5*e;for(let g=1;g<i-1;g++){let w=0,y=0,_=0;for(let p=g-1;p>=0;p--){const I=x+s[p+1]-s[g];if(I<0)break;const b=s[p+1]-s[p],m=s[g]-s[p]<x?1:I/b;if(m<h)break;const M=m*m,D=m*I-.5*M*b,P=m*b/e,V=t[p+1],T=t[p].x-V.x,B=t[p].y-V.y;w+=P/D*(V.x*m*I+.5*M*(I*T-b*V.x)-M*m*b*T/3),y+=P/D*(V.y*m*I+.5*M*(I*B-b*V.y)-M*m*b*B/3),_+=P}for(let p=g+1;p<i;p++){const I=x-s[p-1]+s[g];if(I<0)break;const b=s[p]-s[p-1],m=s[p]-s[g]<x?1:I/b;if(m<h)break;const M=m*m,D=m*I-.5*M*b,P=m*b/e,V=t[p-1],T=t[p].x-V.x,B=t[p].y-V.y;w+=P/D*(V.x*m*I+.5*M*(I*T-b*V.x)-M*m*b*T/3),y+=P/D*(V.y*m*I+.5*M*(I*B-b*V.y)-M*m*b*B/3),_+=P}f.push(new L(w/_,y/_))}return f.push(new L(l,c)),t[0].x=r,t[0].y=o,t[i-1].x=l,t[i-1].y=c,f}static _pushCentroid(t,e){const i=ne,s=ne,a=e.length-1;let n=0,r=0,o=0,l=e[0].x,c=e[0].y;l>i&&(l=i),l<0&&(l=0),c>s&&(c=s),c<0&&(c=0);for(let d=1;d<a;d++){let f=e[d].x,h=e[d].y,x=e[d+1].x,g=e[d+1].y;f>i&&(f=i),f<0&&(f=0),h>s&&(h=s),h<0&&(h=0),x>i&&(x=i),x<0&&(x=0),g>s&&(g=s),g<0&&(g=0);const w=(f-l)*(g-c)-(x-l)*(h-c);n+=w*(l+f+x),r+=w*(c+h+g),o+=w}n/=3*o,r/=3*o,isNaN(n)||isNaN(r)||t.push(new de(n,r))}};N._bidiEngine=new Xe;let _e=N;class yt{constructor(t,e,i,s,a,n){var d;if(this._pbfTiles={},this._tileClippers={},this._client=i,this._tile=e,this._sourceDataMaxLOD=s,n){this._styleLayerUIDs=new Set;for(const f of n)this._styleLayerUIDs.add(f)}this._styleRepository=a,this._layers=((d=this._styleRepository)==null?void 0:d.layers)??[];const[r,o,l]=e.tileKey.split("/").map(parseFloat);this._level=r;const c=Oe(this._level);for(const f of Object.keys(t)){const h=t[f];if(this._pbfTiles[f]=new Ge(new Uint8Array(h.protobuff),new DataView(h.protobuff)),h.refKey){const[x]=h.refKey.split("/").map(parseFloat),g=r-x;if(g>0){const w=(1<<g)-1,y=o&w,_=l&w;this._tileClippers[f]=new Ke(g,y,_,8,c)}}this._tileClippers[f]||(this._tileClippers[f]=new qe)}}_canParseStyleLayer(t){return!this._styleLayerUIDs||this._styleLayerUIDs.has(t)}async parse(t){const e=je(),i=this._initialize(t),{returnedBuckets:s}=i;this._processLayers(i),this._linkReferences(i),this._filterFeatures(i);const a=[],n=new Set,r=(c,d)=>{n.has(c)||(a.push({name:c,repeat:d}),n.add(c))},o={};for(const c of s)c.getResources(c.tileClipper,r,o);if(this._tile.status===4)return[];const l=this._fetchResources(a,o,t);return Promise.all([...l,e]).then(()=>this._processFeatures(i.returnedBuckets))}_initialize(t){return{signal:t==null?void 0:t.signal,sourceNameToTileData:this._parseTileData(this._pbfTiles),layers:this._layers,zoom:this._level,sourceNameToTileClipper:this._tileClippers,sourceNameToUniqueSourceLayerBuckets:{},sourceNameToUniqueSourceLayers:{},returnedBuckets:[],layerIdToBucket:{},referencerUIDToReferencedId:new Map}}_processLayers(t){const{sourceNameToTileData:e,zoom:i,layers:s,sourceNameToTileClipper:a,sourceNameToUniqueSourceLayerBuckets:n,sourceNameToUniqueSourceLayers:r,returnedBuckets:o,layerIdToBucket:l,referencerUIDToReferencedId:c}=t,d=this._sourceDataMaxLOD;for(let f=s.length-1;f>=0;f--){const h=s[f];if(i<d){if(h.minzoom&&i<Math.floor(h.minzoom)||h.maxzoom&&i>=h.maxzoom)continue}else if(h.maxzoom&&i>=h.maxzoom)continue;if(h.type===0||!this._canParseStyleLayer(h.uid)||!e[h.source]||!a[h.source])continue;const x=e[h.source],g=a[h.source],w=h.sourceLayer,y=x[w];if(y){let _=r[h.source];if(_||(_=r[h.source]=new Set),_.add(h.sourceLayer),h.refLayerId)c.set(h.uid,h.refLayerId);else{const p=this._createBucket(h);if(p){p.layerUIDs=[h.uid],p.layerExtent=y.extent,p.tileClipper=g;let I=n[h.source];I||(I=n[h.source]={});let b=I[w];b||(b=I[w]=[]),b.push(p),o.push(p),l[h.id]=p}}}}}_linkReferences(t){const{layerIdToBucket:e,referencerUIDToReferencedId:i}=t;i.forEach((s,a)=>{e[s]&&e[s].layerUIDs.push(a)})}_filterFeatures(t){const{signal:e,sourceNameToTileData:i,sourceNameToUniqueSourceLayerBuckets:s,sourceNameToUniqueSourceLayers:a}=t,n=10*this._level,r=10*(this._level+1),o=[],l=[];for(const c of Object.keys(a))a[c].forEach(d=>{o.push(d),l.push(c)});for(let c=0;c<o.length;c++){const d=l[c],f=o[c];if(!i[d]||!s[d])continue;const h=i[d][f],x=s[d][f];if(!x||x.length===0)continue;if(Ee(e))return;let g=0;const w=h.getData();for(;w.nextTag(2);){const y=w.getMessage(),_=new Ye(y,h,g++);y.release();const p=_.values;if(p){const I=p._minzoom;if(I&&I>=r)continue;const b=p._maxzoom;if(b&&b<=n)continue}for(const I of x)I.pushFeature(_)}}}_fetchResources(t,e,i){const s=[],a=this._tile.getWorkerTileHandler();let n,r;t.length>0&&(n=a.fetchSprites(t,this._client,i),s.push(n));for(const o in e){const l=e[o];l.size>0&&(r=a.fetchGlyphs(this._tile.tileKey,o,l,this._client,i),s.push(r))}return s}_processFeatures(t){const e=t.filter(i=>i.hasFeatures()||this._canParseStyleLayer(i.layer.uid));for(const i of e)i.processFeatures(i.tileClipper);return e}_parseTileData(t){const e={};for(const i of Object.keys(t)){const s=t[i],a={};for(;s.next();)switch(s.tag()){case 3:{const n=s.getMessage(),r=new $e(n);n.release(),a[r.name]=r;break}default:s.skip()}e[i]=a}return e}_createBucket(t){switch(t.type){case 0:return null;case 1:return this._createFillBucket(t);case 2:return this._createLineBucket(t);case 4:return this._createCircleBucket(t);case 3:return this._createSymbolBucket(t)}}_createFillBucket(t){return new ht(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new nt(t.fillMaterial.getStride()),new Q,new at(t.outlineMaterial.getStride()),new Q)}_createLineBucket(t){return new ut(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new rt(t.lineMaterial.getStride()),new Q)}_createCircleBucket(t){return new lt(t,this._level,this._tile.getWorkerTileHandler().getSpriteItems(),new ot(t.circleMaterial.getStride()),new Q)}_createSymbolBucket(t){const e=this._tile;return new _e(e.tileKey,t,this._level,new Te(t.iconMaterial.getStride()),new Q,new Te(t.textMaterial.getStride()),new Q,e.placementEngine,e.getWorkerTileHandler())}}let pt=class{constructor(u,t,e,i){this.status=0,this.placementEngine=new it,this.tileKey=u,this.refKeys=t,this._workerTileHandler=e,this._styleRepository=i}release(){this.tileKey="",this.refKeys=null,this.status=0,this._workerTileHandler=null}async parse(u,t){const e=t==null?void 0:t.signal;if(e!=null){const l=()=>{e.removeEventListener("abort",l),this.status=4};e.addEventListener("abort",l)}let i;const s={bucketsWithData:[],emptyBuckets:null};try{i=await this._parse(u,t)}catch(l){if(Ce(l))throw l;return{result:s,transferList:[]}}this.status=2;const a=s.bucketsWithData,n=[];for(const l of i)if(l.hasFeatures()){const c=l.serialize();a.push(c)}else n.push(l.layer.uid);const r=[...a];let o=null;return n.length>0&&(o=Uint32Array.from(n),r.push(o.buffer)),s.emptyBuckets=o,{result:s,transferList:r}}setObsolete(){this.status=4}getLayers(){return this._workerTileHandler.getLayers()}getWorkerTileHandler(){return this._workerTileHandler}async _parse(u,t){const e=u.sourceName2DataAndRefKey;return Object.keys(e).length===0?[]:(this.status=3,new yt(e,this,t.client,u.sourceDataMaxLOD,this._styleRepository,u.styleLayerUIDs).parse(t))}};const gt=25;class Rt{constructor(){this._spriteInfo={},this._glyphInfo={},this._sourceDataMaxLOD=gt}reset(){return this._spriteInfo={},this._glyphInfo={},Promise.resolve()}getLayers(){var t;return((t=this._styleRepository)==null?void 0:t.layers)??[]}async createTileAndParse(t,e){const{key:i}=t,s={};for(const n of Object.keys(t.sourceName2DataAndRefKey)){const r=t.sourceName2DataAndRefKey[n];s[n]=r.refKey}const a=new pt(i,s,this,this._styleRepository);try{return await a.parse({...t,sourceDataMaxLOD:this._sourceDataMaxLOD},e)}catch(n){if(a.setObsolete(),a.release(),!Ce(n))throw n;return null}}updateStyle(t){if(!t||t.length===0||!this._styleRepository)return;const e=this._styleRepository;for(const i of t){const s=i.type,a=i.data;switch(s){case 0:e.setPaintProperties(a.layer,a.paint);break;case 1:e.setLayoutProperties(a.layer,a.layout);break;case 3:e.deleteStyleLayer(a.layer);break;case 2:e.setStyleLayer(a.layer,a.index);break;case 4:this._spriteInfo={}}}}setStyle(t){const{style:e,sourceDataMaxLOD:i}=t;this._styleRepository=new Je(e),this._sourceDataMaxLOD=i,this._spriteInfo={},this._glyphInfo={}}fetchSprites(t,e,i){const s=[],a=this._spriteInfo;for(const n of t)a[n.name]===void 0&&s.push(n);return s.length===0?Promise.resolve():e.invoke("getSprites",s,{signal:i==null?void 0:i.signal}).then(n=>{for(const r in n){const o=n[r];a[r]=o}})}getSpriteItems(){return this._spriteInfo}fetchGlyphs(t,e,i,s,a){const n=[];let r=this._glyphInfo[e];return r?i.forEach(o=>{r[o]||n.push(o)}):(r=this._glyphInfo[e]=[],i.forEach(o=>n.push(o))),n.length===0?Promise.resolve():s.invoke("getGlyphs",{tileID:t,font:e,codePoints:n},a).then(o=>{for(let l=0;l<o.length;l++)o[l]&&(r[l]=o[l])})}getGlyphItems(t){return this._glyphInfo[t]}}export{Rt as default};
