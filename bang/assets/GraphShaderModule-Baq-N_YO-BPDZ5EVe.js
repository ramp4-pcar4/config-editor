import{j as mt}from"./enums-CQnCd4Rx-DxG4glug.js";import{v as w,a6 as ue,jc as we,W as ve,h as xe}from"./index-12gn5LMs.js";import{Y as $e,_ as Ie}from"./Texture-D5XWO2GQ-DgDJ6koW.js";import"./enums-wEDHPbCF-Cf76M5_x.js";import"./FramebufferObject-D3QloItC-BaqGOulF.js";import{X as _e}from"./ProgramTemplate-C4wmhGXE-DEtuuRZI.js";import{v as Ne}from"./ShaderBuilder-CU5v4tk1-D0yHKPCw.js";let cn=class{constructor(){this.drawPhase=mt.MAP|mt.HITTEST|mt.HIGHLIGHT|mt.DEBUG}startup(){}shutdown(n){}};function Te(n){return n.split(" ").map((t,e)=>e>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function Me(n,t){const e=[];for(e.push(t);e.length;){const r=e.pop();if(typeof r=="object"&&!n.has(r.uid)){n.add(r.uid);for(const i of r.children)e.push(i)}}}var E;let W=(E=class{constructor(){this.uid=E.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=Te(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof E&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}},E.NodeCount=0,E);function o(n){return typeof n=="object"?n.clone():n}let m=class extends W{constructor(){super(...arguments),this.shaderType="primitive-node"}},Se=class he extends W{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new he(o(this.child));return this.cloneInto(t),t}};class Jt extends W{constructor(t,e,r){super(),this.property=t,this.target=e,this.returnType=r,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Jt(this.property,o(this.target),this.returnType);return this.cloneInto(t),t}}let ke=class de extends W{constructor(t,e,r,i){super(),this.x=t,this.y=e,this.target=r,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new de(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(t),t}};class Zt extends W{constructor(t,e,r){super(),this.condition=t,this.ifTrue=e,this.ifFalse=r,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=o(this.ifTrue),e=this.ifFalse?o(this.ifFalse):null,r=new Zt(this.condition,t,e);return this.cloneInto(r),r}}let Pe=class pe extends W{constructor(t,e,r,i){super(),this.captureList=t,this.returnType=e,this.generator=i,this.shaderType="block-node",r&&(this.subgraph=new Se(r))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const r in this.captureList)t[r]=o(this.captureList[r]);const e=new pe(t,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(e),e}},K=class le extends W{constructor(t,e,r,i,s,a=!1){super(),this.token=t,this._children=e,this.isInfix=r,this.isPropertyAccess=i,this.returnType=s,this.isTernary=a,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new le(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var dt,_t,Nt,Tt,Mt,St,kt,Pt,Ft,Ct,Et,Kt,Ut,At;function Fe(n){switch(n.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return $;case"float":case"vec2":case"vec3":case"vec4":return l;case"int":case"ivec2":case"ivec3":case"ivec4":return y;case"uint":case"uvec2":case"uvec3":case"uvec4":return bt;default:throw new Error("Unable to handle type")}}function Ce(n){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const e of t)if(e.includes(n))return e.map(r=>Ue[r]);throw new Error("Unable to find type family")}function fe(n){return new Proxy(n,{get(t,e){if(e==="constructor")return new Proxy(t.constructor,{construct:(r,i,s)=>fe(new r(...i))});if(e in t)return t[e];if(typeof e=="string"){const r=Ce(n.type);return I(n,e,r[e.length-1])}}})}function _(n){return new Proxy(n,{construct:(t,e,r)=>fe(new t(...e))})}function Ee(n){return new Proxy(n,{get(t,e){if(e in t)return t[e];if(typeof e=="string"){const r=parseInt(e,10);if(!isNaN(r))return I(n,`[${r}]`,n.elementType.constructor)}}})}function Ke(n){return new Proxy(n,{construct:(t,e,r)=>Ee(new t(...e))})}class Ot extends Error{}var U;let Vt=(U=class extends m{constructor(t,e){super(),this.elementType=t,this.size=e,this.children=[],this.type="array"}clone(){const t=new dt(this.elementType,this.size);return super.cloneInto(t),t}get(t,e){const r=new y(t),i=e!=null?new y(e):null;return i!=null?$t(this,r,i,Fe(this.elementType.constructor)):I(this,r,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,e,r){return Ve(this,t,e,r)}glslFindIndex(t,e,r){return je(this,t,e,r)}static ofType(t,e){const r={construct:(i,s)=>new dt(new t,e)};return new Proxy(dt,r)}},dt=U,U.type="array",U);Vt=dt=w([Ke],Vt);const pt=class pt extends m{constructor(t,e,r,i=!1){super(),this.elementType=t,this.xSize=e,this.ySize=r,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new pt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,e){return this.isRowMajor?this._getRowMajor(t,e):this._getColumnMajor(t,e)}_getColumnMajor(t,e){const r=new y(t);return I(this,new y(e).add(r.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,e){const r=new y(t),i=new y(e);return I(this,r.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,e,r,i=!1){return new Proxy(Vt,{construct:(s,a)=>new pt(new t,e,r,i)})}};pt.type="array-2d";let re=pt;const wt=class wt extends m{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new wt;return t.children=this.children.map(o),super.cloneInto(t),t}};wt.type="sampler2D";let ie=wt;var N;let l=(N=class extends m{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new N(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return S(this,typeof t=="number"?g(t,N):t)}divide(t){return ft(this,typeof t=="number"?g(t,N):t)}add(t){return it(this,typeof t=="number"?g(t,N):t)}subtract(t){return yt(this,typeof t=="number"?g(t,N):t)}},N.type="float",N);var A;let lt=(A=class extends m{constructor(t,e){super(),this.type="vec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new _t(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return I(this,"[0]",l)}get 1(){return I(this,"[1]",l)}get 2(){throw new Ot}get 3(){throw new Ot}multiply(t){return S(this,typeof t=="number"?g(t,l):t)}divide(t){return ft(this,typeof t=="number"?g(t,l):t)}add(t){return it(this,typeof t=="number"?g(t,l):t)}subtract(t){return yt(this,typeof t=="number"?g(t,l):t)}},_t=A,A.type="vec2",A);lt=_t=w([_],lt);var O;let gt=(O=class extends m{constructor(t,e,r){super(),this.type="vec3",this.children=[t,e,r].filter(i=>i!=null)}get 0(){return I(this,"[0]",l)}get 1(){return I(this,"[1]",l)}get 2(){return I(this,"[2]",l)}get 3(){throw new Ot}clone(){const t=new Nt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}multiply(t){return S(this,typeof t=="number"?g(t,l):t)}divide(t){return ft(this,typeof t=="number"?g(t,l):t)}add(t){return it(this,typeof t=="number"?g(t,l):t)}subtract(t){return yt(this,typeof t=="number"?g(t,l):t)}},Nt=O,O.type="vec3",O);gt=Nt=w([_],gt);var V;let X=(V=class extends m{constructor(t,e,r,i){super(),this.type="vec4",this.children=[t,e,r,i].filter(s=>s!=null)}clone(){const t=new Tt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return I(this,"[0]",l)}get 1(){return I(this,"[1]",l)}get 2(){return I(this,"[2]",l)}get 3(){return I(this,"[3]",l)}multiply(t){return S(this,typeof t=="number"?g(t,l):t)}divide(t){return ft(this,typeof t=="number"?g(t,l):t)}add(t){return it(this,typeof t=="number"?g(t,l):t)}subtract(t){return yt(this,typeof t=="number"?g(t,l):t)}},Tt=V,V.type="vec4",V);X=Tt=w([_],X);var j;let bt=(j=class extends m{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new Mt(o(this.children[0]));return super.cloneInto(t),t}},Mt=j,j.type="uint",j);bt=Mt=w([_],bt);var B;let jt=(B=class extends m{constructor(t,e){super(),this.type="uvec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new St(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}},St=B,B.type="uvec2",B);jt=St=w([_],jt);var D;let Bt=(D=class extends m{constructor(t,e,r){super(),this.type="uvec3",this.children=[t,e,r].filter(i=>i!=null)}clone(){const t=new kt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}},kt=D,D.type="uvec3",D);Bt=kt=w([_],Bt);var z;let Dt=(z=class extends m{constructor(t,e,r,i){super(),this.type="uvec4",this.children=[t,e,r,i].filter(s=>s!=null)}clone(){const t=new Pt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}},Pt=z,z.type="uvec4",z);Dt=Pt=w([_],Dt);const vt=class vt extends m{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return qe(this,t)}or(t){return De(this,t)}xor(t){return Le(this,t)}clone(){const t=new vt(o(this.children[0]));return super.cloneInto(t),t}};vt.type="bool";let $=vt;var L;let zt=(L=class extends m{constructor(t,e){super(),this.type="bvec2",this.children=[t,e].filter(r=>r!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Ft(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}},Ft=L,L.type="bvec2",L);zt=Ft=w([_],zt);var G;let Lt=(G=class extends m{constructor(t,e,r){super(),this.type="bvec3",this.children=[t,e,r].filter(i=>i!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Ct(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}},Ct=G,G.type="bvec3",G);function g(n,t){return typeof n=="number"?new t(n):n}Lt=Ct=w([_],Lt);var q;let Gt=(q=class extends m{constructor(t,e,r,i){super(),this.type="bvec4",this.children=[t,e,r,i].filter(s=>s!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Et(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}},Et=q,q.type="bvec4",q);Gt=Et=w([_],Gt);const C=class C extends m{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return S(this,g(t,C))}add(t){return it(this,g(t,C))}subtract(t){return yt(this,g(t,C))}divide(t){return ft(this,g(t,C))}clone(){const t=new C(o(this.children[0]));return super.cloneInto(t),t}};C.type="int";let y=C;var H;let qt=(H=class extends m{constructor(t,e){super(),this.type="ivec2",this.children=[t,e].filter(r=>r!=null)}clone(){const t=new Kt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}},Kt=H,H.type="ivec2",H);qt=Kt=w([_],qt);var R;let Ht=(R=class extends m{constructor(t,e,r){super(),this.type="ivec3",this.children=[t,e,r].filter(i=>i!=null)}clone(){const t=new Ut(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}},Ut=R,R.type="ivec3",R);Ht=Ut=w([_],Ht);var Y;let Rt=(Y=class extends m{constructor(t,e,r,i){super(),this.type="ivec4",this.children=[t,e,r,i].filter(s=>s!=null)}clone(){const t=new At(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}},At=Y,Y.type="ivec4",Y);Rt=At=w([_],Rt);const xt=class xt extends m{constructor(t,e,r,i){super(),this.type="mat2",this.children=[t,e,r,i]}clone(){const t=new xt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get(t,e){return $t(this,new y(t),new y(e),l)}multiply(t){return S(this,t)}};xt.type="mat2";let se=xt;const Q=class Q extends m{static identity(){return new Q(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const e=Ye(t),r=Re(t);return new Q(r,e,0,Oe(e),r,0,0,0,1)}constructor(t,e,r,i,s,a,u,c,h){super(),this.type="mat3",this.children=[t,e,r,i,s,a,u,c,h]}add(t){return it(this,t)}multiply(t){return S(this,t)}get(t,e){return $t(this,new y(t),new y(e),l)}clone(){const t=new Q(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(t),t}};Q.type="mat3";let Yt=Q;const tt=class tt extends m{static identity(){return new tt(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,e,r,i,s,a,u,c,h,d,p,v,k,T,P,F){super(),this.type="mat4",this.children=[t,e,r,i,s,a,u,c,h,d,p,v,k,T,P,F]}static fromColumns(t,e,r,i){return new tt(t.x,t.y,t.z,t.w,e.x,e.y,e.z,e.w,r.x,r.y,r.z,r.w,i.x,i.y,i.z,i.w)}multiply(t){return S(this,t)}get(t,e){return $t(this,new y(t),new y(e),l)}clone(){const t=new tt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(t),t}};tt.type="mat4";let oe=tt;const Ue={float:l,vec2:lt,vec3:gt,vec4:X,int:y,ivec2:qt,ivec3:Ht,ivec4:Rt,uint:bt,uvec2:jt,uvec3:Bt,uvec4:Dt,bool:$,bvec2:zt,bvec3:Lt,bvec4:Gt},un=(...n)=>new y(...n),Ae=(...n)=>new l(...n),hn=(...n)=>new lt(...n),dn=(...n)=>new gt(...n),pn=(...n)=>new X(...n),ln=(...n)=>new Yt(...n);function I(n,t,e){const r=new e(new Jt(t,n,e));return r.isImplicit=!0,r}function $t(n,t,e,r){const i=new r(new ke(t,e,n,r));return i.isImplicit=!0,i}function b(n,t,e,r=null){if(r){const s=new r,a=new r(new K(n,[t,e],!0,!1,s));return a.isImplicit=!0,a}if(t.type==="float"||t.type==="int"){const s=new e.constructor(new K(n,[t,e],!0,!1,e.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&e.type!=="float"){const s=new e.constructor(new K(n,[t,e],!0,!1,e.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new K(n,[t,e],!0,!1,t.constructor));return i.isImplicit=!0,i}function f(n,t,e=t.constructor){const r=new e(new K(n,[t],!1,!1,e));return r.isImplicit=!0,r}function M(n,t,e,r=t.constructor){const i=new r(new K(n,[t,e],!1,!1,r));return i.isImplicit=!0,i}function It(n,t,e,r,i=t.constructor){const s=new i(new K(n,[t,e,r],!1,!1,i));return s.isImplicit=!0,s}function Oe(n){return S(n,Ae(-1))}function Qt(n,t,e,r){return new t(new Pe(n,t,e,r))}function Ve(n,t,e=0,r=n.size){const i=new y(e).setMutable().setDebugName("FindIndexIterator"),s=t(n.get(i)).setDebugName("FindIndexPredicate");return Qt({iter:i},y,s,({out:a,iter:u,subgraph:c})=>`
${a} = -1;

for (; ${u} < ${r}; ${u}++) {

${c.body}

  if (${c.varName}) {
    ${a} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function je(n,t,e=0,r=n.size){return Qt({array:n},y,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${e}; i < ${r}; i++) {
  bool condition;
  ${t({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function Be(n,t,e){const r=typeof t=="function"?t():t,i=typeof e=="function"?e():e,s=new r.constructor(new Zt(n,r,i));return s.isImplicit=!0,s}function fn(...n){const t=n.map(([u,c])=>typeof c=="function"?[u,c()]:[u,c]),e=t[0][1].constructor,r=t.findIndex(u=>u[0]===!0);if(r===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,r),s=t[r][1],a=new e(i.reduceRight((u,c)=>Be(c[0],c[1],u),s));return a.isImplicit=!0,a}function S(n,t){return b("*",n,t)}function ft(n,t){return b("/",n,t)}function it(n,t){return b("+",n,t)}function yt(n,t){return b("-",n,t)}function yn(n,t){return b("%",n,t)}function mn(n,t){return b("<<",n,t)}function gn(n,t){return b(">>",n,t)}function bn(n,t){return b("&",n,t)}function wn(n,t){return b("|",n,t)}function vn(n,t){return b("^",n,t)}function xn(n){return f("~",n)}function $n(n,t){return b("==",n,t,$)}function In(n,t){return b("!=",n,t,$)}function _n(n,t){return b("<",n,t,$)}function Nn(n,t){return b("<=",n,t,$)}function Tn(n,t){return b(">",n,t,$)}function Mn(n,t){return b(">=",n,t,$)}function De(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>ze(t,e),n[0])}function ze(n,t){return b("||",n,t,$)}function Le(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>Ge(t,e),n[0])}function Ge(n,t){return b("^^",n,t,$)}function qe(...n){return n.length<=1?n[0]:n.slice(1).reduce((t,e)=>He(t,e),n[0])}function He(n,t){return b("&&",n,t,$)}function Sn(n){return f("abs",n)}function kn(n){return f("acos",n)}function Pn(n){return f("acosh",n)}function te(n){return f("all",n,$)}function ee(n){return f("any",n,$)}function Fn(n){return f("asin",n)}function Cn(n){return f("asinh",n)}function En(n,t){return t==null?f("atan",n):M("atan",n,t,n.constructor)}function Kn(n){return f("atanh",n)}function Un(n){return f("ceil",n)}function An(n,t,e){return It("clamp",n,t,e,n.constructor)}function Re(n){return f("cos",n)}function On(n){return f("cosh",n)}function Vn(n,t){return M("distance",n,t,l)}function jn(n,t){return M("dot",n,t,l)}function Bn(n){return f("exp",n)}function Dn(n){return f("floor",n)}function zn(n){return f("fract",n)}function Ln(n){return f("length",n,l)}function Gn(n){return f("log",n)}function qn(n){return f("log2",n)}function Hn(n,t){return M("max",n,t)}function Rn(n,t){return M("min",n,t)}function Yn(n,t,e){return It("mix",n,t,e)}function Xn(n,t){return M("mod",n,t)}function Wn(n){return f("normalize",n)}function Jn(n){return n.type==="bool"?f("!",n):f("not",n)}function Zn(n,t){return M("pow",n,t)}function Qn(n){return f("round",n)}function tr(n){return f("sign",n)}function Ye(n){return f("sin",n)}function er(n){return f("sinh",n)}function nr(n,t,e){return It("smoothstep",n,t,e)}function rr(n){return f("sqrt",n)}function ir(n,t){return M("step",n,t,t.constructor)}function sr(n){return f("tan",n)}function or(n){return f("tanh",n)}function ar(n,t,e){return It("texelFetch",n,t,e,X)}function cr(n,t){return M("texture",n,t,X)}function ur(n,t){const{initialValue:e,xRange:r,yRange:i,callback:s}=t,[a,u]=r,[c,h]=i,d=new y(0).setMutable().setDebugName("iterX"),p=new y(0).setMutable().setDebugName("iterY"),v=e.setMutable().setDebugName("accumulator"),k=s(v,n.get(d,p),d,p).setDebugName("callback");return Qt({iterX:d,iterY:p,accumulator:v},e.constructor,k,({out:T,iterX:P,iterY:F,accumulator:ot,subgraph:at})=>`
for (${F} = ${c}; ${F} < ${h}; ${F}++) {
  for (${P} = ${a}; ${P} < ${u}; ${P}++) {

  ${at.body}

  ${ot} = ${at.varName};
  }
}
${T} = ${ot};
`).setDebugName("reduce2DBody")}const ct=5;function x(n,t,e){const r=t.split(`
`);for(const i of r)if(i.trim().length){{let s="";e!=null&&(s+=`/*id:${e??"000"}*/   `),n.body+=s.padEnd(14)}n.body+=" ".repeat(n.indent)+i+`
`}}class ae{write(t){for(const e of t.rootOutputNodes())t.shouldPruneOutputNode(e)||(e.variableName=this._write(t,e.node));return t}_createVarName(t,e){let r="";return typeof e!="boolean"&&typeof e!="number"&&e.debugInfo.name&&(r=`${e.debugInfo.name}_`),`${r}v${t.varCount++}`}_write(t,e,r=!1){if(typeof e=="number"||typeof e=="boolean")return e.toString();let i=t.getEmit(e);if(i)return i;switch(e.shaderType){case"scope-node":i=this._writeScopeNode(t,e);break;case"primitive-node":i=this._writePrimitiveNode(t,e,r);break;case"function-node":i=this._writeFunctionNode(t,e);break;case"property-access-node":i=this._writePropertyAccessNode(t,e);break;case"property-access-2d-node":i=this._writePropertyAccess2DNode(t,e);break;case"text-node":i=e.text;break;case"block-node":i=this._writeBlockNode(t,e);break;case"condition-node":i=this._writeConditionNode(t,e)}return t.setEmit(e,i),i}_writeScopeNode(t,e){const r=new e.child.constructor;r.setDebugName(e.debugInfo.name);const i=this._write(t,r,!0);return x(t,`{ /*ScopeStart: ${e.uid} ${e.debugInfo.name}*/`),t.indent+=2,x(t,`${i} = ${this._write(t,e.child)};`),t.indent-=2,x(t,`} /*ScopeEnd: ${e.uid} ${e.debugInfo.name}*/`),i}_writeConditionNode(t,e){const r=new e.ifTrue.constructor,i=this._write(t,r,!0);x(t,`if (${this._write(t,e.condition)}) {`),t.indent+=2;const s=t.createSubgraphContext(),a=this._write(s,e.ifTrue);if(t.body+=s.body,a&&x(t,`${i} = ${a};`),t.indent-=2,x(t,"}"),e.ifFalse){x(t,"else {"),t.indent+=2;const u=t.createSubgraphContext(),c=this._write(u,e.ifFalse);t.body+=u.body,c&&x(t,`${i} = ${c};`),t.indent-=2,x(t,"}")}return i}_writeBlockNode(t,e){const{captureList:r,generator:i,returnType:s}=e,a={};for(const d in r){if(!r[d])continue;const p=this._write(t,r[d]);a[d]=p}const u=new s,c=this._write(t,u,!0);if(a.out=c,e.subgraph){const d=t.createSubgraphContext(),p=this._write(d,e.subgraph.child),v=d.body;a.subgraph={varName:p,body:v}}const h=i(a);return x(t,`{
`),t.indent+=2,x(t,h),t.indent-=2,x(t,`}
`),c}_writePropertyAccessNode(t,e){const r=this._write(t,e.target);return typeof e.property=="string"&&e.property.includes("[")?`${r}${e.property}`:typeof e.property!="string"?`${r}[${this._write(t,e.property)}]`:`${r}.${e.property}`}_writePropertyAccess2DNode(t,e){return`${this._write(t,e.target)}[${this._write(t,e.x)}][${this._write(t,e.y)}]`}_writeFunctionNode(t,e){const r=e.returnType.type;if(e.isInfix){const[a,u]=e.children.map(h=>this._write(t,h)),c=this._createVarName(t,e);return x(t,`${r.padEnd(ct)} ${c} = ${a} ${e.token} ${u};`,e.uid),c}const i=e.children.map(a=>this._write(t,a)).join(", "),s=this._createVarName(t,e);return x(t,`${r.padEnd(ct)} ${s} = ${e.token}(${i});`,e.uid),s}_writePrimitiveNode(t,e,r=!1){var h;const i=t.getInput(e);if(i)return i.isUsed=!0,i.variableName;const s=e.children.length===1&&((h=e.children[0])==null?void 0:h.type)===e.type;if(!e.isMutable&&(e.isImplicit||s))return this._write(t,e.children[0]);const a=this._createVarName(t,e);if(r)return x(t,`${e.type.padEnd(ct)} ${a};`,e.uid),a;const u=!e.debugInfo.name&&!e.isMutable;if(u&&e.type==="float"&&typeof e.children[0]=="number")return Number.isInteger(e.children[0])?e.children[0].toFixed(1):e.children[0].toString();if(u&&e.type==="int"&&typeof e.children[0]=="number"&&Number.isInteger(e.children[0]))return e.children[0].toString();const c=e.children.map(d=>this._write(t,d)).join(", ");return e.type==="array"?(x(t,`${e.type.padEnd(ct)} ${a} = [${c}];`,e.uid),a):u?`${e.type}(${c})`:(x(t,`${e.type.padEnd(ct)} ${a} = ${e.type}(${c});`,e.uid),a)}}let J=class ye{constructor(t,e,r){this.variableName=t,this.variableInputType=e,this.node=r,this.type="shader-input",this.isUsed=!1}clone(){return new ye(this.variableName,this.variableInputType,o(this.node))}},Z=class me{constructor(t,e,r){this.outVariableName=t,this.outVariableType=e,this.node=r,this.type="shader-output"}clone(){const t=new me(this.outVariableName,this.outVariableType,o(this.node));return t.variableName=this.variableName,t}};class et{static createVertex(t,e,r,i,s,a){const u=[];for(const h in t){const d=t[h],p=r.get(h);p?u.push(new J(p,"builtin",d)):u.push(new J("a_"+h,"in",d))}for(const h of i){const d=h.uniformHydrated;u.push(new J(h.uniformName,"uniform",d))}const c=[];for(const h in e){const d=e[h];h==="glPosition"?c.push(new Z("gl_Position","builtin",d)):h==="glPointSize"?c.push(new Z("gl_PointSize","builtin",d)):c.push(new Z("v_"+h,"out",d))}return new et(u,c,s,a)}static createFragment(t,e,r,i,s,a){const u=[],c=Array.from(s.rootOutputNodes());for(const d in t){const p=t[d],v=r.get(d);if(v){u.push(new J(v,"builtin",p));continue}const k=c.find(T=>T.node===p);k&&u.push(new J(k.outVariableName,"in",p))}for(const d of i){const p=d.uniformHydrated;u.push(new J(d.uniformName,"uniform",p))}const h=[];for(const d in e){const p=e[d],v=r.get(d);d==="discard"?h.push(new Z(null,"discard",p)):v?h.push(new Z(v,"builtin",p)):h.push(new Z(d,"out",p))}return new et(u,h,a)}constructor(t,e,r,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=e,this._transformFeedbackBindings=r,this._transformFeedbackNames=new Set(r.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,e){this._nodeEmitMap.set(t.uid,e)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const e of this._outputShaderTypes.values())t.push(e.node);for(;t.length;){const e=t.pop();typeof e!="number"&&typeof e!="boolean"&&t.push(...e.children.filter(Boolean)),yield e}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new et([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const e of this.rootOutputNodes()){const r=e.outVariableType==="builtin";this.shouldPruneOutputNode(e)||(r?t.vertex.code.add(`// ${e.outVariableType.padEnd(7)} ${e.node.type.padEnd(9)} ${e.outVariableName};`):t.vertex.code.add(`${e.outVariableType.padEnd(10)} ${e.node.type.padEnd(9)} ${e.outVariableName};`))}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const e of this.rootOutputNodes())this.shouldPruneOutputNode(e)||t.vertex.code.add(`  ${e.outVariableName} = ${e.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let e=0;for(const r of this.rootOutputNodes())r.outVariableType==="builtin"?t.fragment.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`):t.outputs.add(r.outVariableName,r.node.type,e++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())r.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${r.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.fragment.code.add("}")}_insertInputs(t,e){t[e].code.add("// INPUTS: "),t[e].code.add("// --------------------------------------------------------- ");for(const r of this.inputs())r.isUsed&&r.variableInputType!=="builtin"&&(r.node.type==="array"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}];`):r.node.type==="array-2d"?t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.elementType.type.padEnd(9)} ${r.variableName}[${r.node.size}]; // Emulated 2D Array. Not supported by ES3.0`):t[e].code.add(`${r.variableInputType.padEnd(10)} ${r.node.type.padEnd(9)} ${r.variableName};`))}}function Xe(n,t,e){const r=new $e(t.width,t.height);return r.dataType=t.dataType,t.depth&&(r.depth=t.depth),t.flipped&&(r.flipped=t.flipped),t.hasMipmap&&(r.hasMipmap=t.hasMipmap),r.internalFormat=t.internalFormat,t.isImmutable&&(r.isImmutable=t.isImmutable),t.isOpaque&&(r.isOpaque=t.isOpaque),t.maxAnisotropy&&(r.maxAnisotropy=t.maxAnisotropy),r.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(r.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(r.samplingMode=t.samplingMode),t.target&&(r.target=t.target),r.uniform=t.uniform,t.unpackAlignment&&(r.unpackAlignment=t.unpackAlignment),t.wrapMode&&(r.wrapMode=t.wrapMode),new Ie(n,r,e)}const We=()=>ue.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function ut(n,t,e){const r=t.length;if(r!==e){const i=new xe("Invalid Uniform",`Invalid length, expected ${e} but got ${r}`,{uniformName:n,values:t});We().errorOnce(i)}}class ce{constructor(t,e,r,i,s,a){this._program=null,this._vao=null,this._temporaryTextures=[],this.vertexShader=t,this.fragmentShader=e,this._locations=r,this._locationInfo=i,this._uniformBindings=s,this._transformFeedbackBindings=a}destroy(){this._program&&this._program.dispose(),this.cleanupTemporaryTextures()}get locations(){return this._locations}get locationInfo(){return this._locationInfo}setUniforms(t){this._uniforms=t}cleanupTemporaryTextures(){for(const t of this._temporaryTextures)t.dispose();this._temporaryTextures=[]}bind(t){const e=this._uniforms;if(!this._program){const i=new Map;for(const[a,u]of this._locations)i.set(a,u);const s=[];for(const a of this._transformFeedbackBindings??[]){const{index:u,propertyKey:c}=a;s[u]=`v_${c}`}this._program=new _e(t,this.vertexShader,this.fragmentShader,i,new Map,s)}const r=this._program;t.useProgram(r);for(const i of this._uniformBindings){const{shaderModulePath:s,uniformName:a,uniformType:u,uniformArrayLength:c}=i,h=ve(s,e);if(h==null){if(u==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${s}`)}switch(u==="array"||u==="array-2d"?i.uniformArrayElementType:u){case"sampler2D":{const{unit:d,texture:p}=h;if(r.setUniform1i(a,d),"type"in p)t.bindTexture(p,d);else{const v=Xe(t,p.descriptor,p.data);t.bindTexture(v,d)}break}case"int":if(!c){r.setUniform1i(a,h);break}ut(i.uniformName,h,c),r.setUniform1iv(a,h);break;case"float":if(!c){r.setUniform1f(a,h);break}ut(i.uniformName,h,c),r.setUniform1fv(a,h);break;case"vec2":if(!c){r.setUniform2f(a,h[0],h[1]);break}ut(i.uniformName,h,c),r.setUniform2fv(a,h.flat());break;case"vec3":if(!c){r.setUniform3f(a,h[0],h[1],h[2]);break}ut(i.uniformName,h,c),r.setUniform3fv(a,h.flat());break;case"vec4":if(!c){r.setUniform4f(a,h[0],h[1],h[2],h[3]);break}ut(i.uniformName,h,c),r.setUniform4fv(a,h.flat());break;case"mat3":r.setUniformMatrix3fv(a,h);break;case"mat4":r.setUniformMatrix4fv(a,h);break;default:throw new Error(`Unable to set uniform for type ${u}`)}}}}function ht(n){return new n}function st(n,t,e){const r=n.constructor[t]??[];n.constructor.hasOwnProperty(t)||Object.defineProperty(n.constructor,t,{value:r.slice()}),n.constructor[t].push(e)}function hr(n,t){return(e,r)=>{st(e,"locations",{typeCtor:t,propertyKey:r,parameterIndex:null,index:n})}}const Je=n=>(t,e)=>{st(t,"builtins",{builtin:n,propertyKey:e})},dr=n=>(t,e,r)=>{st(t,"inputs",{inputCtor:n,propertyKey:e,parameterIndex:r})},pr=n=>(t,e)=>{st(t,"uniforms",{typeCtor:n,propertyKey:e})},lr=n=>(t,e)=>{st(t,"options",{typeCtor:n,propertyKey:e})},fr=(n,t)=>{st(n,"defines",{propertyKey:t})},Xt=(n,t)=>(e,r)=>{e.constructor.builtins.push({builtin:n,propertyKey:r,typeCtor:t})};var nt;let Ze=(nt=class{},nt.builtins=[],nt);w([Xt("gl_VertexID",y)],Ze.prototype,"glVertexID",void 0);class yr{}var rt;let Wt=(rt=class{},rt.builtins=[],rt);w([Xt("gl_FragCoord",X)],Wt.prototype,"glFragCoord",void 0),w([Xt("gl_PointCoord",lt)],Wt.prototype,"glPointCoord",void 0);class Qe{}w([Je("gl_FragDepth")],Qe.prototype,"glFragDepth",void 0);let mr=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},gr=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const n=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===0);if(!n)throw new Error("Unable to find vertex input parameter");return n}get computeInput(){return this._shaderModuleClass.inputs.findLast(n=>n.propertyKey==="vertex"&&n.parameterIndex===1)}get fragmentInput(){const n=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="fragment");if(!n)throw new Error("Unable to find fragment input parameter");return n}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var n;return[...this.vertexInput.inputCtor.locations,...((n=this.computeInput)==null?void 0:n.inputCtor.locations)??[]]}get locationsMap(){const n=new Map,t=new Set;for(const e of this.locations)t.has(e.index)?ue.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${e.propertyKey} to ${e.index}. Index already in use`,{locationsMap:n}):(n.set(e.propertyKey,e.index),t.add(e.index));return n}get locationInfo(){if(!this._locationInfo){const n=this.locationsMap,t=Array.from(n.entries()).map(([i,s])=>`${i}.${s}`).join("."),e=we(t),r=this.computeAttributes;this._locationInfo={hash:e,stringHash:t,locations:n,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const n=new Map;for(const t of this.locations)n.set("a_"+t.propertyKey,t.index);return n}get optionPropertyKeys(){if(!this._optionPropertyKeys){const n=new Set;for(const t of this._options)n.add(t.propertyKey);this._optionPropertyKeys=n}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(n,t,e,r){try{const{vertex:i,fragment:s,uniformBindings:a}=this._generateShaders(n,t,e,r);return new ce(i,s,this.renamedLocationsMap,this.locationInfo,a,this.transformFeedbackBindings)}catch{return new ce("","",this.renamedLocationsMap,this.locationInfo,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(n){const t=this._options.find(r=>r.propertyKey===n);if(t)return{type:"option",className:t.typeCtor};const e=this._uniforms.find(r=>r.propertyKey===n);if(!e)throw new Error(`Unable to find uniform class type for property: ${n}`);return{type:"required",className:e.typeCtor}}getShaderKey(n,t,e,r){const i=Object.keys(n).map(c=>`${c}.${n[c]}`).join("."),s=Object.keys(e).map(c=>`${c}.${e[c]}`).join("."),a=Object.keys(r).map(c=>`${c}.${r[c]}`).join("."),u=Object.keys(t).filter(c=>this.optionPropertyKeys.has(c)&&t[c]).join(".");return`${this.type}.${i}.${s}.${a}.${u}`}_generateShaders(n,t,e,r){const i=[];this._setDefines(e),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(r),a=this._injectPackPrecisionFactor(s,n),u=this._hydrateComputeInput(),c=u&&this._injectComputePackPrecisionFactor(u,n),h=this.vertex(a,c),d=this._hydrateFragmentInput(h),p=this.fragment(d),v=new Set;for(const ge in p){const be=p[ge];Me(v,be)}const k=this._getVertexInputBuiltins(),T=et.createVertex({...s,...u},h,k,i,this.transformFeedbackBindings,v);new ae().write(T);const P=this._getFragmentInputBuiltins(p);P.set("glPointCoord","gl_PointCoord");const F=et.createFragment(d,p,P,i,T,this.transformFeedbackBindings);new ae().write(F);const ot=this._createShaderBuilder(T,F),at=ot.generate("vertex"),ne=ot.generate("fragment");return this.logShader&&(console.log(at),console.log(ne)),{vertex:at,fragment:ne,uniformBindings:i}}_setDefines(n){for(const t in n)this[t]=n[t]}_setOptionalUniforms(n,t){for(const e of this._options)t[e.propertyKey]?this[e.propertyKey]=this._hydrateUniformGroup(n,e):this[e.propertyKey]=null}_setRequiredUniforms(n){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(n,t)}_hydrateUniformGroup(n,t){const e=new t.typeCtor;for(const r of e._uniforms??[]){const i=ht(r.typeCtor),s=`u_${t.propertyKey}_${r.propertyKey}`,a=i.type,u=[t.propertyKey,r.propertyKey].join(".");if("type"in r.typeCtor&&r.typeCtor.type==="array"){const c=i;n.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else if("type"in r.typeCtor&&r.typeCtor.type==="array-2d"){const c=i;n.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformArrayLength:c.size,uniformArrayElementType:c.elementType.type,uniformHydrated:i})}else n.push({shaderModulePath:u,uniformName:s,uniformType:a,uniformHydrated:i});e[r.propertyKey]=i}return e}_hydrateVertexInput(n){const t=this.vertexInput.inputCtor,e=t.locations.reduce((r,i)=>n[i.propertyKey]===!1?r:{...r,[i.propertyKey]:ht(i.typeCtor)},{});for(const{propertyKey:r,typeCtor:i}of t.builtins){const s=ht(i);e[r]=s}return e}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((n,t)=>({...n,[t.propertyKey]:ht(t.typeCtor)}),{})}_injectPackPrecisionFactor(n,t){const e={};for(const r in n){const i=n[r],s=t[r];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);e[r]=i.divide(new l(s))}else e[r]=i}return e}_injectComputePackPrecisionFactor(n,t){const e={},r=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])r.set(s,i);for(const i in n){const s=n[i],a=r.get(i);if(!a)continue;const u=t[a];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);e[i]=s.divide(new l(u))}else e[i]=s}return e}_hydrateFragmentInput(n){const t={};for(const e in n)t[e]=n[e];for(const{propertyKey:e,typeCtor:r}of Wt.builtins){const i=ht(r);t[e]=i}return t}_getVertexInputBuiltins(){const n=this.vertexInput.inputCtor,t=new Map;for(const{builtin:e,propertyKey:r}of n.builtins)t.set(r,e);return t}_getFragmentInputBuiltins(n){const t=n.constructor,e=new Map;for(const r of t.builtins??[])e.set(r.propertyKey,r.builtin);return e}_createShaderBuilder(n,t){const e=new Ne;return this._insertDebugInfo(e),n.insertVertexShader(e),t.insertFragmentShader(e),e}_insertDebugInfo(n){n.vertex.code.add("// DEFINES: "),n.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?n.vertex.code.add(`//   ${t.propertyKey}: true`):n.vertex.code.add(`//   ${t.propertyKey}: false`);n.vertex.code.add(""),n.vertex.code.add("// OPTIONS: "),n.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?n.vertex.code.add(`//   ${t.propertyKey}: true`):n.vertex.code.add(`//   ${t.propertyKey}: false`)}};export{un as $,yr as A,lr as B,Hn as C,gr as D,nr as E,hr as F,Mn as G,Dn as H,rr as I,Ze as J,pr as K,Be as L,y as M,gn as N,mr as O,X as P,oe as Q,gt as R,cr as S,bn as T,lt as U,fr as V,Zn as W,Ye as X,ie as Y,Vt as Z,$ as _,ir as a,Qe as a0,qe as a1,Jn as a2,ln as a3,hn as a4,Wt as a5,Wn as a6,ce as a7,Qn as a8,yn as a9,ar as aA,S as aa,En as ab,dn as ac,pn as ad,In as ae,Le as af,vn as ag,xn as ah,mn as ai,wn as aj,or as ak,sr as al,er as am,On as an,Kn as ao,Cn as ap,Fn as aq,Pn as ar,kn as as,tr as at,Bn as au,qn as av,Gn as aw,re as ax,ur as ay,qt as az,Tn as b,zn as c,fn as d,Un as e,De as f,Yt as g,$n as h,Oe as i,Ae as j,se as k,cn as l,Sn as m,Qt as n,dr as o,l as p,Re as q,An as r,Yn as s,Rn as t,jn as u,Ln as v,_n as w,Vn as x,Xn as y,Nn as z};
