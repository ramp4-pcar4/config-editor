import{c9 as S,v as h,I as d,ao as N,J as T,U as F,dE as P,T as w,t as j,Y as q,bI as J,z as O,bV as R}from"./index-Cd7FS_80.js";import{y as M}from"./Field-Cj6Pz3TI-BfIhW_SD.js";var z;const G=new S({esriGeometryPoint:"point",esriGeometryMultipoint:"multipoint",esriGeometryPolyline:"polyline",esriGeometryPolygon:"polygon",esriGeometryEnvelope:"extent",mesh:"mesh","":null});let c=z=class extends q{constructor(r){super(r),this.displayFieldName=null,this.exceededTransferLimit=!1,this.features=[],this.fields=null,this.geometryType=null,this.hasM=!1,this.hasZ=!1,this.queryGeometry=null,this.spatialReference=null}readFeatures(r,l){return this.readFeaturesWithClass(r,l,N)}writeGeometryType(r,l,s,e){if(r)return void G.write(r,l,s,e);const{features:i}=this;if(i){for(const t of i)if((t==null?void 0:t.geometry)!=null)return void G.write(t.geometry.type,l,s,e)}}readQueryGeometry(r,l){if(!r)return null;const s=!!r.spatialReference,e=J(r);return e&&!s&&l.spatialReference&&(e.spatialReference=w.fromJSON(l.spatialReference)),e}writeSpatialReference(r,l){if(r)return void(l.spatialReference=r.toJSON());const{features:s}=this;if(s){for(const e of s)if(e&&e.geometry!=null&&e.geometry.spatialReference)return void(l.spatialReference=e.geometry.spatialReference.toJSON())}}clone(){return new z(this.cloneProperties())}cloneProperties(){return O({displayFieldName:this.displayFieldName,exceededTransferLimit:this.exceededTransferLimit,features:this.features,fields:this.fields,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,queryGeometry:this.queryGeometry,spatialReference:this.spatialReference,transform:this.transform})}toJSON(r){const l=this.write();if(l.features&&Array.isArray(r)&&r.length>0)for(let s=0;s<l.features.length;s++){const e=l.features[s];if(e.geometry){const i=r==null?void 0:r[s];e.geometry=(i==null?void 0:i.toJSON())||e.geometry}}return l}quantize(r){const{scale:[l,s],translate:[e,i]}=r,t=n=>Math.round((n-e)/l),a=n=>Math.round((i-n)/s),m=this.features,u=this._getQuantizationFunction(this.geometryType,t,a);for(let n=0,y=m.length;n<y;n++)u!=null&&u(m[n].geometry)||(m.splice(n,1),n--,y--);return this.transform=r,this}unquantize(){var f,g;const{geometryType:r,features:l,transform:s}=this;if(!s)return this;const{translate:[e,i],scale:[t,a]}=s,m=p=>p*t+e,u=p=>i-p*a;let n=null,y=null;if(this.hasZ&&((f=s==null?void 0:s.scale)==null?void 0:f[2])!=null){const{translate:[,,p],scale:[,,x]}=s;n=v=>v*x+p}if(this.hasM&&((g=s==null?void 0:s.scale)==null?void 0:g[3])!=null){const{translate:[,,,p],scale:[,,,x]}=s;y=v=>v==null?v:v*x+p}const o=this._getHydrationFunction(r,m,u,n,y);for(const{geometry:p}of l)p!=null&&o&&o(p);return this.transform=null,this}readFeaturesWithClass(r,l,s){var t;const e=w.fromJSON(l.spatialReference),i=[];for(let a=0;a<r.length;a++){const m=r[a],u=s.fromJSON(m),n=(t=m.geometry)==null?void 0:t.spatialReference;u.geometry==null||n||(u.geometry.spatialReference=e);const y=m.aggregateGeometries,o=u.aggregateGeometries;if(y&&o!=null)for(const f in o){const g=o[f],p=y[f],x=p==null?void 0:p.spatialReference;g==null||x||(g.spatialReference=e)}i.push(u)}return i}_quantizePoints(r,l,s){let e,i;const t=[];for(let a=0,m=r.length;a<m;a++){const u=r[a];if(a>0){const n=l(u[0]),y=s(u[1]);n===e&&y===i||(t.push([n-e,y-i]),e=n,i=y)}else e=l(u[0]),i=s(u[1]),t.push([e,i])}return t.length>0?t:null}_getQuantizationFunction(r,l,s){return r==="point"?e=>(e.x=l(e.x),e.y=s(e.y),e):r==="polyline"||r==="polygon"?e=>{const i=R(e)?e.rings:e.paths,t=[];for(let a=0,m=i.length;a<m;a++){const u=i[a],n=this._quantizePoints(u,l,s);n&&t.push(n)}return t.length>0?(R(e)?e.rings=t:e.paths=t,e):null}:r==="multipoint"?e=>{const i=this._quantizePoints(e.points,l,s);return i&&i.length>0?(e.points=i,e):null}:r==="extent"?e=>e:null}_getHydrationFunction(r,l,s,e,i){return r==="point"?t=>{t.x=l(t.x),t.y=s(t.y),e&&(t.z=e(t.z))}:r==="polyline"||r==="polygon"?t=>{const a=R(t)?t.rings:t.paths;let m,u;for(let n=0,y=a.length;n<y;n++){const o=a[n];for(let f=0,g=o.length;f<g;f++){const p=o[f];f>0?(m+=p[0],u+=p[1]):(m=p[0],u=p[1]),p[0]=l(m),p[1]=s(u)}}if(e&&i)for(let n=0,y=a.length;n<y;n++){const o=a[n];for(let f=0,g=o.length;f<g;f++){const p=o[f];p[2]=e(p[2]),p[3]=i(p[3])}}else if(e)for(let n=0,y=a.length;n<y;n++){const o=a[n];for(let f=0,g=o.length;f<g;f++){const p=o[f];p[2]=e(p[2])}}else if(i)for(let n=0,y=a.length;n<y;n++){const o=a[n];for(let f=0,g=o.length;f<g;f++){const p=o[f];p[2]=i(p[2])}}}:r==="extent"?t=>{t.xmin=l(t.xmin),t.ymin=s(t.ymin),t.xmax=l(t.xmax),t.ymax=s(t.ymax),e&&t.zmax!=null&&t.zmin!=null&&(t.zmax=e(t.zmax),t.zmin=e(t.zmin)),i&&t.mmax!=null&&t.mmin!=null&&(t.mmax=i(t.mmax),t.mmin=i(t.mmin))}:r==="multipoint"?t=>{const a=t.points;let m,u;for(let n=0,y=a.length;n<y;n++){const o=a[n];n>0?(m+=o[0],u+=o[1]):(m=o[0],u=o[1]),o[0]=l(m),o[1]=s(u)}if(e&&i)for(let n=0,y=a.length;n<y;n++){const o=a[n];o[2]=e(o[2]),o[3]=i(o[3])}else if(e)for(let n=0,y=a.length;n<y;n++){const o=a[n];o[2]=e(o[2])}else if(i)for(let n=0,y=a.length;n<y;n++){const o=a[n];o[2]=i(o[2])}}:null}};h([d({type:String,json:{write:!0}})],c.prototype,"displayFieldName",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"exceededTransferLimit",void 0),h([d({type:[N],json:{write:!0}})],c.prototype,"features",void 0),h([T("features")],c.prototype,"readFeatures",null),h([d({type:[M],json:{write:!0}})],c.prototype,"fields",void 0),h([d({type:["point","multipoint","polyline","polygon","extent","mesh"],json:{read:{reader:G.read}}})],c.prototype,"geometryType",void 0),h([F("geometryType")],c.prototype,"writeGeometryType",null),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasM",void 0),h([d({type:Boolean,json:{write:{overridePolicy:r=>({enabled:r})}}})],c.prototype,"hasZ",void 0),h([d({types:P,json:{write:!0}})],c.prototype,"queryGeometry",void 0),h([T("queryGeometry")],c.prototype,"readQueryGeometry",null),h([d({type:w,json:{write:!0}})],c.prototype,"spatialReference",void 0),h([F("spatialReference")],c.prototype,"writeSpatialReference",null),h([d({json:{write:!0}})],c.prototype,"transform",void 0),c=z=h([j("esri.rest.support.FeatureSet")],c),c.prototype.toJSON.isDefaultToJSON=!0;const L=c;export{L as O};
