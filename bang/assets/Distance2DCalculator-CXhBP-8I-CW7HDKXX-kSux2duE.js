import{jY as $,jZ as j}from"./index-BeTPrQ6f.js";import{Z as u,v as I,b as f,p as A,J as T,aQ as Q,r as J,e as C,m as H}from"./Point2D-BVUQyGsf-qih0ZuJV.js";import{e as G,r as R,L as X,f as K,u as ee,n as te}from"./ProjectionTransformation-BXUROh_s-kKBZ5FDB.js";import{Envelope2D as E}from"./Envelope2D-2iYexKQo-BCKocNS7.js";function Z(){return{outPoint:new I,index:-1,t:Number.NaN}}function w(a,e,t){return{outPoint:a.clone(),index:e,t}}function l(a,e,t,n){a.outPoint.assign(e),a.index=t,a.t=n}function B(a,e){a.outPoint.assign(e.outPoint),a.index=e.index,a.t=e.t}function U(a,e,t,n){a.index=t,a.t=n,e.queryCoord2D(a.t,a.outPoint)}function Y(a,e){const t=Z();B(t,a),B(a,e),B(e,t)}function ne(a,e,t,n,r,i){if(a.getGeometryType()===u.enumPolygon){for(;n.nextPath();)if(n.hasNextSegment()){const s=n.nextSegment();if(X(a,s.getEndXY(),0)!==0)return l(r,s.getEndXY(),-1,Number.NaN),l(i,s.getEndXY(),-1,Number.NaN),!0}n.resetToFirstPath()}if(e.getGeometryType()===u.enumPolygon){for(;t.nextPath();)if(t.hasNextSegment()){const s=t.nextSegment();if(X(e,s.getEndXY(),0)!==0)return l(r,s.getEndXY(),-1,Number.NaN),l(i,s.getEndXY(),-1,Number.NaN),!0}t.resetToFirstPath()}return!1}function re(a){const e=a.getPathCount(),t=H(a.getSegmentCount(),0);let n=0;for(let r=0;r<e;++r){const i=n+a.getSegmentCountPath(r);for(let s=n,m=a.getPathStart(r);s<i;++s,++m)t[s]=m;n=i}return te(a.getPointCount(),t),t}function W(a,e){return!!Number.isNaN(e)||a<=e}function F(a){const e=new ee;return e.addEnvelope(a,!1),e}class ae{constructor(e,t){if(this.m_env2DgeometryA=null,this.m_env2DgeometryB=null,this.m_progressCounter=0,this.m_progressTracker=t,this.m_maxSqrDistance=e*e,this.m_maxDistance=e,this.m_bIsNearCalc=!1,Number.isNaN(this.m_maxDistance)?this.m_maxDistance=Number.POSITIVE_INFINITY:this.m_maxDistance=e,this.m_maxSqrDistance=this.m_maxDistance*this.m_maxDistance,Number.isFinite(this.m_maxSqrDistance)){let n=Math.sqrt(this.m_maxSqrDistance);for(;n<this.m_maxDistance;)this.m_maxSqrDistance*=1+Number.EPSILON,n=Math.sqrt(this.m_maxSqrDistance)}}calculate(e,t,n,r){if((e.getGeometryType()!==G.type||t.getGeometryType()!==G.type)&&(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!W(this.m_env2DgeometryA.distanceFromEnvelope(this.m_env2DgeometryB),this.m_maxDistance)))return Number.POSITIVE_INFINITY;const i=w(new I,C(),Number.NaN),s=w(new I,C(),Number.NaN),m=this._ExecuteBruteForce(e,t,i,s);return W(m,this.m_maxDistance)?(n!==null&&B(n,i),r!==null&&B(r,s),m):Number.POSITIVE_INFINITY}isNear(e,t){if(this.m_bIsNearCalc=!0,e.isEmpty()||t.isEmpty())return!1;if(e===t)return!0;let n=!0;if(e.getGeometryType()!==G.type&&e.getGeometryType()!==R.type||t.getGeometryType()!==G.type&&t.getGeometryType()!==R.type||(n=!1),n){if(this.m_env2DgeometryA=new E,this.m_env2DgeometryB=new E,e.queryEnvelope(this.m_env2DgeometryA),t.queryEnvelope(this.m_env2DgeometryB),!(this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)>this.m_maxSqrDistance))return!0;if(this.m_env2DgeometryA.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>this.m_maxSqrDistance)return!1}const r=w(new I,C(),Number.NaN),i=w(new I,C(),Number.NaN);return this._ExecuteBruteForce(e,t,r,i)<=this.m_maxDistance}progress_(e=!1){}_ExecuteBruteForce(e,t,n,r){switch(e.getGeometryType()){case u.enumPoint:return this.distancePointGeometry(e,t,n,r);case u.enumMultiPoint:return this.distanceMultipointGeometry(e,t,n,r);case u.enumEnvelope:return this.distanceEnvelopeGeometry(e,t,n,r);case u.enumPolyline:case u.enumPolygon:return this.distanceMultipathGeometry(e,t,n,r);default:return Number.NaN}}distancePointGeometry(e,t,n,r){switch(t.getGeometryType()){case u.enumPoint:return this.distancePointPoint(e,t,n,r);case u.enumMultiPoint:return this.distancePointMultipoint(e,t,n,r);case u.enumPolyline:case u.enumPolygon:return this.distancePointMultipath(e,t,n,r);case u.enumEnvelope:return this.distancePointEnvelope(e,t,n,r);default:return Number.NaN}}distancePointPoint(e,t,n,r){const i=e.getXY(),s=t.getXY();return l(n,i,0,0),l(r,s,0,0),Math.sqrt(I.sqrDistance(i,s))}distancePointMultipoint(e,t,n,r){const i=e.getXY();let s=this.m_maxSqrDistance,m=s,o=!1;const c=t.getPointCount(),y=new I;for(let _=0;_<c;++_)if(t.queryXY(_,y),m=I.sqrDistance(i,y),this.m_bIsNearCalc){if(m<=s)return 0}else if(!(m>s)&&(!o&&m===s||m<s)&&(s=m,l(n,i,0,0),l(r,y,_,0),o=!0,s===0))return 0;return o?Math.sqrt(s):Number.POSITIVE_INFINITY}distancePointMultipath(e,t,n,r){const i=!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB),s=e.getXY();if(!i&&t.getGeometryType()===u.enumPolygon&&X(t,s,0)!==0)return l(n,s,0,0),l(r,s,-1,Number.NaN),0;t.getImpl().getAccelerators();let m=this.m_maxSqrDistance,o=m,c=-1;const y=new E,_=t.querySegmentIterator();let h=!1;for(;_.nextPath();)for(;_.hasNextSegment();){const D=_.nextSegment();D.queryEnvelope(y);const d=y.sqrDistance(s);if(d>m||!this.m_bIsNearCalc&&h&&d===m)continue;c=D.getClosestCoordinate(s,!1);const g=D.getCoord2D(c);if(o=I.sqrDistance(s,g),this.m_bIsNearCalc){if(o<=m)return 0}else if(!(o>m)&&(!h||o<m)&&(m=o,l(n,s,0,0),l(r,g,_.getStartPointIndex(),c),h=!0,m===0))return 0}return h?Math.sqrt(m):Number.POSITIVE_INFINITY}distancePointEnvelope(e,t,n,r){const i=e.getXY();l(n,i,0,0),l(r,i,-1,Number.NaN);const s=t.asEnvelope2D();return s.contains(i)?0:Math.sqrt(s.sqrDistance(i,r.outPoint))}distanceMultipointGeometry(e,t,n,r){switch(t.getGeometryType()){case u.enumPoint:{this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipoint(t,e,r,n);return this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case u.enumMultiPoint:return this.distanceMultipointMultipoint(e,t,n,r,1,1);case u.enumPolyline:case u.enumPolygon:return this.distanceMultipointMultipath(e,t,n,r);case u.enumEnvelope:return this.distanceMultipointMultipath(e,F(t),n,r);default:return Number.NaN}}distanceMultipointMultipoint(e,t,n,r,i,s){const m={stack:[],error:void 0,hasError:!1};try{if(this.m_bIsNearCalc&&i===1&&s===1){const x=Math.trunc(A(Math.sqrt(e.getPointCount())+1,1,T())),P=Math.trunc(A(Math.sqrt(t.getPointCount())+1,1,T()));if((x>=4||P>=4)&&this.distanceMultipointMultipoint(e,t,n,r,x,P)<=this.m_maxSqrDistance)return 0}let o=this.m_maxSqrDistance;const c=[e],y=[t],_=this.swapGeometriesIfBGtA(c,y);_&&(this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),s=f(i,i=s),Y(n,r)),$(m,Q(()=>{Y(n,r),this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!_),!1);const h=c[0].getImpl(),D=y[0].getImpl(),d=h.getPointCount(),g=D.getPointCount(),M=g>1;let q=!1;const N=new I,v=new I;for(let x=0;x<d;x+=i){if(h.queryXY(x,N),M){const P=this.m_env2DgeometryB.sqrDistance(N);if(this.m_bIsNearCalc){if(P>o)continue;if(this.m_env2DgeometryB.sqrMaxMinDistance(N)<=o)return 0}else if(P>=o)continue}for(let P=0;P<g;P+=s){D.queryXY(P,v);const p=I.sqrDistance(N,v);if(this.m_bIsNearCalc){if(p<=o)return 0}else if(!(p>o||q&&p===o)&&(!q||p<o)&&(l(n,N,x,0),l(r,v,P,0),q=!0,o=p,o===0))return q?Math.sqrt(o):Number.POSITIVE_INFINITY}}return q?Math.sqrt(o):Number.POSITIVE_INFINITY}catch(o){m.error=o,m.hasError=!0}finally{j(m)}}distanceMultipointMultipath(e,t,n,r){let i=!!this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)&&t.getGeometryType()===u.enumPolygon;const s=t.querySegmentIterator();s.stripAttributes();const m=new E,o=new I;let c=this.m_maxSqrDistance;const y=e.getImpl(),_=y.getPointCount(),h=_>1;let D=!1;for(;s.nextPath();)for(;s.hasNextSegment();){const d=s.nextSegment();if(d.queryLooseEnvelope(m),h){const g=m.sqrDistanceEnvelope(this.m_env2DgeometryA,null,null);if(this.m_bIsNearCalc){if(g>c)continue}else if(g>c||D&&g===c)continue}for(let g=0;g<_;g++){if(y.queryXY(g,o),i&&X(t,o,0)!==0)return l(n,o,-1,Number.NaN),l(r,o,g,0),0;{const v=m.sqrDistance(o);if(this.m_bIsNearCalc){if(v>c)continue}else if(v>c)continue}const M=d.getClosestCoordinate(o,!1),q=d.getCoord2D(M);o.subThis(q);const N=o.sqrLength();if(this.m_bIsNearCalc){if(N<=c)return 0}else if(!(N>c)&&(!D||N<c)&&(c=N,l(n,y.getXY(g),g,0),l(r,q,s.getStartPointIndex(),M),D=!0,c===0))return 0}i=!1}return D?Math.sqrt(c):Number.POSITIVE_INFINITY}distanceEnvelopeGeometry(e,t,n,r){switch(t.getGeometryType()){case u.enumPoint:return this.distancePointEnvelope(t,e,r,n);case u.enumMultiPoint:{this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(t,F(e),r,n);return this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case u.enumPolyline:case u.enumPolygon:return this.distanceMultipathMultipath(F(e),t,n,r);case u.enumEnvelope:return this.distanceEnvelopeEnvelope(e,t,n,r);default:return Number.NaN}}distanceEnvelopeEnvelope(e,t,n,r){n.t=Number.NaN,n.index=-1,r.t=Number.NaN,r.index=-1;const i=e.asEnvelope2D(),s=t.asEnvelope2D();return Math.sqrt(i.sqrDistanceEnvelope(s,n.outPoint,r.outPoint))}distanceMultipathGeometry(e,t,n,r){switch(t.getGeometryType()){case u.enumPoint:{this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distancePointMultipath(t,e,r,n);return this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case u.enumMultiPoint:{this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB);const i=this.distanceMultipointMultipath(t,e,r,n);return this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),i}case u.enumPolyline:case u.enumPolygon:return this.distanceMultipathMultipath(e,t,n,r);case u.enumEnvelope:return this.distanceMultipathMultipath(e,F(t),n,r);default:return Number.NaN}}distanceMultipathMultipath(e,t,n,r){const i={stack:[],error:void 0,hasError:!1};try{const s=[e],m=[t],o=this.swapGeometriesIfAGtB(s,m);o&&(this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB),Y(n,r)),$(i,Q(()=>{Y(n,r),this.m_env2DgeometryB=f(this.m_env2DgeometryA,this.m_env2DgeometryA=this.m_env2DgeometryB)},!o),!1);const c=s[0],y=m[0],_=c.querySegmentIterator();_.stripAttributes();const h=y.querySegmentIterator();if(h.stripAttributes(),this.m_bIsNearCalc&&this.m_env2DgeometryA.sqrMaxMinDistanceEnvelope(this.m_env2DgeometryB)<=this.m_maxSqrDistance)return 0;if(this.m_bIsNearCalc){const p=Math.trunc(A(Math.sqrt(c.getPointCount())+1,1,T())),S=Math.trunc(A(Math.sqrt(c.getPointCount())+1,1,T()));if(this.distanceMultipointMultipoint(c,y,n,r,p,S)<=this.m_maxSqrDistance)return 0}if(this.m_env2DgeometryA.isIntersecting(this.m_env2DgeometryB)){const p=Z(),S=Z();if(ne(c,y,_,h,p,S))return B(n,p),B(r,S),0}const D=re(c),d=[],g=new K,M=new E,q=new E,N=new E;let v=this.m_maxSqrDistance,x=!0,P=!1;for(let p=0,S=D.length;p<S;++p){c.querySegment(D[p],g,!0);const O=g.get();if(O.queryEnvelope(M),!(M.sqrDistanceEnvelope(this.m_env2DgeometryB,null,null)>v)){if(this.m_bIsNearCalc&&M.sqrMaxDistanceEnvelope(this.m_env2DgeometryB)<=v)return 0;for(;h.nextPath();){if(this.progress_(),x)y.queryPathEnvelope(h.getPathIndex(),N),d[h.getPathIndex()]=N.clone();else if(M.sqrDistanceEnvelope(d[h.getPathIndex()],null,null)>v)continue;for(;h.hasNextSegment();){const V=h.nextSegment();if(V.queryEnvelope(q),M.sqrDistanceEnvelope(q,null,null)<=v){const z=!M.isIntersecting(q),L=[0],k=[0];let b=O.distance(V,z,L,k);if(b*=b,this.m_bIsNearCalc&&b<=this.m_maxSqrDistance)return 0;if(b<v||b===v&&D[p]<n.index){if(P=!0,U(n,O,D[p],L[0]),U(r,V,h.getStartPointIndex(),k[0]),b===0)return 0;v=b}}}}h.resetToFirstPath(),x=!1}}return P?Math.sqrt(v):Number.POSITIVE_INFINITY}catch(s){i.error=s,i.hasError=!0}finally{j(i)}}swapGeometriesIfAGtB(e,t){return J(e[0])>J(t[0])&&(t[0]=f(e[0],e[0]=t[0]),!0)}swapGeometriesIfBGtA(e,t){return this.swapGeometriesIfAGtB(t,e)}}export{ne as R,re as W,Z as Y,ae as r};
