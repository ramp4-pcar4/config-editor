import{bD as $,v as c,I as u,cI as _,c as d,R as O,bM as M,b as T,ai as z,cJ as C,cK as q,K as P,D as U,e as k,t as S,J as D,T as R,z as j,b3 as K,bp as B,cL as E}from"./index-DLCK036j.js";import{V as A}from"./TileInfo-owTCOSRx-CWHNwPGg.js";import{G as H}from"./ByteSizeUnit-DL8UhsB0-B2-AmVRx.js";import{i as J}from"./LRUCache-BLmkvs7b-Dd-5CcIY.js";import{e as V}from"./TileKey-B_6qmYK--BtZdR-Xy.js";import{i as F}from"./memoryEstimations-iHVpvWPf-BTDcSgIs.js";class G{constructor(t,l=0,i=t.lods[t.lods.length-1].level){this.tileInfo=t,this.minLOD=l,this.maxLOD=i,t.lodAt(l)||(this.minLOD=t.lods[0].level),t.lodAt(i)||(this.maxLOD=t.lods[t.lods.length-1].level)}get effectiveMinLOD(){return this.minLOD??this.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.tileInfo.lods[this.tileInfo.lods.length-1].level}getAvailability(t,l,i){var n;const a=(n=this.tileInfo)==null?void 0:n.lodAt(t);return!a||t<this.minLOD||t>this.maxLOD?"unavailable":a.cols&&a.rows?i>=a.cols[0]&&i<=a.cols[1]&&l>=a.rows[0]&&l<=a.rows[1]?"unknown":"unavailable":"unknown"}async fetchAvailability(t,l,i,a){await _(a);const n=this.getAvailability(t,l,i);if(n==="unavailable")throw new d("tile-map:tile-unavailable","Tile is not available",{level:t,row:l,col:i});return n}async fetchAvailabilityUpsample(t,l,i,a,n){await _(n),a.level=t,a.row=l,a.col=i;const r=this.tileInfo;return r.updateTileInfo(a),this.fetchAvailability(t,l,i,n).catch(s=>{if(O(s))throw s;if(r.upsampleTile(a))return this.fetchAvailabilityUpsample(a.level,a.row,a.col,a,n);throw s})}}function N(e,t=!1){return e<=E?t?new Array(e).fill(0):new Array(e):new Uint32Array(e)}class w{constructor(t){Y(t);const{location:l,data:i}=t;this.location=Object.freeze(j(l));const a=this.location.width,n=this.location.height;let r=!0,s=!0;const p=Math.ceil(a*n/32),o=N(p);let h=0;for(let f=0;f<i.length;f++){const m=f%32;i[f]?(s=!1,o[h]|=1<<m):r=!1,m===31&&++h}s?(this._availability="unavailable",this.byteSize=40):r?(this._availability="available",this.byteSize=40):(this._availability=o,this.byteSize=40+F(o))}getAvailability(t,l){if(this._availability==="unavailable"||this._availability==="available")return this._availability;const i=(t-this.location.top)*this.location.width+(l-this.location.left),a=i%32,n=i>>5,r=this._availability;return n<0||n>r.length?"unknown":r[n]&1<<a?"available":"unavailable"}static fromDefinition(t,l){const i=t.service.request||T,{row:a,col:n,width:r,height:s}=t,p={query:{f:"json"}};return l=l?{...p,...l}:p,i(Q(t),l).then(o=>o.data).catch(o=>{var h;if(((h=o==null?void 0:o.details)==null?void 0:h.httpStatus)===422)return{location:{top:a,left:n,width:r,height:s},valid:!0,data:new Array(r*s).fill(0)};throw o}).then(o=>{if(o.location&&(o.location.top!==a||o.location.left!==n||o.location.width!==r||o.location.height!==s))throw new d("tilemap:location-mismatch","Tilemap response for different location than requested",{response:o,definition:{top:a,left:n,width:r,height:s}});return w.fromJSON(o)})}static fromJSON(t){return Object.freeze(new w(t))}}function x(e){return`${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}function Q(e){var i;let t;if((i=e.service.tileServers)!=null&&i.length){const a=e.service.tileServers;t=`${a&&a.length?a[e.row%a.length]:e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`}else t=`${e.service.url}/tilemap/${e.level}/${e.row}/${e.col}/${e.width}/${e.height}`;const l=e.service.query;return l&&(t=`${t}?${l}`),t}function Y(e){if(!(e!=null&&e.location))throw new d("tilemap:missing-location","Location missing from tilemap response");if(e.valid===!1)throw new d("tilemap:invalid","Tilemap response was marked as invalid");if(!e.data)throw new d("tilemap:missing-data","Data missing from tilemap response");if(!Array.isArray(e.data))throw new d("tilemap:data-mismatch","Data must be an array of numbers");if(e.data.length!==e.location.width*e.location.height)throw new d("tilemap:data-mismatch","Number of data items does not match width/height of tilemap")}var y;function I(e,t,l){return new d("tile-map:tile-unavailable","Tile is not available",{level:e,row:t,col:l})}let v=y=class extends M{constructor(e){super(e),this._pendingTilemapRequests={},this.request=T,this.size=32,this._prefetchingEnabled=!0}initialize(){this._tilemapCache=new J(2*H.MEGABYTES),this.addHandles(z(()=>{const{layer:e}=this;return[e==null?void 0:e.parsedUrl,e==null?void 0:e.tileServers,e==null?void 0:e.apiKey,e==null?void 0:e.customParameters]},()=>this._initializeTilemapDefinition(),C))}get effectiveMinLOD(){return this.minLOD??this.layer.tileInfo.lods[0].level}get effectiveMaxLOD(){return this.maxLOD??this.layer.tileInfo.lods[this.layer.tileInfo.lods.length-1].level}getAvailability(e,t,l){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return"unavailable";const i=this._tilemapFromCache(e,t,l,this._tmpTilemapDefinition);return i?i.getAvailability(t,l):"unknown"}fetchAvailability(e,t,l,i){return!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD?Promise.reject(I(e,t,l)):this._fetchTilemap(e,t,l,i).catch(a=>a).then(a=>{if(a instanceof w){const n=a.getAvailability(t,l);if(n==="unavailable")throw I(e,t,l);return n}if(O(a))throw a;return"unknown"})}fetchAvailabilityUpsample(e,t,l,i,a){i.level=e,i.row=t,i.col=l;const n=this.layer.tileInfo;n.updateTileInfo(i);const r=this.fetchAvailability(e,t,l,a).catch(s=>{if(O(s))throw s;if(n.upsampleTile(i))return this.fetchAvailabilityUpsample(i.level,i.row,i.col,i,a);throw s});return this._fetchAvailabilityUpsamplePrefetch(i.id,e,t,l,a,r),r}async _fetchAvailabilityUpsamplePrefetch(e,t,l,i,a,n){if(!this._prefetchingEnabled||e==null)return;const r=`prefetch-${e}`;if(this.hasHandles(r))return;const s=new AbortController;n.then(()=>s.abort(),()=>s.abort());let p=!1;const o=K(()=>{p||(p=!0,s.abort())});if(this.addHandles(o,r),await q(10,s.signal).catch(()=>{}),p||(p=!0,this.removeHandles(r)),P(s))return;const h=new V(e,t,l,i),f={...a,signal:s.signal},m=this.layer.tileInfo;for(let b=0;y._prefetches.length<y._maxPrefetch&&m.upsampleTile(h);++b){const g=this.fetchAvailability(h.level,h.row,h.col,f);y._prefetches.push(g);const L=()=>{y._prefetches.removeUnordered(g)};g.then(L,L)}}_fetchTilemap(e,t,l,i){if(!this.layer.tileInfo.lodAt(e)||e<this.effectiveMinLOD||e>this.effectiveMaxLOD)return Promise.reject(new d("tilemap-cache:level-unavailable",`Level ${e} is unavailable in the service`));const a=this._tmpTilemapDefinition,n=this._tilemapFromCache(e,t,l,a);if(n)return Promise.resolve(n);const r=i==null?void 0:i.signal;return i={...i,signal:null},new Promise((s,p)=>{U(r,()=>p(B()));const o=x(a);let h=this._pendingTilemapRequests[o];if(!h){h=w.fromDefinition(a,i).then(m=>(this._tilemapCache.put(o,m,m.byteSize),m));const f=()=>{delete this._pendingTilemapRequests[o]};this._pendingTilemapRequests[o]=h,h.then(f,f)}h.then(s,p)})}_initializeTilemapDefinition(){var i;if(!this.layer.parsedUrl)return;const{parsedUrl:e,apiKey:t,customParameters:l}=this.layer;this._tilemapCache.clear(),this._tmpTilemapDefinition={service:{url:e.path,query:k({...e.query,...l,token:t??((i=e.query)==null?void 0:i.token)}),tileServers:this.layer.tileServers,request:this.request},width:this.size,height:this.size,level:0,row:0,col:0}}_tilemapFromCache(e,t,l,i){i.level=e,i.row=t-t%this.size,i.col=l-l%this.size;const a=x(i);return this._tilemapCache.get(a)}get test(){}};v._maxPrefetch=4,v._prefetches=new $({initialSize:y._maxPrefetch}),c([u({constructOnly:!0})],v.prototype,"layer",void 0),c([u({constructOnly:!0})],v.prototype,"minLOD",void 0),c([u({constructOnly:!0})],v.prototype,"maxLOD",void 0),c([u({constructOnly:!0})],v.prototype,"request",void 0),c([u({constructOnly:!0})],v.prototype,"size",void 0),v=y=c([S("esri.layers.support.TilemapCache")],v);const le=e=>{let t=class extends e{constructor(){super(...arguments),this.copyright=null,this.minScale=0,this.maxScale=0,this.spatialReference=null,this.tileInfo=null,this.tilemapCache=null}destroy(){var l,i;(i=(l=this.tilemapCache)==null?void 0:l.destroy)==null||i.call(l)}readMinScale(l,i){return i.minLOD!=null&&i.maxLOD!=null?l:0}readMaxScale(l,i){return i.minLOD!=null&&i.maxLOD!=null?l:0}get supportsBlankTile(){return this.version>=10.2}readTilemapCache(l,i,a){var h;const n=(h=i.capabilities)==null?void 0:h.includes("Tilemap");let{minLOD:r,maxLOD:s,minScale:p,maxScale:o}=i;if(r==null&&s==null&&(p!==0||o!==0)){const f=m=>Math.round(1e4*m)/1e4;p=f(p||i.tileInfo.lods[0].scale),o=f(o||i.tileInfo.lods[i.tileInfo.lods.length-1].scale);for(const m of i.tileInfo.lods){const b=f(m.scale);r=b>=p?m.level:r,s=b>=o?m.level:s}}if(n)return new v({layer:this,minLOD:r,maxLOD:s});if(i.tileInfo){const f=new A;return f.read(i.tileInfo,a),new G(f,r,s)}return null}};return c([u({json:{read:{source:"copyrightText"}}})],t.prototype,"copyright",void 0),c([u()],t.prototype,"minScale",void 0),c([D("service","minScale")],t.prototype,"readMinScale",null),c([u()],t.prototype,"maxScale",void 0),c([D("service","maxScale")],t.prototype,"readMaxScale",null),c([u({type:R})],t.prototype,"spatialReference",void 0),c([u({readOnly:!0})],t.prototype,"supportsBlankTile",null),c([u({type:A})],t.prototype,"tileInfo",void 0),c([u()],t.prototype,"tilemapCache",void 0),c([D("service","tilemapCache",["capabilities","tileInfo"])],t.prototype,"readTilemapCache",null),c([u()],t.prototype,"version",void 0),t=c([S("esri.layers.mixins.ArcGISCachedService")],t),t};export{G as T,le as V,v};
