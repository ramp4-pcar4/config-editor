import{aj as N,bY as z,N as _,aa as H,M as I,c6 as T,f8 as W,aM as Y,m,E as l,n as $}from"./index-BeTPrQ6f.js";import{p as q}from"./TileInfo-BmHJ3kZT-BCenfvrA.js";import{s as A}from"./BitmapTechnique-BhFKaUl9-DD4q1hpj.js";import{m as B}from"./Tile-BNoJIjzH-DZ-xZWMb.js";import{s as C}from"./TileKey-BZu7Ia24-BiyRHU0x.js";const G=Math.PI/180;function O(p){return p*G}function j(p,a){const i=O(a.rotation),s=Math.abs(Math.cos(i)),t=Math.abs(Math.sin(i)),[r,o]=a.size;return p[0]=Math.round(o*t+r*s),p[1]=Math.round(o*s+r*t),p}function J(p,a,i,s){const[t,r]=a,[o,d]=s,e=.5*i;return p[0]=t-e*o,p[1]=r-e*d,p[2]=t+e*o,p[3]=r+e*d,p}const u=Y(),c=[0,0],w=new C(0,0,0,0),M={imageMaxWidth:2048,imageMaxHeight:2048,imageRotationSupported:!1,imageNormalizationSupported:!1,hidpi:!1};let h=class extends N{constructor(a){super(a),this._imagePromise=null,this.bitmaps=[],this.hidpi=M.hidpi,this.imageMaxWidth=M.imageMaxWidth,this.imageMaxHeight=M.imageMaxHeight,this.imageRotationSupported=M.imageRotationSupported,this.imageNormalizationSupported=M.imageNormalizationSupported,this.update=z(async(i,s)=>{if(_(s),!i.stationary||this.destroyed)return;const t=i.state,r=H(t.spatialReference),o=this.hidpi?i.pixelRatio:1,d=t.worldScreenWidth>0,e=d&&this.imageNormalizationSupported&&t.worldScreenWidth<t.size[0],f=Math.round((this.imageMaxWidth??0)/o),x=Math.round((this.imageMaxHeight??0)/o);e?(c[0]=t.worldScreenWidth,c[1]=t.size[1]):this.imageRotationSupported?(c[0]=t.size[0],c[1]=t.size[1]):j(c,t);const S=Math.floor(c[0])>f||Math.floor(c[1])>x,v=r&&(t.extent.xmin<r.valid[0]||t.extent.xmax>r.valid[1]),R=!this.imageNormalizationSupported&&v,y=!S&&!R,b=this.imageRotationSupported?t.rotation:0,E=this.container.children.slice();if(y){const n=e?t.paddedViewState.center:t.center;this._imagePromise=this._singleExport(t,c,n,t.resolution,b,o,s)}else{let n=Math.min(f,x);d&&(n=Math.min(t.worldScreenWidth,n),n=Math.round(t.worldScreenWidth/Math.ceil(t.worldScreenWidth/n))),this._imagePromise=this._tiledExport(t,n,o,s)}try{const n=await this._imagePromise??[];_(s);const P=[];if(this._imagePromise=null,this.destroyed)return;this.bitmaps=n;for(const g of E)n.includes(g)||P.push(g.fadeOut().then(()=>{g.remove(),g.destroy()}));for(const g of n)P.push(g.fadeIn());await Promise.all(P)}catch(n){this._imagePromise=null,I(n)}},5e3),this.updateExports=z(async i=>{const s=[];for(const t of this.container.children){if(!t.visible||!t.stage)return;s.push(i(t).then(()=>{t.invalidateTexture(),t.requestRender()}))}this._imagePromise=T(s).then(()=>this._imagePromise=null),await this._imagePromise})}destroy(){this.bitmaps.forEach(a=>a.destroy()),this.bitmaps=[]}get updating(){return!this.destroyed&&this._imagePromise!==null}async _export(a,i,s,t,r,o){const d=await this.fetchSource(a,Math.floor(i*r),Math.floor(s*r),{rotation:t,pixelRatio:r,signal:o});_(o);const e=new A(null,!0);return e.x=a.xmin,e.y=a.ymax,e.resolution=a.width/i,e.rotation=t,e.pixelRatio=r,e.opacity=0,this.container.addChild(e),await e.setSourceAsync(d,o),_(o),e}async _singleExport(a,i,s,t,r,o,d){J(u,s,t,i);const e=W(u,a.spatialReference);return[await this._export(e,i[0],i[1],r,o,d)]}_tiledExport(a,i,s,t){const r=q.create({size:i,spatialReference:a.spatialReference,scales:[a.scale]}),o=new B(r),d=o.getTileCoverage(a);if(!d)return null;const e=[];return d.forEach((f,x,S,v)=>{w.set(f,x,S,0),o.getTileBounds(u,w);const R=W(u,a.spatialReference);e.push(this._export(R,i,i,0,s,t).then(y=>(v!==0&&(w.set(f,x,S,v),o.getTileBounds(u,w),y.x=u[0],y.y=u[3]),y)))}),Promise.all(e)}};m([l()],h.prototype,"_imagePromise",void 0),m([l()],h.prototype,"bitmaps",void 0),m([l()],h.prototype,"container",void 0),m([l()],h.prototype,"fetchSource",void 0),m([l()],h.prototype,"hidpi",void 0),m([l()],h.prototype,"imageMaxWidth",void 0),m([l()],h.prototype,"imageMaxHeight",void 0),m([l()],h.prototype,"imageRotationSupported",void 0),m([l()],h.prototype,"imageNormalizationSupported",void 0),m([l()],h.prototype,"requestUpdate",void 0),m([l()],h.prototype,"updating",null),h=m([$("esri.views.2d.layers.support.ExportStrategy")],h);export{h};
