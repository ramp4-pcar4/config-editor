import{ah as N,P as Y,N as tt,gy as G,gz as W,aa as et,F as nt,aO as ot}from"./index-BeTPrQ6f.js";const q=()=>Y.getLogger("esri.views.2d.engine.flow.dataUtils"),rt=10;async function mt(m,t,r,u){const w=performance.now(),a=it(t,r),e=performance.now(),p=at(t,a,r.width,r.height),n=performance.now(),o=ct(p),s=performance.now(),A=m==="Streamlines"?ft(o,rt):ut(o),g=performance.now();return N("esri-2d-profiler")&&(q().info("I.1","_createFlowFieldFromData (ms)",Math.round(e-w)),q().info("I.2","_getStreamlines (ms)",Math.round(n-e)),q().info("I.3","createAnimatedLinesData (ms)",Math.round(s-n)),q().info("I.4","create{Streamlines|Particles}Mesh (ms)",Math.round(g-s)),q().info("I.5","createFlowMesh (ms)",Math.round(g-w)),q().info("I.6","Mesh size (bytes)",A.vertexData.buffer.byteLength+A.indexData.buffer.byteLength)),await Promise.resolve(),tt(u),A}function it(m,t){const r=st(t.data,t.width,t.height,m.smoothing);return m.interpolate?(u,w)=>{const a=Math.floor(u),e=Math.floor(w);if(a<0||a>=t.width)return[0,0];if(e<0||e>=t.height)return[0,0];const p=u-a,n=w-e,o=a,s=e,A=a<t.width-1?a+1:a,g=e<t.height-1?e+1:e,c=r[2*(s*t.width+o)],f=r[2*(s*t.width+A)],d=r[2*(g*t.width+o)],M=r[2*(g*t.width+A)],y=r[2*(s*t.width+o)+1],h=r[2*(s*t.width+A)+1];return[(c*(1-n)+d*n)*(1-p)+(f*(1-n)+M*n)*p,(y*(1-n)+r[2*(g*t.width+o)+1]*n)*(1-p)+(h*(1-n)+r[2*(g*t.width+A)+1]*n)*p]}:(u,w)=>{const a=Math.round(u),e=Math.round(w);return a<0||a>=t.width||e<0||e>=t.height?[0,0]:[r[2*(e*t.width+a)],r[2*(e*t.width+a)+1]]}}function j(m,t,r,u,w,a,e,p){const n=[],{raster:o,width:s,height:A,resolutionFactor:g}=p;let c=u,f=w,d=0,[M,y]=r(c,f);M*=t.velocityScale,y*=t.velocityScale;const h=Math.sqrt(M*M+y*y);let x,l;n.push({x:c,y:f,t:d,speed:h});for(let i=0;i<t.verticesPerLine;i++){let[v,O]=r(c,f);v*=t.velocityScale,O*=t.velocityScale;const T=Math.sqrt(v*v+O*O);if(T<t.minSpeedThreshold)return n;const B=m*v/T,S=m*O/T;if(c+=B*t.segmentLength,f+=S*t.segmentLength,t.wrapAround&&(c=W(c,a[0])),d+=m*t.segmentLength/T,Math.acos(B*x+S*l)>t.maxTurnAngle)return n;if(t.collisions){let P=Math.round(c*g);const F=Math.round(f*g);if(t.wrapAround&&(P=W(P,s)),P<0||P>s-1||F<0||F>A-1)return n;const V=o[F*s+P];if(V!==-1&&V!==e)return n;o[F*s+P]=e}n.push({x:c,y:f,t:d,speed:T}),x=B,l=S}return n}function lt(m,t,r,u,w,a,e,p){const n=Math.round((.2+.6*e.getFloat())*m.verticesPerLine),o=m.verticesPerLine-n,s=j(-1,{...m,verticesPerLine:o},t,r,u,w,a,p),A=j(1,{...m,verticesPerLine:n},t,r,u,w,a,p),g=s.reverse();return g.splice(-1,1),g.concat(A)}function at(m,t,r,u,w={positions:[]}){if(m.density<=0)return[];const{positions:a}=w,e=[],p=new G,n=1/Math.max(m.lineCollisionWidth,1),o=Math.round(r*n),s=Math.round(u*n),A=new Int32Array(o*s);for(let h=0;h<A.length;h++)A[h]=-1;const g={raster:A,width:o,height:s,resolutionFactor:n},c={},f=m.lineSpacing/Math.sqrt(m.density),d=Math.floor(u/f),M=Math.floor(r/f);for(let h=0;h<d;h++){const x=h*f;for(let l=0;l<M;l++){const i=l*f;c[`${l}-${h}`]={x:i,y:x,positions:[]}}}for(const{x:h,y:x}of a){const l=c[`${Math.floor(h/f)}-${Math.floor(x/f)}`];l&&l.positions.push([h,x])}const y=[];for(const h in c){const x=c[h];if(x.positions.length===0)y.push({x:x.x+f/2,y:x.y+f/2,sort:.66+.33*p.getFloat(),stage:0});else{const[l]=x.positions.splice(0,1);y.push({x:l[0],y:l[1],sort:.33*p.getFloat(),stage:1});for(const[i,v]of x.positions)y.push({x:i,y:v,sort:.33+.33*p.getFloat(),stage:2})}}y.sort((h,x)=>h.sort-x.sort);for(const{x:h,y:x,stage:l}of y){const i=m.onlyForwardTracing?j(1,m,t,h,x,[r,u],e.length,g):lt(m,t,h,x,[r,u],e.length,p,g);i.length<2||e.push({stage:l,vertices:i})}return e}function st(m,t,r,u){if(u===0)return m;const w=Math.round(3*u),a=new Array(2*w+1);let e=0;for(let o=-w;o<=w;o++){const s=Math.exp(-o*o/(u*u));a[o+w]=s,e+=s}for(let o=-w;o<=w;o++)a[o+w]/=e;const p=new Float32Array(m.length);for(let o=0;o<r;o++)for(let s=0;s<t;s++){let A=0,g=0;for(let c=-w;c<=w;c++){if(s+c<0||s+c>=t)continue;const f=a[c+w];A+=f*m[2*(o*t+(s+c))],g+=f*m[2*(o*t+(s+c))+1]}p[2*(o*t+s)]=A,p[2*(o*t+s)+1]=g}const n=new Float32Array(m.length);for(let o=0;o<t;o++)for(let s=0;s<r;s++){let A=0,g=0;for(let c=-w;c<=w;c++){if(s+c<0||s+c>=r)continue;const f=a[c+w];A+=f*p[2*((s+c)*t+o)],g+=f*p[2*((s+c)*t+o)+1]}n[2*(s*t+o)]=A,n[2*(s*t+o)+1]=g}return n}function ct(m,t){const r=new G,u=m.reduce((n,o)=>n+o.vertices.length,0),w=new Float32Array(4*u),a=new Array(m.length);let e=0,p=0;for(const{vertices:n}of m){const o=e;for(const s of n)w[4*e]=s.x,w[4*e+1]=s.y,w[4*e+2]=s.t,w[4*e+3]=s.speed,e++;a[p++]={startVertex:o,numberOfVertices:n.length,totalTime:n[n.length-1].t,timeSeed:r.getFloat()}}return{lineVertices:w,lineDescriptors:a}}function ft(m,t){const{lineVertices:r,lineDescriptors:u}=m;let w=0,a=0;for(const g of u)w+=2*g.numberOfVertices,a+=6*(g.numberOfVertices-1);const e=new Float32Array(w*9),p=new Uint32Array(a);let n=0,o=0;function s(){p[o++]=n-2,p[o++]=n,p[o++]=n-1,p[o++]=n,p[o++]=n+1,p[o++]=n-1}function A(g,c,f,d,M,y,h,x){const l=n*9;let i=0;e[l+i++]=g,e[l+i++]=c,e[l+i++]=1,e[l+i++]=f,e[l+i++]=y,e[l+i++]=h,e[l+i++]=d/2,e[l+i++]=M/2,e[l+i++]=x,n++,e[l+i++]=g,e[l+i++]=c,e[l+i++]=-1,e[l+i++]=f,e[l+i++]=y,e[l+i++]=h,e[l+i++]=-d/2,e[l+i++]=-M/2,e[l+i++]=x,n++}for(const g of u){const{totalTime:c,timeSeed:f}=g;let d=null,M=null,y=null,h=null,x=null,l=null;for(let i=0;i<g.numberOfVertices;i++){const v=r[4*(g.startVertex+i)],O=r[4*(g.startVertex+i)+1],T=r[4*(g.startVertex+i)+2],B=r[4*(g.startVertex+i)+3];let S=null,P=null,F=null,V=null;if(i>0){S=v-d,P=O-M;const b=Math.sqrt(S*S+P*P);if(S/=b,P/=b,i>1){let I=S+x,U=P+l;const R=Math.sqrt(I*I+U*U);I/=R,U/=R;const L=Math.min(1/(I*S+U*P),t);I*=L,U*=L,F=-U,V=I}else F=-P,V=S;F!==null&&V!==null&&(A(d,M,y,F,V,c,f,B),s())}d=v,M=O,y=T,x=S,l=P,h=B}A(d,M,y,-l,x,c,f,h)}return{vertexData:e,indexData:p}}function ut(m){const{lineVertices:t,lineDescriptors:r}=m;let u=0,w=0;for(const F of r){const V=F.numberOfVertices-1;u+=4*V*2,w+=6*V*2}const a=new Float32Array(u*16),e=new Uint32Array(w);let p,n,o,s,A,g,c,f,d,M,y,h,x,l,i=0,v=0;function O(){e[v++]=i-8,e[v++]=i-7,e[v++]=i-6,e[v++]=i-7,e[v++]=i-5,e[v++]=i-6,e[v++]=i-4,e[v++]=i-3,e[v++]=i-2,e[v++]=i-3,e[v++]=i-1,e[v++]=i-2}function T(F,V,b,I,U,R,L,_,$,z,H,J,Z,K){const D=i*16;let k=0;for(const Q of[1,2])for(const X of[1,2,3,4])a[D+k++]=F,a[D+k++]=V,a[D+k++]=b,a[D+k++]=I,a[D+k++]=L,a[D+k++]=_,a[D+k++]=$,a[D+k++]=z,a[D+k++]=Q,a[D+k++]=X,a[D+k++]=Z,a[D+k++]=K,a[D+k++]=U/2,a[D+k++]=R/2,a[D+k++]=H/2,a[D+k++]=J/2,i++}function B(F,V){let b=d+y,I=M+h;const U=Math.sqrt(b*b+I*I);b/=U,I/=U;const R=d*b+M*I;b/=R,I/=R;let L=y+x,_=h+l;const $=Math.sqrt(L*L+_*_);L/=$,_/=$;const z=y*L+h*_;L/=z,_/=z,T(p,n,o,s,-I,b,A,g,c,f,-_,L,F,V),O()}function S(F,V,b,I,U,R){if(d=y,M=h,y=x,h=l,d==null&&M==null&&(d=y,M=h),A!=null&&g!=null){x=F-A,l=V-g;const L=Math.sqrt(x*x+l*l);x/=L,l/=L}d!=null&&M!=null&&B(U,R),p=A,n=g,o=c,s=f,A=F,g=V,c=b,f=I}function P(F,V){d=y,M=h,y=x,h=l,d==null&&M==null&&(d=y,M=h),d!=null&&M!=null&&B(F,V)}for(const F of r){p=null,n=null,o=null,s=null,A=null,g=null,c=null,f=null,d=null,M=null,y=null,h=null,x=null,l=null;const{totalTime:V,timeSeed:b}=F;for(let I=0;I<F.numberOfVertices;I++)S(t[4*(F.startVertex+I)],t[4*(F.startVertex+I)+1],t[4*(F.startVertex+I)+2],t[4*(F.startVertex+I)+3],V,b);P(V,b)}return{vertexData:a,indexData:e}}function C(m,t,r=t.width,u=t.height,w=0,a=0){const e=t.pixels,p=r*u,n=2,o=new Float32Array(p*n),s=t.width,A=(f,d)=>f+w+(d+a)*s,g=(f,d)=>f+d*r;let c;if(t.mask!=null)if(r!==t.width||u!==t.height||w!==0||a!==0){c=new Uint8Array(p*n);const f=t.mask;for(let d=0;d<u;++d)for(let M=0;M<r;++M){const y=A(M,d),h=g(M,d);c[n*h]=f[n*y],c[n*h+1]=f[n*y+1]}}else c=t.mask;else c=new Uint8Array(p*n),c.fill(255);if(m==="vector-uv")for(let f=0;f<u;++f)for(let d=0;d<r;++d){const M=A(d,f),y=g(d,f);o[n*y]=e[0][M],o[n*y+1]=-e[1][M]}else if(m==="vector-magdir"){const{cos:f,sin:d}=Math;for(let M=0;M<u;++M)for(let y=0;y<r;++y){const h=A(y,M),x=g(y,M),l=e[0][h],i=ot(e[1][h]),v=f(i-Math.PI/2),O=d(i-Math.PI/2);o[n*x]=v*l,o[n*x+1]=O*l}}return{data:o,mask:c,width:r,height:u}}async function wt(m,t,r,u,w,a){const e=performance.now(),p=et(t.spatialReference);if(!p){const l=await E(m,t,r,u,w,a);return N("esri-2d-profiler")&&q().info("I.7","loadImagery, early exit (ms)",Math.round(performance.now()-e)),N("esri-2d-profiler")&&q().info("I.9","Number of parts",1),l}const[n,o]=p.valid,s=o-n,A=Math.ceil(t.width/s),g=t.width/A,c=Math.round(r/A);let f=t.xmin;const d=[],M=performance.now();for(let l=0;l<A;l++){const i=new nt({xmin:f,xmax:f+g,ymin:t.ymin,ymax:t.ymax,spatialReference:t.spatialReference});d.push(E(m,i,c,u,w,a)),f+=g}const y=await Promise.all(d);if(N("esri-2d-profiler")&&q().info("I.8","All calls to _fetchPart (ms)",Math.round(performance.now()-M)),N("esri-2d-profiler")&&q().info("I.9","Number of parts",y.length),y.length===1)return N("esri-2d-profiler")&&q().info("I.10","loadImagery, general exit without stitching back (ms)",Math.round(performance.now()-e)),y[0];const h={data:new Float32Array(r*u*2),mask:new Uint8Array(r*u),width:r,height:u};let x=0;for(const l of y){for(let i=0;i<l.height;i++)for(let v=0;v<l.width;v++)x+v>=r||(h.data[2*(i*r+x+v)]=l.data[2*(i*l.width+v)],h.data[2*(i*r+x+v)+1]=l.data[2*(i*l.width+v)+1],h.mask[i*r+x+v]=l.mask[i*l.width+v]);x+=l.width}return N("esri-2d-profiler")&&q().info("I.10","loadImagery, general exit (ms)",Math.round(performance.now()-e)),h}async function E(m,t,r,u,w,a){var n;const e={requestProjectedLocalDirections:!0,signal:a};if(w!=null&&(e.timeExtent=w),m.type==="imagery"){await m.load({signal:a});const o=await m.internalFetchImage(t,r,u,e);return((n=o==null?void 0:o.pixelData)==null?void 0:n.pixelBlock)==null?{data:new Float32Array(r*u*2),mask:new Uint8Array(r*u),width:r,height:u}:C(m.rasterInfo.dataType,o.pixelData.pixelBlock)}await m.load({signal:a});const p=await m.fetchPixels(t,r,u,e);return(p==null?void 0:p.pixelBlock)==null?{data:new Float32Array(r*u*2),mask:new Uint8Array(r*u),width:r,height:u}:C(m.serviceRasterInfo.dataType,p.pixelBlock)}export{at as G,it as W,wt as d,mt as s};
