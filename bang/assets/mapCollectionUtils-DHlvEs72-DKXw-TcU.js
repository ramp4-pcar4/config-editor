import{g as C}from"./asyncUtils-Cu__bxqs-ecCTUaGV.js";import{a7 as _,bc as v,nu as b,i as y,V as w,bh as p,nv as I}from"./index-BeTPrQ6f.js";function M(i,o,e){var s;const r=((s=e==null?void 0:e.createCollection)==null?void 0:s.call(e))??new _,a=e!=null&&e.recycleItems?new R:null,l=(t,n=0)=>{if(!(t!=null&&t.length))return;const d=r.splice(n,t.length);a?a.processRemoved(t):d.forEach(m)},u=(t,n=0)=>{if(!(t!=null&&t.length))return;const d=[];for(const c of t){const f=a==null?void 0:a.use(c);if(f)d.push(f);else{const h=o(c);a==null||a.register(c,h),d.push(h)}}r.addMany(d,n)},g=v(i,"after-splice",({added:t,start:n,removed:d})=>{l(d,n),u(t,n)},{sync:!0,onListenerRemove:t=>l(t.items),onListenerAdd:t=>u(t.items)});return r.addHandles(g),r}class R{constructor(){this._originalToMapped=new Map,this._removedItemCandidates=new Set,this._garbageCollectionQueued=!1}processRemoved(o){var r;if(!(o!=null&&o.length))return;const{_removedItemCandidates:e}=this;for(const a of o)(r=this._getItem(a))!=null&&r.markRemoved()&&(e.add(a),this._queueGarbageCollection())}use(o){const e=this._getItem(o);return e&&(e.removed=!1),e==null?void 0:e.item}register(o,e){this._originalToMapped.set(o,new H(e))}_getItem(o){return this._originalToMapped.get(o)}_queueGarbageCollection(){this._garbageCollectionQueued||(this._garbageCollectionQueued=!0,queueMicrotask(()=>this._garbageCollectCandidates()))}_garbageCollectCandidates(){this._garbageCollectionQueued=!1;const{_removedItemCandidates:o}=this,e=Array.from(o);o.clear(),e.forEach(r=>this._garbageCollectIfRemoved(r))}_garbageCollectIfRemoved(o){const{_originalToMapped:e}=this,r=this._getItem(o);r!=null&&r.removed&&(m(r.item),e.delete(o))}}class H{constructor(o){this.item=o,this.removed=!1}markRemoved(){return this.removed=!0,!0}}function m(i){typeof i=="object"&&i&&("destroy"in i&&typeof i.destroy=="function"?i.destroy():b(i))}function k(i,o,e){const r=new _,a=M(i,s=>C(async t=>{const n=await o(s,t);if(y(t))throw m(n),w();return n}),e),l=()=>null,u=async s=>{const t=await s.promise,n=a.indexOf(s);n<0||r.splice(n,1,t)};r.addMany(a.items.map(l));for(const s of a)p(u(s));const g=a.on("after-splice",({added:s,start:t,deleteCount:n})=>{const d=r.splice(t,n);for(const c of d)m(c);if(s!=null&&s.length){r.addMany(s.map(l),t);for(const c of s)p(u(c))}});return r.addHandles([I(a),g]),r}export{k as T,M as _};
