import{P as le,lL as ve,u as xe,l as $e,m as x}from"./index-BeTPrQ6f.js";import"./BufferObject-RHe5uojV-C-IINTcZ.js";import"./FramebufferObject-CjoCv_5U-BOVEwWIe.js";import{X as Ie}from"./ProgramTemplate-BqCbl7jA-D5ymqDWS.js";import{$ as _e,w as Ne}from"./Texture-DLw7oaIg-fTsxdRzn.js";import{T as Te}from"./ShaderBuilder-ufvKEDd5-DMnPqr6U.js";let ar=class{constructor(){this.drawPhase=89}startup(){}shutdown(e){}};function Me(e){return e.split(" ").map((t,r)=>r>0?t.charAt(0).toUpperCase()+t.slice(1):t).join("")}function ke(e,t){const r=[];for(r.push(t);r.length;){const n=r.pop();if(typeof n=="object"&&!e.has(n.uid)){e.add(n.uid);for(const i of n.children)r.push(i)}}}const yt=class yt{constructor(){this.uid=yt.NodeCount++,this._debugName=null,this._isMutable=!1,this.isImplicit=!1}get isMutable(){return this._isMutable}setMutable(){return this._isMutable=!0,this}setDebugName(t){return t=Me(t),this._debugName=t,this.isImplicit&&this.children[0]instanceof yt&&this.children[0].setDebugName(t),this}get debugInfo(){return{name:this._debugName??""}}cloneInto(t){t._debugName=this._debugName,t._isMutable=this._isMutable,t.isImplicit=this.isImplicit,t.uid=this.uid}};yt.NodeCount=0;let K=yt;function o(e){return typeof e=="object"?e.clone():e}let w=class extends K{constructor(){super(...arguments),this.shaderType="primitive-node"}},Se=class fe extends K{constructor(t){super(),this.child=t,this.shaderType="scope-node"}get children(){return[this.child]}clone(){const t=new fe(o(this.child));return this.cloneInto(t),t}};class Jt extends K{constructor(t,r,n){super(),this.property=t,this.target=r,this.returnType=n,this.shaderType="property-access-node"}get children(){const t=[this.target];return typeof this.property!="string"&&t.push(this.property),t}clone(){const t=new Jt(this.property,o(this.target),this.returnType);return this.cloneInto(t),t}}let Ce=class ye extends K{constructor(t,r,n,i){super(),this.x=t,this.y=r,this.target=n,this.returnType=i,this.shaderType="property-access-2d-node"}get children(){return[this.target,this.x,this.y]}clone(){const t=new ye(this.x,this.y,o(this.target),this.returnType);return this.cloneInto(t),t}};class Qt extends K{constructor(t,r,n){super(),this.condition=t,this.ifTrue=r,this.ifFalse=n,this.shaderType="condition-node"}get children(){return[this.condition,this.ifTrue,this.ifFalse]}clone(){const t=o(this.ifTrue),r=this.ifFalse?o(this.ifFalse):null,n=new Qt(this.condition,t,r);return this.cloneInto(n),n}}let Pe=class me extends K{constructor(t,r,n,i){super(),this.captureList=t,this.returnType=r,this.generator=i,this.shaderType="block-node",n&&(this.subgraph=new Se(n))}get children(){return Object.keys(this.captureList).map(t=>this.captureList[t]).concat(this.subgraph??[])}clone(){const t={};for(const n in this.captureList)t[n]=o(this.captureList[n]);const r=new me(t,this.returnType,this.subgraph?o(this.subgraph.child):this.subgraph,this.generator);return this.cloneInto(r),r}},z=class ge extends K{constructor(t,r,n,i,s,c=!1){super(),this.token=t,this._children=r,this.isInfix=n,this.isPropertyAccess=i,this.returnType=s,this.isTernary=c,this.shaderType="function-node"}get children(){return this._children}clone(){const t=new ge(this.token,this._children.map(o),this.isInfix,this.isPropertyAccess,this.returnType,this.isTernary);return this.cloneInto(t),t}};var ft,Tt,Mt,kt,B,St,Ct,Pt,Ft,Et,Dt,Kt,Ut,jt;function Fe(e){switch(e.type){case"bool":case"bvec2":case"bvec3":case"bvec4":return N;case"float":case"vec2":case"vec3":case"vec4":return y;case"int":case"ivec2":case"ivec3":case"ivec4":return d;case"uint":case"uvec2":case"uvec3":case"uvec4":return b;default:throw new Error("Unable to handle type")}}function Ee(e){const t=[["float","vec2","vec3","vec4"],["int","ivec2","ivec3","ivec4"],["uint","uvec2","uvec3","uvec4"],["bool","bvec2","bvec3","bvec4"]];for(const r of t)if(r.includes(e))return r.map(n=>Ue[n]);throw new Error("Unable to find type family")}function be(e){return new Proxy(e,{get(t,r){if(r==="constructor")return new Proxy(t.constructor,{construct:(n,i,s)=>be(new n(...i))});if(r in t)return t[r];if(typeof r=="string"){const n=Ee(e.type);return m(e,r,n[r.length-1])}}})}function T(e){return new Proxy(e,{construct:(t,r,n)=>be(new t(...r))})}function De(e){return new Proxy(e,{get(t,r){if(r in t)return t[r];if(typeof r=="string"){const n=parseInt(r,10);if(!isNaN(n))return m(e,`[${n}]`,e.elementType.constructor)}}})}function Ke(e){return new Proxy(e,{construct:(t,r,n)=>De(new t(...r))})}class U extends Error{}var L;let Ot=(L=class extends w{constructor(t,r){super(),this.elementType=t,this.size=r,this.children=[],this.type="array"}clone(){const t=new ft(this.elementType,this.size);return super.cloneInto(t),t}get(t,r){const n=new d(t),i=r!=null?new d(r):null;return i!=null?_t(this,n,i,Fe(this.elementType.constructor)):m(this,n,this.elementType.constructor)}last(){return this.get(this.size-1)}first(){return this.get(0)}findIndex(t,r,n){return Ve(this,t,r,n)}glslFindIndex(t,r,n){return Ae(this,t,r,n)}static ofType(t,r){const n={construct:(i,s)=>new ft(new t,r)};return new Proxy(ft,n)}},ft=L,L.type="array",L);Ot=ft=x([Ke],Ot);const mt=class mt extends w{constructor(t,r,n,i=!1){super(),this.elementType=t,this.xSize=r,this.ySize=n,this.isRowMajor=i,this.children=[],this.type="array-2d"}clone(){const t=new mt(this.elementType,this.xSize,this.ySize,this.isRowMajor);return super.cloneInto(t),t}get size(){return this.xSize*this.ySize}get(t,r){return this.isRowMajor?this._getRowMajor(t,r):this._getColumnMajor(t,r)}_getColumnMajor(t,r){const n=new d(t);return m(this,new d(r).add(n.multiply(this.xSize)),this.elementType.constructor)}_getRowMajor(t,r){const n=new d(t),i=new d(r);return m(this,n.add(i.multiply(this.ySize)),this.elementType.constructor)}static ofType(t,r,n,i=!1){return new Proxy(Ot,{construct:(s,c)=>new mt(new t,r,n,i)})}};mt.type="array-2d";let oe=mt;const xt=class xt extends w{constructor(){super(...arguments),this.type="sampler2D",this.children=[]}clone(){const t=new xt;return t.children=this.children.map(o),super.cloneInto(t),t}};xt.type="sampler2D";let ae=xt;var C;let y=(C=class extends w{constructor(t){super(),this.type="float",this.children=[t]}clone(){const t=new C(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return _(this,typeof t=="number"?h(t,C):t)}divide(t){return k(this,typeof t=="number"?h(t,C):t)}add(t){return M(this,typeof t=="number"?h(t,C):t)}subtract(t){return S(this,typeof t=="number"?h(t,C):t)}},C.type="float",C);var q;let gt=(q=class extends w{constructor(t,r){super(),this.type="vec2",this.children=[t,r].filter(n=>n!=null)}clone(){const t=new Tt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){throw new U}get 3(){throw new U}multiply(t){return _(this,typeof t=="number"?h(t,y):t)}divide(t){return k(this,typeof t=="number"?h(t,y):t)}add(t){return M(this,typeof t=="number"?h(t,y):t)}subtract(t){return S(this,typeof t=="number"?h(t,y):t)}},Tt=q,q.type="vec2",q);gt=Tt=x([T],gt);var G;let vt=(G=class extends w{constructor(t,r,n){super(),this.type="vec3",this.children=[t,r,n].filter(i=>i!=null)}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){throw new U}clone(){const t=new Mt(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}multiply(t){return _(this,typeof t=="number"?h(t,y):t)}divide(t){return k(this,typeof t=="number"?h(t,y):t)}add(t){return M(this,typeof t=="number"?h(t,y):t)}subtract(t){return S(this,typeof t=="number"?h(t,y):t)}},Mt=G,G.type="vec3",G);vt=Mt=x([T],vt);var R;let nt=(R=class extends w{constructor(t,r,n,i){super(),this.type="vec4",this.children=[t,r,n,i].filter(s=>s!=null)}clone(){const t=new kt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",y)}get 1(){return m(this,"[1]",y)}get 2(){return m(this,"[2]",y)}get 3(){return m(this,"[3]",y)}multiply(t){return _(this,typeof t=="number"?h(t,y):t)}divide(t){return k(this,typeof t=="number"?h(t,y):t)}add(t){return M(this,typeof t=="number"?h(t,y):t)}subtract(t){return S(this,typeof t=="number"?h(t,y):t)}},kt=R,R.type="vec4",R);nt=kt=x([T],nt);var X;let b=(X=class extends w{constructor(t){super(),this.type="uint",this.children=[t]}clone(){const t=new B(o(this.children[0]));return super.cloneInto(t),t}multiply(t){return _(this,h(t,B))}add(t){return M(this,h(t,B))}subtract(t){return S(this,h(t,B))}divide(t){return k(this,h(t,B))}},B=X,X.type="uint",X);b=B=x([T],b);var H;let Vt=(H=class extends w{constructor(t,r){super(),this.type="uvec2",this.children=[t,r].filter(n=>n!=null)}clone(){const t=new St(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){throw new U}get 3(){throw new U}multiply(t){return _(this,typeof t=="number"?h(t,b):t)}divide(t){return k(this,typeof t=="number"?h(t,b):t)}add(t){return M(this,typeof t=="number"?h(t,b):t)}subtract(t){return S(this,typeof t=="number"?h(t,b):t)}},St=H,H.type="uvec2",H);Vt=St=x([T],Vt);var Y;let At=(Y=class extends w{constructor(t,r,n){super(),this.type="uvec3",this.children=[t,r,n].filter(i=>i!=null)}clone(){const t=new Ct(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){throw new U}multiply(t){return _(this,typeof t=="number"?h(t,b):t)}divide(t){return k(this,typeof t=="number"?h(t,b):t)}add(t){return M(this,typeof t=="number"?h(t,b):t)}subtract(t){return S(this,typeof t=="number"?h(t,b):t)}},Ct=Y,Y.type="uvec3",Y);At=Ct=x([T],At);var W;let Bt=(W=class extends w{constructor(t,r,n,i){super(),this.type="uvec4",this.children=[t,r,n,i].filter(s=>s!=null)}clone(){const t=new Pt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",b)}get 1(){return m(this,"[1]",b)}get 2(){return m(this,"[2]",b)}get 3(){return m(this,"[3]",b)}multiply(t){return _(this,typeof t=="number"?h(t,b):t)}divide(t){return k(this,typeof t=="number"?h(t,b):t)}add(t){return M(this,typeof t=="number"?h(t,b):t)}subtract(t){return S(this,typeof t=="number"?h(t,b):t)}},Pt=W,W.type="uvec4",W);Bt=Pt=x([T],Bt);const $t=class $t extends w{constructor(t){super(),this.type="bool",this.children=[t]}and(t){return Re(this,t)}or(t){return ze(this,t)}xor(t){return qe(this,t)}clone(){const t=new $t(o(this.children[0]));return super.cloneInto(t),t}};$t.type="bool";let N=$t;var J;let zt=(J=class extends w{constructor(t,r){super(),this.type="bvec2",this.children=[t,r].filter(n=>n!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Ft(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}},Ft=J,J.type="bvec2",J);zt=Ft=x([T],zt);var Q;let Lt=(Q=class extends w{constructor(t,r,n){super(),this.type="bvec3",this.children=[t,r,n].filter(i=>i!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Et(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}},Et=Q,Q.type="bvec3",Q);function h(e,t){return typeof e=="number"?new t(e):e}Lt=Et=x([T],Lt);var Z;let qt=(Z=class extends w{constructor(t,r,n,i){super(),this.type="bvec4",this.children=[t,r,n,i].filter(s=>s!=null)}all(){return te(this)}any(){return ee(this)}clone(){const t=new Dt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}},Dt=Z,Z.type="bvec4",Z);qt=Dt=x([T],qt);const A=class A extends w{constructor(t){super(),this.type="int",this.children=[t]}multiply(t){return _(this,h(t,A))}add(t){return M(this,h(t,A))}subtract(t){return S(this,h(t,A))}divide(t){return k(this,h(t,A))}clone(){const t=new A(o(this.children[0]));return super.cloneInto(t),t}};A.type="int";let d=A;var tt;let Gt=(tt=class extends w{constructor(t,r){super(),this.type="ivec2",this.children=[t,r].filter(n=>n!=null)}clone(){const t=new Kt(o(this.children[0]),o(this.children[1]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){throw new U}get 3(){throw new U}multiply(t){return _(this,typeof t=="number"?h(t,d):t)}divide(t){return k(this,typeof t=="number"?h(t,d):t)}add(t){return M(this,typeof t=="number"?h(t,d):t)}subtract(t){return S(this,typeof t=="number"?h(t,d):t)}},Kt=tt,tt.type="ivec2",tt);Gt=Kt=x([T],Gt);var et;let Rt=(et=class extends w{constructor(t,r,n){super(),this.type="ivec3",this.children=[t,r,n].filter(i=>i!=null)}clone(){const t=new Ut(o(this.children[0]),o(this.children[1]),o(this.children[2]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){return m(this,"[2]",d)}get 3(){throw new U}multiply(t){return _(this,typeof t=="number"?h(t,d):t)}divide(t){return k(this,typeof t=="number"?h(t,d):t)}add(t){return M(this,typeof t=="number"?h(t,d):t)}subtract(t){return S(this,typeof t=="number"?h(t,d):t)}},Ut=et,et.type="ivec3",et);Rt=Ut=x([T],Rt);var rt;let Xt=(rt=class extends w{constructor(t,r,n,i){super(),this.type="ivec4",this.children=[t,r,n,i].filter(s=>s!=null)}clone(){const t=new jt(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get 0(){return m(this,"[0]",d)}get 1(){return m(this,"[1]",d)}get 2(){return m(this,"[2]",d)}get 3(){return m(this,"[3]",d)}multiply(t){return _(this,typeof t=="number"?h(t,d):t)}divide(t){return k(this,typeof t=="number"?h(t,d):t)}add(t){return M(this,typeof t=="number"?h(t,d):t)}subtract(t){return S(this,typeof t=="number"?h(t,d):t)}},jt=rt,rt.type="ivec4",rt);Xt=jt=x([T],Xt);const It=class It extends w{constructor(t,r,n,i){super(),this.type="mat2",this.children=[t,r,n,i]}clone(){const t=new It(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]));return super.cloneInto(t),t}get(t,r){return _t(this,new d(t),new d(r),y)}multiply(t){return _(this,t)}};It.type="mat2";let ue=It;const it=class it extends w{static identity(){return new it(1,0,0,0,1,0,0,0,1)}static fromRotation(t){const r=Ye(t),n=He(t);return new it(n,r,0,Oe(r),n,0,0,0,1)}constructor(t,r,n,i,s,c,u,a,p){super(),this.type="mat3",this.children=[t,r,n,i,s,c,u,a,p]}add(t){return M(this,t)}multiply(t){return _(this,t)}get(t,r){return _t(this,new d(t),new d(r),y)}clone(){const t=new it(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]));return super.cloneInto(t),t}};it.type="mat3";let Ht=it;const st=class st extends w{static identity(){return new st(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)}constructor(t,r,n,i,s,c,u,a,p,l,f,I,O,F,E,D){super(),this.type="mat4",this.children=[t,r,n,i,s,c,u,a,p,l,f,I,O,F,E,D]}static fromColumns(t,r,n,i){return new st(t.x,t.y,t.z,t.w,r.x,r.y,r.z,r.w,n.x,n.y,n.z,n.w,i.x,i.y,i.z,i.w)}multiply(t){return _(this,t)}get(t,r){return _t(this,new d(t),new d(r),y)}clone(){const t=new st(o(this.children[0]),o(this.children[1]),o(this.children[2]),o(this.children[3]),o(this.children[4]),o(this.children[5]),o(this.children[6]),o(this.children[7]),o(this.children[8]),o(this.children[9]),o(this.children[10]),o(this.children[11]),o(this.children[12]),o(this.children[13]),o(this.children[14]),o(this.children[15]));return super.cloneInto(t),t}};st.type="mat4";let ce=st;const Ue={float:y,vec2:gt,vec3:vt,vec4:nt,int:d,ivec2:Gt,ivec3:Rt,ivec4:Xt,uint:b,uvec2:Vt,uvec3:At,uvec4:Bt,bool:N,bvec2:zt,bvec3:Lt,bvec4:qt},ur=(...e)=>new d(...e),je=(...e)=>new y(...e),cr=(...e)=>new gt(...e),hr=(...e)=>new vt(...e),dr=(...e)=>new nt(...e),pr=(...e)=>new Ht(...e);function m(e,t,r){const n=new r(new Jt(t,e,r));return n.isImplicit=!0,n}function _t(e,t,r,n){const i=new n(new Ce(t,r,e,n));return i.isImplicit=!0,i}function v(e,t,r,n=null){if(n){const s=new n,c=new n(new z(e,[t,r],!0,!1,s));return c.isImplicit=!0,c}if(t.type==="float"||t.type==="int"){const s=new r.constructor(new z(e,[t,r],!0,!1,r.constructor));return s.isImplicit=!0,s}if((t.type==="mat2"||t.type==="mat3"||t.type==="mat4")&&r.type!=="float"){const s=new r.constructor(new z(e,[t,r],!0,!1,r.constructor));return s.isImplicit=!0,s}const i=new t.constructor(new z(e,[t,r],!0,!1,t.constructor));return i.isImplicit=!0,i}function g(e,t,r=t.constructor){const n=new r(new z(e,[t],!1,!1,r));return n.isImplicit=!0,n}function j(e,t,r,n=t.constructor){const i=new n(new z(e,[t,r],!1,!1,n));return i.isImplicit=!0,i}function Nt(e,t,r,n,i=t.constructor){const s=new i(new z(e,[t,r,n],!1,!1,i));return s.isImplicit=!0,s}function Oe(e){return _(e,je(-1))}function Zt(e,t,r,n){return new t(new Pe(e,t,r,n))}function Ve(e,t,r=0,n=e.size){const i=new d(r).setMutable().setDebugName("FindIndexIterator"),s=t(e.get(i)).setDebugName("FindIndexPredicate");return Zt({iter:i},d,s,({out:c,iter:u,subgraph:a})=>`
${c} = -1;

for (; ${u} < ${n}; ${u}++) {

${a.body}

  if (${a.varName}) {
    ${c} = ${u};
    break;
  }

}
`).setDebugName("FindIndexBlock")}function Ae(e,t,r=0,n=e.size){return Zt({array:e},d,null,({out:i,array:s})=>`
${i} = -1;
for (int i = ${r}; i < ${n}; i++) {
  bool condition;
  ${t({array:s,i:"i",out:"condition"})}
  if (condition) {
    ${i} = i;
    break;
  }
}
`).setDebugName("GlslFindIndexBlock")}function Be(e,t,r){const n=typeof t=="function"?t():t,i=typeof r=="function"?r():r,s=new n.constructor(new Qt(e,n,i));return s.isImplicit=!0,s}function lr(...e){const t=e.map(([u,a])=>typeof a=="function"?[u,a()]:[u,a]),r=t[0][1].constructor,n=t.findIndex(u=>u[0]===!0);if(n===-1)throw new Error("A cond must have a fallthrough case with `true`/; ");const i=t.slice(0,n),s=t[n][1],c=new r(i.reduceRight((u,a)=>Be(a[0],a[1],u),s));return c.isImplicit=!0,c}function _(e,t){return v("*",e,t)}function k(e,t){return v("/",e,t)}function M(e,t){return v("+",e,t)}function S(e,t){return v("-",e,t)}function fr(e,t){return v("%",e,t)}function yr(e,t){return v("<<",e,t)}function mr(e,t){return v(">>",e,t)}function gr(e,t){return v("&",e,t)}function br(e,t){return v("|",e,t)}function wr(e,t){return v("^",e,t)}function vr(e){return g("~",e)}function xr(e,t){return v("==",e,t,N)}function $r(e,t){return v("!=",e,t,N)}function Ir(e,t){return v("<",e,t,N)}function _r(e,t){return v("<=",e,t,N)}function Nr(e,t){return v(">",e,t,N)}function Tr(e,t){return v(">=",e,t,N)}function ze(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>Le(t,r),e[0])}function Le(e,t){return v("||",e,t,N)}function qe(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>Ge(t,r),e[0])}function Ge(e,t){return v("^^",e,t,N)}function Re(...e){return e.length<=1?e[0]:e.slice(1).reduce((t,r)=>Xe(t,r),e[0])}function Xe(e,t){return v("&&",e,t,N)}function Mr(e){return g("abs",e)}function kr(e){return g("acos",e)}function Sr(e){return g("acosh",e)}function te(e){return g("all",e,N)}function ee(e){return g("any",e,N)}function Cr(e){return g("asin",e)}function Pr(e){return g("asinh",e)}function Fr(e,t){return t==null?g("atan",e):j("atan",e,t,e.constructor)}function Er(e){return g("atanh",e)}function Dr(e){return g("ceil",e)}function Kr(e,t,r){return Nt("clamp",e,t,r,e.constructor)}function He(e){return g("cos",e)}function Ur(e){return g("cosh",e)}function jr(e,t){return j("distance",e,t,y)}function Or(e,t){return j("dot",e,t,y)}function Vr(e){return g("exp",e)}function Ar(e){return g("floor",e)}function Br(e){return g("fract",e)}function zr(e){return g("length",e,y)}function Lr(e){return g("log",e)}function qr(e){return g("log2",e)}function Gr(e,t){return j("max",e,t)}function Rr(e,t){return j("min",e,t)}function Xr(e,t,r){return Nt("mix",e,t,r)}function Hr(e,t){return j("mod",e,t)}function Yr(e){return g("normalize",e)}function Wr(e){return e.type==="bool"?g("!",e):g("not",e)}function Jr(e,t){return j("pow",e,t)}function Qr(e){return g("round",e)}function Zr(e){return g("sign",e)}function Ye(e){return g("sin",e)}function tn(e){return g("sinh",e)}function en(e,t,r){return Nt("smoothstep",e,t,r)}function rn(e){return g("sqrt",e)}function nn(e,t){return j("step",e,t,t.constructor)}function sn(e){return g("tan",e)}function on(e){return g("tanh",e)}function an(e,t,r){return Nt("texelFetch",e,t,r,nt)}function un(e,t){return j("texture",e,t,nt)}function cn(e,t){const{initialValue:r,xRange:n,yRange:i,callback:s}=t,[c,u]=n,[a,p]=i,l=new d(0).setMutable().setDebugName("iterX"),f=new d(0).setMutable().setDebugName("iterY"),I=r.setMutable().setDebugName("accumulator"),O=s(I,e.get(l,f),l,f).setDebugName("callback");return Zt({iterX:l,iterY:f,accumulator:I},r.constructor,O,({out:F,iterX:E,iterY:D,accumulator:at,subgraph:ut})=>`
for (${D} = ${a}; ${D} < ${p}; ${D}++) {
  for (${E} = ${c}; ${E} < ${u}; ${E}++) {

  ${ut.body}

  ${at} = ${ut.varName};
  }
}
${F} = ${at};
`).setDebugName("reduce2DBody")}const dt=5;function $(e,t,r){const n=t.split(`
`);for(const i of n)if(i.trim().length){{let s="";r!=null&&(s+=`/*id:${r??"000"}*/   `),e.body+=s.padEnd(14)}e.body+=" ".repeat(e.indent)+i+`
`}}let he=class{write(e){for(const t of e.rootOutputNodes())e.shouldPruneOutputNode(t)||(t.variableName=this._write(e,t.node));return e}_createVarName(e,t){let r="";return typeof t!="boolean"&&typeof t!="number"&&t.debugInfo.name&&(r=`${t.debugInfo.name}_`),`${r}v${e.varCount++}`}_write(e,t,r=!1){if(typeof t=="number"||typeof t=="boolean")return t.toString();let n=e.getEmit(t);if(n)return n;switch(t.shaderType){case"scope-node":n=this._writeScopeNode(e,t);break;case"primitive-node":n=this._writePrimitiveNode(e,t,r);break;case"function-node":n=this._writeFunctionNode(e,t);break;case"property-access-node":n=this._writePropertyAccessNode(e,t);break;case"property-access-2d-node":n=this._writePropertyAccess2DNode(e,t);break;case"text-node":n=t.text;break;case"block-node":n=this._writeBlockNode(e,t);break;case"condition-node":n=this._writeConditionNode(e,t)}return e.setEmit(t,n),n}_writeScopeNode(e,t){const r=new t.child.constructor;r.setDebugName(t.debugInfo.name);const n=this._write(e,r,!0);return $(e,`{ /*ScopeStart: ${t.uid} ${t.debugInfo.name}*/`),e.indent+=2,$(e,`${n} = ${this._write(e,t.child)};`),e.indent-=2,$(e,`} /*ScopeEnd: ${t.uid} ${t.debugInfo.name}*/`),n}_writeConditionNode(e,t){const r=new t.ifTrue.constructor,n=this._write(e,r,!0);$(e,`if (${this._write(e,t.condition)}) {`),e.indent+=2;const i=e.createSubgraphContext(),s=this._write(i,t.ifTrue);if(e.body+=i.body,s&&$(e,`${n} = ${s};`),e.indent-=2,$(e,"}"),t.ifFalse){$(e,"else {"),e.indent+=2;const c=e.createSubgraphContext(),u=this._write(c,t.ifFalse);e.body+=c.body,u&&$(e,`${n} = ${u};`),e.indent-=2,$(e,"}")}return n}_writeBlockNode(e,t){const{captureList:r,generator:n,returnType:i}=t,s={};for(const p in r){if(!r[p])continue;const l=this._write(e,r[p]);s[p]=l}const c=new i,u=this._write(e,c,!0);if(s.out=u,t.subgraph){const p=e.createSubgraphContext(),l=this._write(p,t.subgraph.child),f=p.body;s.subgraph={varName:l,body:f}}const a=n(s);return $(e,`{
`),e.indent+=2,$(e,a),e.indent-=2,$(e,`}
`),u}_writePropertyAccessNode(e,t){const r=this._write(e,t.target);return typeof t.property=="string"&&t.property.includes("[")?`${r}${t.property}`:typeof t.property!="string"?`${r}[${this._write(e,t.property)}]`:`${r}.${t.property}`}_writePropertyAccess2DNode(e,t){return`${this._write(e,t.target)}[${this._write(e,t.x)}][${this._write(e,t.y)}]`}_writeFunctionNode(e,t){const r=t.returnType.type;if(t.isInfix){const[s,c]=t.children.map(a=>this._write(e,a)),u=this._createVarName(e,t);return $(e,`${r.padEnd(dt)} ${u} = ${s} ${t.token} ${c};`,t.uid),u}const n=t.children.map(s=>this._write(e,s)).join(", "),i=this._createVarName(e,t);return $(e,`${r.padEnd(dt)} ${i} = ${t.token}(${n});`,t.uid),i}_writePrimitiveNode(e,t,r=!1){var a;const n=e.getInput(t);if(n)return n.isUsed=!0,n.variableName;const i=t.children.length===1&&((a=t.children[0])==null?void 0:a.type)===t.type;if(!t.isMutable&&(t.isImplicit||i))return this._write(e,t.children[0]);const s=this._createVarName(e,t);if(r)return $(e,`${t.type.padEnd(dt)} ${s};`,t.uid),s;const c=!t.debugInfo.name&&!t.isMutable;if(c&&t.type==="float"&&typeof t.children[0]=="number")return Number.isInteger(t.children[0])?t.children[0].toFixed(1):t.children[0].toString();if(c&&t.type==="int"&&typeof t.children[0]=="number"&&Number.isInteger(t.children[0]))return t.children[0].toString();const u=t.children.map(p=>this._write(e,p)).join(", ");return t.type==="array"?($(e,`${t.type.padEnd(dt)} ${s} = [${u}];`,t.uid),s):c?`${t.type}(${u})`:($(e,`${t.type.padEnd(dt)} ${s} = ${t.type}(${u});`,t.uid),s)}};class V{constructor(t,r,n,i=[]){this.variableName=t,this.variableInputType=r,this.node=n,this.qualifiers=i,this.type="shader-input",this.isUsed=!1}clone(){return new V(this.variableName,this.variableInputType,o(this.node),[...this.qualifiers])}}let P=class we{constructor(t,r,n,i=[]){this.outVariableName=t,this.outVariableType=r,this.node=n,this.qualifiers=i,this.type="shader-output"}clone(){const t=new we(this.outVariableName,this.outVariableType,o(this.node),[...this.qualifiers]);return t.variableName=this.variableName,t}},de=class wt{static createVertex(t,r,n,i,s,c){const u=[];for(const p in t){const l=t[p],f=n.get(p);f?u.push(new V(f,"builtin",l)):u.push(new V("a_"+p,"in",l))}for(const p of i){const l=p.uniformHydrated;u.push(new V(p.uniformName,"uniform",l))}const a=[];for(const p in r){const l=r[p];if(p==="glPosition")a.push(new P("gl_Position","builtin",l));else if(p==="glPointSize")a.push(new P("gl_PointSize","builtin",l));else{const f=We(l),I=[];f&&I.push(f),a.push(new P("v_"+p,"out",l,I))}}return new wt(u,a,s,c)}static createFragment(t,r,n,i,s,c){const u=[],a=Array.from(s.rootOutputNodes());for(const l in t){const f=t[l],I=n.get(l);if(I){u.push(new V(I,"builtin",f));continue}const O=a.find(F=>F.node===f);O&&u.push(new V(O.outVariableName,"in",f))}for(const l of i){const f=l.uniformHydrated;u.push(new V(l.uniformName,"uniform",f))}const p=[];for(const l in r){const f=r[l],I=n.get(l);switch(l){case"discard":p.push(new P(null,"discard",f));break;case"fragData0":p.push(new P("fragData0","fragData0",f));break;case"fragData1":p.push(new P("fragData1","fragData1",f));break;case"fragData2":p.push(new P("fragData2","fragData2",f));break;case"fragData3":p.push(new P("fragData3","fragData3",f));break;default:I?p.push(new P(I,"builtin",f)):p.push(new P(l,"out",f))}}return new wt(u,p,c)}constructor(t,r,n,i){this.type="shader-graph-context",this.indent=0,this.body="",this.varCount=0,this._inputShaderTypesByNodeUid=new Map,this._nodeEmitMap=new Map;for(const s of t)this._inputShaderTypesByNodeUid.set(s.node.uid,s);this._outputShaderTypes=r,this._transformFeedbackBindings=n,this._transformFeedbackNames=new Set(n.map(s=>"v_"+s.propertyKey)),this._usedInFragmentShader=i}shouldPruneOutputNode(t){return!!this._usedInFragmentShader&&t.outVariableType!=="builtin"&&!this._transformFeedbackNames.has(t.outVariableName)&&!this._usedInFragmentShader.has(t.node.uid)}setEmit(t,r){this._nodeEmitMap.set(t.uid,r)}getEmit(t){return this._nodeEmitMap.get(t.uid)}inputs(){return this._inputShaderTypesByNodeUid.values()}getInput(t){return this._inputShaderTypesByNodeUid.get(t.uid)}*rootOutputNodes(){for(const t of this._outputShaderTypes)yield t}*nodes(){const t=[];for(const r of this._outputShaderTypes.values())t.push(r.node);for(;t.length;){const r=t.pop();typeof r!="number"&&typeof r!="boolean"&&t.push(...r.children.filter(Boolean)),yield r}}*nodesOfTypeOrFunction(){for(const t of this.nodes())typeof t!="number"&&typeof t!="boolean"&&(yield t)}createSubgraphContext(){const t=this.clone();return t.body="",t.indent=this.indent+2,t._nodeEmitMap=new Map(this._nodeEmitMap),t}clone(){const t=new wt([],this._outputShaderTypes,this._transformFeedbackBindings,this._usedInFragmentShader);return t._inputShaderTypesByNodeUid=this._inputShaderTypesByNodeUid,t.indent=this.indent,t.body=this.body,t.varCount=this.varCount,t._nodeEmitMap=this._nodeEmitMap,t}insertVertexShader(t){t.vertex.code.add(""),this._insertInputs(t,"vertex"),t.vertex.code.add(""),t.vertex.code.add("// OUTPUTS: "),t.vertex.code.add("// --------------------------------------------------------- ");for(const r of this.rootOutputNodes()){const n=r.outVariableType==="builtin";if(!this.shouldPruneOutputNode(r))if(n)t.vertex.code.add(`// ${r.outVariableType.padEnd(7)} ${r.node.type.padEnd(9)} ${r.outVariableName};`);else{const i=[...r.qualifiers,r.outVariableType].join(" ");t.vertex.code.add(`${i.padEnd(10)} ${r.node.type.padEnd(9)} ${r.outVariableName};`)}}t.vertex.code.add(""),t.vertex.code.add("void main() {"),t.vertex.code.add("  "+this.body.split(`
`).join(`
  `));for(const r of this.rootOutputNodes())this.shouldPruneOutputNode(r)||t.vertex.code.add(`  ${r.outVariableName} = ${r.variableName};`);t.vertex.code.add("}")}insertFragmentShader(t){this._insertInputs(t,"fragment"),t.fragment.code.add(""),t.fragment.code.add("// OUTPUTS: "),t.fragment.code.add("// --------------------------------------------------------- ");let r=0;for(const n of this.rootOutputNodes())n.outVariableType==="builtin"?t.fragment.code.add(`// ${n.outVariableType.padEnd(7)} ${n.node.type.padEnd(9)} ${n.outVariableName};`):t.outputs.add(n.outVariableName,n.node.type,r++);t.fragment.code.add(""),t.fragment.code.add("void main() {"),t.fragment.code.add("  "+this.body.split(`
`).join(`
  `));for(const n of this.rootOutputNodes())n.outVariableType==="discard"?(t.fragment.code.add("  // TODO: Should ensure codegen for discard appears first in fragment shader"),t.fragment.code.add(`  if (${n.variableName}) {`),t.fragment.code.add("    discard;"),t.fragment.code.add("  }"),t.fragment.code.add("  ")):t.fragment.code.add(`  ${n.outVariableName} = ${n.variableName};`);t.fragment.code.add("}")}_insertInputs(t,r){t[r].code.add("// INPUTS: "),t[r].code.add("// --------------------------------------------------------- ");for(const n of this.inputs())if(n.isUsed&&n.variableInputType!=="builtin")if(n.node.type==="array")t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}];`);else if(n.node.type==="array-2d")t[r].code.add(`${n.variableInputType.padEnd(10)} ${n.node.elementType.type.padEnd(9)} ${n.variableName}[${n.node.size}]; // Emulated 2D Array. Not supported by ES3.0`);else{const i=[...n.qualifiers,n.variableInputType].join(" ");t[r].code.add(` ${i.padEnd(10)} ${n.node.type.padEnd(9)} ${n.variableName};`)}}};function We(e){switch(e.type){case"float":case"vec2":case"vec3":case"vec4":return null;case"int":case"ivec2":case"ivec3":case"ivec4":case"uint":case"uvec2":case"uvec3":case"uvec4":case"bool":case"bvec2":case"bvec3":case"bvec4":return"flat";case"mat2":case"mat3":case"mat4":case"array":case"sampler2D":case"array-2d":throw new Error(`InternalError: ${e.type} is not a valid output type`)}}function Je(e,t,r){const n=new _e(t.width,t.height);return n.dataType=t.dataType,t.depth&&(n.depth=t.depth),t.flipped&&(n.flipped=t.flipped),t.hasMipmap&&(n.hasMipmap=t.hasMipmap),n.internalFormat=t.internalFormat,t.isImmutable&&(n.isImmutable=t.isImmutable),t.isOpaque&&(n.isOpaque=t.isOpaque),t.maxAnisotropy&&(n.maxAnisotropy=t.maxAnisotropy),n.pixelFormat=t.pixelFormat,t.preMultiplyAlpha&&(n.preMultiplyAlpha=t.preMultiplyAlpha),t.samplingMode&&(n.samplingMode=t.samplingMode),t.target&&(n.target=t.target),n.uniform=t.uniform,t.unpackAlignment&&(n.unpackAlignment=t.unpackAlignment),t.wrapMode&&(n.wrapMode=t.wrapMode),new Ne(e,n,r)}const Qe=()=>le.getLogger("esri.views.2d.engine.webgl.shaderGraph.typed.TypedShaderProgram");function pt(e,t,r){const n=t.length;if(n!==r){const i=new $e("Invalid Uniform",`Invalid length, expected ${r} but got ${n}`,{uniformName:e,values:t});Qe().errorOnce(i)}}let pe=class{constructor(e,t,r,n,i){this.vertexShader=e,this.fragmentShader=t,this._locations=r,this._uniformBindings=n,this._transformFeedbackBindings=i,this._vao=null,this._temporaryTextures=[]}destroy(){this._program=ve(this._program),this.cleanupTemporaryTextures()}setUniforms(e){this._uniforms=e}cleanupTemporaryTextures(){for(const e of this._temporaryTextures)e.dispose();this._temporaryTextures=[]}bind(e){const t=this._uniforms;if(!this._program){const n=[];for(const i of this._transformFeedbackBindings??[]){const{index:s,propertyKey:c}=i;n[s]=`v_${c}`}this._program=new Ie(e,this.vertexShader,this.fragmentShader,this._locations,new Map,n)}const r=this._program;e.useProgram(r);for(const n of this._uniformBindings){const{shaderModulePath:i,uniformName:s,uniformType:c,uniformArrayLength:u}=n,a=xe(i,t);if(a==null){if(c==="sampler2D")continue;throw new Error(`Failed to find uniform value for ${i}`)}switch(c==="array"||c==="array-2d"?n.uniformArrayElementType:c){case"sampler2D":{const{unit:p,texture:l}=a;if(r.setUniform1i(s,p),"type"in l)e.bindTexture(l,p);else{const f=Je(e,l.descriptor,l.data);e.bindTexture(f,p)}break}case"int":if(!u){r.setUniform1i(s,a);break}pt(n.uniformName,a,u),r.setUniform1iv(s,a);break;case"float":if(!u){r.setUniform1f(s,a);break}pt(n.uniformName,a,u),r.setUniform1fv(s,a);break;case"vec2":if(!u){r.setUniform2f(s,a[0],a[1]);break}pt(n.uniformName,a,u),r.setUniform2fv(s,a.flat());break;case"vec3":if(!u){r.setUniform3f(s,a[0],a[1],a[2]);break}pt(n.uniformName,a,u),r.setUniform3fv(s,a.flat());break;case"vec4":if(!u){r.setUniform4f(s,a[0],a[1],a[2],a[3]);break}pt(n.uniformName,a,u),r.setUniform4fv(s,a.flat());break;case"mat3":r.setUniformMatrix3fv(s,a);break;case"mat4":r.setUniformMatrix4fv(s,a);break;default:throw new Error(`Unable to set uniform for type ${c}`)}}}};function lt(e){return new e}function ot(e,t,r){const n=e.constructor[t]??[];e.constructor.hasOwnProperty(t)||Object.defineProperty(e.constructor,t,{value:n.slice()}),e.constructor[t].push(r)}function hn(e,t){return(r,n)=>{ot(r,"locations",{typeCtor:t,propertyKey:n,parameterIndex:null,index:e})}}const Ze=e=>(t,r)=>{ot(t,"builtins",{builtin:e,propertyKey:r})},dn=e=>(t,r,n)=>{ot(t,"inputs",{inputCtor:e,propertyKey:r,parameterIndex:n})},pn=e=>(t,r)=>{ot(t,"uniforms",{typeCtor:e,propertyKey:r})},ln=e=>(t,r)=>{ot(t,"options",{typeCtor:e,propertyKey:r})},fn=(e,t)=>{ot(e,"defines",{propertyKey:t})},Yt=(e,t)=>(r,n)=>{r.constructor.builtins.push({builtin:e,propertyKey:n,typeCtor:t})},re=class re{};re.builtins=[];let Wt=re;x([Yt("gl_VertexID",d)],Wt.prototype,"glVertexID",void 0);class yn{}const ne=class ne{};ne.builtins=[];let bt=ne;x([Yt("gl_FragCoord",nt)],bt.prototype,"glFragCoord",void 0),x([Yt("gl_PointCoord",gt)],bt.prototype,"glPointCoord",void 0);let tr=class{};x([Ze("gl_FragDepth")],tr.prototype,"glFragDepth",void 0);let gn=class{constructor(){this.type="uniform-group"}get _uniforms(){return this.constructor.uniforms??[]}},bn=class{constructor(){this.logShader=!1,this.computeAttributes={}}get vertexInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="vertex"&&t.parameterIndex===0);if(!e)throw new Error("Unable to find vertex input parameter");return e}get computeInput(){return this._shaderModuleClass.inputs.findLast(e=>e.propertyKey==="vertex"&&e.parameterIndex===1)}get fragmentInput(){const e=this._shaderModuleClass.inputs.findLast(t=>t.propertyKey==="fragment");if(!e)throw new Error("Unable to find fragment input parameter");return e}get transformFeedbackBindings(){return this.fragmentInput.inputCtor.transformFeedbackBindings??[]}get locations(){var e;return[...this.vertexInput.inputCtor.locations,...((e=this.computeInput)==null?void 0:e.inputCtor.locations)??[]]}get locationsMap(){const e=new Map,t=new Set;for(const r of this.locations)t.has(r.index)?le.getLogger("esri.views.2d.engine.webgl.shaderGraph.GraphShaderModule").warnOnce("mapview-rendering",`Unable to assigned attribute ${r.propertyKey} to ${r.index}. Index already in use`,{locationsMap:e}):(e.set(r.propertyKey,r.index),t.add(r.index));return e}get locationInfo(){if(!this._locationInfo){const e=this.locationsMap,t=Array.from(e.entries()).map(([n,i])=>`${n}.${i}`).join("."),r=this.computeAttributes;this._locationInfo={stringHash:t,locations:e,computeAttributeMap:r}}return this._locationInfo}get renamedLocationsMap(){const e=new Map;for(const t of this.locations)e.set("a_"+t.propertyKey,t.index);return e}get optionPropertyKeys(){if(!this._optionPropertyKeys){const e=new Set;for(const t of this._options)e.add(t.propertyKey);this._optionPropertyKeys=e}return this._optionPropertyKeys}get _shaderModuleClass(){return this.constructor}get _defines(){return this._shaderModuleClass.defines??[]}get _options(){return this._shaderModuleClass.options??[]}get _uniforms(){return this._shaderModuleClass.uniforms??[]}getProgram(e,t,r,n){try{const{vertex:i,fragment:s,uniformBindings:c}=this._generateShaders(e,t,r,n);return new pe(i,s,this.renamedLocationsMap,c,this.transformFeedbackBindings)}catch{return new pe("","",this.renamedLocationsMap,[],this.transformFeedbackBindings)}}getDebugUniformClassInfo(e){const t=this._options.find(n=>n.propertyKey===e);if(t)return{type:"option",className:t.typeCtor};const r=this._uniforms.find(n=>n.propertyKey===e);if(!r)throw new Error(`Unable to find uniform class type for property: ${e}`);return{type:"required",className:r.typeCtor}}getShaderKey(e,t,r,n){const i=Object.keys(e).map(a=>`${a}.${e[a]}`).join("."),s=Object.keys(r).map(a=>`${a}.${r[a]}`).join("."),c=Object.keys(n).map(a=>`${a}.${n[a]}`).join("."),u=Object.keys(t).filter(a=>this.optionPropertyKeys.has(a)&&t[a]).join(".");return`${this.type}.${i}.${s}.${c}.${u}`}_generateShaders(e,t,r,n){const i=[];this._setDefines(r),this._setOptionalUniforms(i,t),this._setRequiredUniforms(i);const s=this._hydrateVertexInput(n),c=this._injectPackPrecisionFactor(s,e),u=this._hydrateComputeInput(),a=u&&this._injectComputePackPrecisionFactor(u,e),p=this.vertex(c,a),l=this._hydrateFragmentInput(p),f=this.fragment(l),I=new Set;for(const ct in f){const ht=f[ct];ke(I,ht)}const O=this._getVertexInputBuiltins(),F={};for(const[ct,ht]of Object.entries(s))F[ct]=ht;if(u!=null)for(const[ct,ht]of Object.entries(u))F[ct]=ht;const E=de.createVertex(F,p,O,i,this.transformFeedbackBindings,I);new he().write(E);const D=this._getFragmentInputBuiltins(f);D.set("glPointCoord","gl_PointCoord"),D.set("glFragCoord","gl_FragCoord");const at=de.createFragment(l,f,D,i,E,this.transformFeedbackBindings);new he().write(at);const ut=this._createShaderBuilder(E,at),ie=ut.generate("vertex"),se=ut.generate("fragment");return this.logShader&&(console.log(ie),console.log(se)),{vertex:ie,fragment:se,uniformBindings:i}}_setDefines(e){for(const t in e)this[t]=e[t]}_setOptionalUniforms(e,t){for(const r of this._options)t[r.propertyKey]?this[r.propertyKey]=this._hydrateUniformGroup(e,r):this[r.propertyKey]=null}_setRequiredUniforms(e){for(const t of this._uniforms)this[t.propertyKey]=this._hydrateUniformGroup(e,t)}_hydrateUniformGroup(e,t){const r=new t.typeCtor;for(const n of r._uniforms??[]){const i=lt(n.typeCtor),s=`u_${t.propertyKey}_${n.propertyKey}`,c=i.type,u=[t.propertyKey,n.propertyKey].join(".");if("type"in n.typeCtor&&n.typeCtor.type==="array"){const a=i;e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else if("type"in n.typeCtor&&n.typeCtor.type==="array-2d"){const a=i;e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformArrayLength:a.size,uniformArrayElementType:a.elementType.type,uniformHydrated:i})}else e.push({shaderModulePath:u,uniformName:s,uniformType:c,uniformHydrated:i});r[n.propertyKey]=i}return r}_hydrateVertexInput(e){const t=this.vertexInput.inputCtor,r=t.locations.reduce((n,i)=>e[i.propertyKey]===!1?n:{...n,[i.propertyKey]:lt(i.typeCtor)},{});for(const{propertyKey:n,typeCtor:i}of t.builtins){const s=lt(i);r[n]=s}return r}_hydrateComputeInput(){return this.computeInput==null?null:this.computeInput.inputCtor.locations.reduce((e,t)=>({...e,[t.propertyKey]:lt(t.typeCtor)}),{})}_injectPackPrecisionFactor(e,t){const r={};for(const n in e){const i=e[n],s=t[n];if(s){if(i.type!=="float"&&i.type!=="vec2"&&i.type!=="vec3"&&i.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${i.type}`);r[n]=i.divide(new y(s))}else r[n]=i}return r}_injectComputePackPrecisionFactor(e,t){const r={},n=new Map;for(const i in this.computeAttributes)for(const s of this.computeAttributes[i]??[])n.set(s,i);for(const i in e){const s=e[i],c=n.get(i);if(!c)continue;const u=t[c];if(u){if(s.type!=="float"&&s.type!=="vec2"&&s.type!=="vec3"&&s.type!=="vec4")throw new Error(`InternalError: packPrecisionFactor requires GenType, but found ${s.type}`);r[i]=s.divide(new y(u))}else r[i]=s}return r}_hydrateFragmentInput(e){const t={};for(const r in e)t[r]=e[r];for(const{propertyKey:r,typeCtor:n}of bt.builtins){const i=lt(n);t[r]=i}return t}_getVertexInputBuiltins(){const e=this.vertexInput.inputCtor,t=new Map;for(const{builtin:r,propertyKey:n}of e.builtins)t.set(n,r);return t}_getFragmentInputBuiltins(e){const t=e.constructor,r=new Map;for(const n of t.builtins??[])r.set(n.propertyKey,n.builtin);return r}_createShaderBuilder(e,t){const r=new Te;return this._insertDebugInfo(r),e.insertVertexShader(r),t.insertFragmentShader(r),r}_insertDebugInfo(e){e.vertex.code.add("// DEFINES: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._defines)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`);e.vertex.code.add(""),e.vertex.code.add("// OPTIONS: "),e.vertex.code.add("// --------------------------------------------------------- ");for(const t of this._options)this[t.propertyKey]?e.vertex.code.add(`//   ${t.propertyKey}: true`):e.vertex.code.add(`//   ${t.propertyKey}: false`)}};export{nn as $,ue as A,Ir as B,lr as C,_r as D,mr as E,Re as F,Wr as G,Mr as H,cr as I,Yr as J,gr as K,Oe as L,un as M,N,nt as O,pe as P,vt as Q,ze as R,pn as S,hn as T,ae as U,fn as V,tr as W,Ye as X,He as Y,ln as Z,rn as _,Rr as a,gn as a0,ur as a1,Dr as a2,Wt as a3,yn as a4,Tr as a5,dn as a6,bt as a7,Qr as a8,fr as a9,oe as aA,_ as aa,Fr as ab,Vr as ac,dr as ad,hr as ae,Zr as af,Gt as ag,an as ah,cn as ai,$r as aj,qe as ak,wr as al,vr as am,yr as an,br as ao,on as ap,sn as aq,tn as ar,Ur as as,Er as at,Pr as au,Cr as av,Sr as aw,kr as ax,qr as ay,Lr as az,Ht as b,zr as c,Gr as d,Kr as e,Nr as f,bn as g,ce as h,Or as i,xr as j,d as k,Xr as l,Br as m,jr as n,Ar as o,ar as p,Be as q,Jr as r,Ot as s,Hr as t,Zt as u,je as v,pr as w,en as x,y,gt as z};
