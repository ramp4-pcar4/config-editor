import{v as Ot}from"./deduplicate-DRKoZSEv-CcA39H3Q.js";import{e as X}from"./InterleavedLayout-C2YUDwKf-BqpIRDcC.js";import{T as a}from"./VertexAttribute-hUz6pozM-Bx3V-z96.js";import{m as et}from"./glUtil-0ZzWJjlL-C5xhkIWX.js";import{d7 as nt,du as w,fh as St,gU as At,ay as dt}from"./index-DRDU_nTl.js";import{P as Et,l as ht,g as wt,A as G,_ as it,y as Q,W as Tt,S as pt,r as ct}from"./vec32-Cj8pVsU0-DklfJOsw.js";import{b as Y}from"./Normals-BNEsVQbp-CRcHq4io.js";const vt=X().vec3f(a.POSITION).u16(a.COMPONENTINDEX).freeze(),yt=X().vec2u8(a.SIDENESS).freeze();et(yt);const H=X().vec3f(a.POSITION0).vec3f(a.POSITION1).vec2i16(a.NORMALCOMPRESSED).u16(a.COMPONENTINDEX).u8(a.VARIANTOFFSET,{glNormalized:!0}).u8(a.VARIANTSTROKE).u8(a.VARIANTEXTENSION,{glNormalized:!0}).freeze(),j=X().vec3f(a.POSITION0).vec3f(a.POSITION1).vec2i16(a.NORMALCOMPRESSED).vec2i16(a.NORMAL2COMPRESSED).u16(a.COMPONENTINDEX).u8(a.VARIANTOFFSET,{glNormalized:!0}).u8(a.VARIANTSTROKE).u8(a.VARIANTEXTENSION,{glNormalized:!0}).freeze();a.POSITION0,a.POSITION1,a.COMPONENTINDEX,a.VARIANTOFFSET,a.VARIANTSTROKE,a.VARIANTEXTENSION,a.NORMALCOMPRESSED,a.NORMAL2COMPRESSED,a.SIDENESS;class Pt{constructor(){this.position0=w(),this.position1=w(),this.faceNormal0=w(),this.faceNormal1=w(),this.componentIndex=0,this.cosAngle=0}}const B=-1;function Mt(t,n,o){const r=t.vertices.position,c=t.vertices.componentIndex,f=N.position0,h=N.position1,I=N.faceNormal0,S=N.faceNormal1,{edges:i,normals:g}=Ct(t),m=i.length/4,A=n.allocate(m);let V=0;const z=m,T=o==null?void 0:o.allocate(z);let W=0,e=0,s=0;$.length=0;for(let d=0;d<m;++d){const y=4*d;r.getVec(i.data[y],f),r.getVec(i.data[y+1],h);const C=$.pushNew();C.index=4*d,C.length=wt(f,h)}$.sort((d,y)=>y.length-d.length);const u=new Array,l=new Array;$.forAll(({length:d,index:y})=>{const C=i.data[y],It=i.data[y+1],ot=i.data[y+2],st=i.data[y+3],rt=st===B;if(r.getVec(C,f),r.getVec(It,h),rt){const E=3*ot;G(I,g.data[E],g.data[E+1],g.data[E+2]),it(S,I),N.componentIndex=c.get(C),N.cosAngle=Q(I,S)}else{let E=3*ot;if(G(I,g.data[E],g.data[E+1],g.data[E+2]),E=3*st,G(S,g.data[E],g.data[E+1],g.data[E+2]),N.componentIndex=c.get(C),N.cosAngle=Q(I,S),Vt(N,xt))return;N.cosAngle<-.9999&&it(S,I)}e+=d,s++,rt||Rt(N,zt)?(n.write(A,V++,N),u.push(d)):Dt(N,Nt)&&(T&&o&&o.write(T,W++,N),l.push(d))});const O=new Float32Array(u.reverse()),v=new Float32Array(l.reverse()),P=T&&o?{instancesData:T.slice(0,W),lodInfo:{lengths:v}}:void 0;return{regular:{instancesData:A.slice(0,V),lodInfo:{lengths:O}},silhouette:P,averageEdgeLength:e/s}}function Rt(t,n){return t.cosAngle<n}function Vt(t,n){return t.cosAngle>n}function Dt(t,n){const o=At(t.cosAngle);return Tt(at,t.position1,t.position0),o*(Q(pt(Ft,t.faceNormal0,t.faceNormal1),at)>0?-1:1)>n}function Ct(t){const n=t.faces.length/3,o=t.faces,r=t.neighbors,c=t.vertices.position;p.length=q.length=0;for(let f=0;f<n;f++){const h=3*f,I=r[h],S=r[h+1],i=r[h+2],g=o[h],m=o[h+1],A=o[h+2];c.getVec(g,D),c.getVec(m,U),c.getVec(A,_),ct(U,U,D),ct(_,_,D),pt(D,U,_),ht(D,D),q.pushArray(D),(I===B||g<m)&&(p.push(g),p.push(m),p.push(f),p.push(I)),(S===B||m<A)&&(p.push(m),p.push(A),p.push(f),p.push(S)),(i===B||A<g)&&(p.push(A),p.push(g),p.push(f),p.push(i))}return{edges:p,normals:q}}class Lt{constructor(){this.index=0,this.length=0}}const $=new nt({allocator:t=>t||new Lt,deallocator:null}),p=new nt({deallocator:null}),q=new nt({deallocator:null}),N=new Pt,Ft=w(),at=w(),D=w(),U=w(),_=w(),Nt=dt(4),xt=Math.cos(Nt),Xt=dt(35),zt=Math.cos(Xt);function lt(t,n,o){const r=n/3,c=new Uint32Array(o+1),f=new Uint32Array(o+1),h=(e,s)=>{e<s?c[e+1]++:f[s+1]++};for(let e=0;e<r;e++){const s=t[3*e],u=t[3*e+1],l=t[3*e+2];h(s,u),h(u,l),h(l,s)}let I=0,S=0;for(let e=0;e<o;e++){const s=c[e+1],u=f[e+1];c[e+1]=I,f[e+1]=S,I+=s,S+=u}const i=new Uint32Array(6*r),g=c[o],m=(e,s,u)=>{if(e<s){const l=c[e+1]++;i[2*l]=s,i[2*l+1]=u}else{const l=f[s+1]++;i[2*g+2*l]=e,i[2*g+2*l+1]=u}};for(let e=0;e<r;e++){const s=t[3*e],u=t[3*e+1],l=t[3*e+2];m(s,u,e),m(u,l,e),m(l,s,e)}const A=(e,s)=>{const u=2*e,l=s-e;for(let O=1;O<l;O++){const v=i[u+2*O],P=i[u+2*O+1];let d=O-1;for(;d>=0&&i[u+2*d]>v;d--)i[u+2*d+2]=i[u+2*d],i[u+2*d+3]=i[u+2*d+1];i[u+2*d+2]=v,i[u+2*d+3]=P}};for(let e=0;e<o;e++)A(c[e],c[e+1]),A(g+f[e],g+f[e+1]);const V=new Int32Array(3*r),z=(e,s)=>e===t[3*s]?0:e===t[3*s+1]?1:e===t[3*s+2]?2:-1,T=(e,s)=>{const u=z(e,s);V[3*s+u]=-1},W=(e,s,u,l)=>{const O=z(e,s);V[3*s+O]=l;const v=z(u,l);V[3*l+v]=s};for(let e=0;e<o;e++){let s=c[e];const u=c[e+1];let l=f[e];const O=f[e+1];for(;s<u&&l<O;){const v=i[2*s],P=i[2*g+2*l];v===P?(W(e,i[2*s+1],P,i[2*g+2*l+1]),s++,l++):v<P?(T(e,i[2*s+1]),s++):(T(P,i[2*g+2*l+1]),l++)}for(;s<u;)T(e,i[2*s+1]),s++;for(;l<O;)T(i[2*g+2*l],i[2*g+2*l+1]),l++}return V}const J=.7;let mt=class{updateSettings(t){this.settings=t,this._edgeHashFunction=t.reducedPrecision?$t:Wt}write(t,n,o){b.seed=this._edgeHashFunction(o);const r=b.getIntRange(0,255),c=b.getIntRange(0,this.settings.variants-1),f=b.getFloat(),h=255*(.5*Ut(-(1-Math.min(f/J,1))+Math.max(0,f-J)/(1-J),1.2)+.5);t.position0.setVec(n,o.position0),t.position1.setVec(n,o.position1),t.componentIndex.set(n,o.componentIndex),t.variantOffset.set(n,r),t.variantStroke.set(n,c),t.variantExtension.set(n,h)}};const M=new Float32Array(6),R=new Uint32Array(M.buffer),x=new Uint32Array(1);function Wt(t){return M[0]=t.position0[0],M[1]=t.position0[1],M[2]=t.position0[2],M[3]=t.position1[0],M[4]=t.position1[1],M[5]=t.position1[2],x[0]=31*(31*(31*(31*(31*(166811+R[0])+R[1])+R[2])+R[3])+R[4])+R[5],x[0]}function $t(t){const n=M;n[0]=L(t.position0[0]),n[1]=L(t.position0[1]),n[2]=L(t.position0[2]),n[3]=L(t.position1[0]),n[4]=L(t.position1[1]),n[5]=L(t.position1[2]),x[0]=5381;for(let o=0;o<R.length;o++)x[0]=31*x[0]+R[o];return x[0]}const ft=1e4;function L(t){return Math.round(t*ft)/ft}function Ut(t,n){return Math.abs(t)**n*Math.sign(t)}const K=class K{constructor(){this._commonWriter=new mt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return H.createBuffer(n)}write(n,o,r){this._commonWriter.write(n,o,r),Et(F,r.faceNormal0,r.faceNormal1),ht(F,F);const{typedBuffer:c,typedBufferStride:f}=n.normalCompressed;Y(c,o,F[0],F[1],F[2],f)}};K.Layout=H,K.glLayout=et(H,1);let Z=K;const k=class k{constructor(){this._commonWriter=new mt}updateSettings(n){this._commonWriter.updateSettings(n)}allocate(n){return j.createBuffer(n)}write(n,o,r){this._commonWriter.write(n,o,r);{const{typedBuffer:c,typedBufferStride:f}=n.normalCompressed;Y(c,o,r.faceNormal0[0],r.faceNormal0[1],r.faceNormal0[2],f)}{const{typedBuffer:c,typedBufferStride:f}=n.normal2Compressed;Y(c,o,r.faceNormal1[0],r.faceNormal1[1],r.faceNormal1[2],f)}}};k.Layout=j,k.glLayout=et(j,1);let tt=k;const F=w(),b=new St;function Jt(t){const n=_t(t.data,t.skipDeduplicate,t.indices,t.indicesLength);return ut.updateSettings(t.writerSettings),gt.updateSettings(t.writerSettings),Mt(n,ut,gt)}function _t(t,n,o,r){if(n){const h=lt(o,r,t.count);return new bt(o,r,h,t)}const c=Ot(t.buffer,t.stride/4,{originalIndices:o}),f=lt(c.indices,r,c.uniqueCount);return{faces:c.indices,facesLength:c.indices.length,neighbors:f,vertices:vt.createView(c.buffer)}}class bt{constructor(n,o,r,c){this.faces=n,this.facesLength=o,this.neighbors=r,this.vertices=c}}const ut=new Z,gt=new tt,Qt=X().vec3f(a.POSITION0).vec3f(a.POSITION1),Yt=X().vec3f(a.POSITION0).vec3f(a.POSITION1).u16(a.COMPONENTINDEX);export{Yt as K,Qt as U,Jt as X,Mt as c,_t as g,vt as r};
